<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>程式柴 CodeShiba</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="程式柴 CodeShiba"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="程式柴 CodeShiba"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Chapter 14: Ajax Posted by on Miguel Grinberg  這是 Flask 大型教程系列的第十四部分，在這部分中，我將使用 Microsoft 的翻譯服務和一點點 JavaScript 來增加即時語言翻譯功能。 在這篇文章中，我將脫離伺服器端開發的 “安全區”，去處理一個同樣重要的伺服器和客戶端組件的功能。你有沒有看到一些網站旁邊用戶生成的內容旁邊顯示的“翻譯”"><meta property="og:type" content="website"><meta property="og:title" content="程式柴 CodeShiba"><meta property="og:url" content="https://codeshiba.com/python/flask-mega-tutorial/chapter_14_ajax.html"><meta property="og:site_name" content="程式柴 CodeShiba"><meta property="og:description" content="Chapter 14: Ajax Posted by on Miguel Grinberg  這是 Flask 大型教程系列的第十四部分，在這部分中，我將使用 Microsoft 的翻譯服務和一點點 JavaScript 來增加即時語言翻譯功能。 在這篇文章中，我將脫離伺服器端開發的 “安全區”，去處理一個同樣重要的伺服器和客戶端組件的功能。你有沒有看到一些網站旁邊用戶生成的內容旁邊顯示的“翻譯”"><meta property="og:locale" content="zh_TW"><meta property="og:image" content="https://codeshiba.com/img/python/flask-mega-tutorial/2024-02-02-11-49-59.png"><meta property="article:published_time" content="2024-02-02T13:08:50.755Z"><meta property="article:modified_time" content="2024-02-02T13:08:50.755Z"><meta property="article:author" content="Luka Huang"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/python/flask-mega-tutorial/2024-02-02-11-49-59.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://codeshiba.com/python/flask-mega-tutorial/chapter_14_ajax.html"},"headline":"程式柴 CodeShiba","image":["https://codeshiba.com/img/python/flask-mega-tutorial/2024-02-02-11-49-59.png"],"datePublished":"2024-02-02T13:08:50.755Z","dateModified":"2024-02-02T13:08:50.755Z","author":{"@type":"Person","name":"Luka Huang"},"publisher":{"@type":"Organization","name":"程式柴 CodeShiba","logo":{"@type":"ImageObject","url":{"text":"程式柴 CodeShiba"}}},"description":"Chapter 14: Ajax Posted by on Miguel Grinberg  這是 Flask 大型教程系列的第十四部分，在這部分中，我將使用 Microsoft 的翻譯服務和一點點 JavaScript 來增加即時語言翻譯功能。 在這篇文章中，我將脫離伺服器端開發的 “安全區”，去處理一個同樣重要的伺服器和客戶端組件的功能。你有沒有看到一些網站旁邊用戶生成的內容旁邊顯示的“翻譯”"}</script><link rel="canonical" href="https://codeshiba.com/python/flask-mega-tutorial/chapter_14_ajax.html"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=417968703" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', '417968703');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="程式柴 CodeShiba" type="application/atom+xml">
</head><body class="is-2-column" id=""><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">程式柴 CodeShiba</a></div><div class="navbar-menu"><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="饅頭計畫" href="/bootcamp">饅頭計畫</a><a class="navbar-item" target="_blank" rel="noopener" title="Youtube" href="https://www.youtube.com/channel/UCDOlnOIq5EjQt1ikKhs4XZg"><i class="fab fa-youtube"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目錄" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜尋" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="content"><h2 id="Chapter-14-Ajax"><a href="#Chapter-14-Ajax" class="headerlink" title="Chapter 14: Ajax"></a>Chapter 14: Ajax</h2><blockquote>
<p>Posted by on <a target="_blank" rel="noopener" href="https://blog.miguelgrinberg.com/author/Miguel%20Grinberg">Miguel Grinberg</a></p>
</blockquote>
<p>這是 Flask 大型教程系列的第十四部分，在這部分中，我將使用 Microsoft 的翻譯服務和一點點 JavaScript 來增加即時語言翻譯功能。</p>
<p>在這篇文章中，我將脫離伺服器端開發的 “安全區”，去處理一個同樣重要的伺服器和客戶端組件的功能。你有沒有看到一些網站旁邊用戶生成的內容旁邊顯示的“翻譯” 連結？這些連結觸發對用戶母語以外的內容進行即時自動翻譯。翻譯後的內容通常插入在原始版本下方。Google 在外語搜索結果中展示這個功能。Facebook 用於帖子，Twitter 用於推文。今天我將向你展示如何將同樣的功能添加到 Microblog！</p>
<p>這一章的 GitHub 連結是：<a target="_blank" rel="noopener" href="https://github.com/miguelgrinberg/microblog/tree/v0.14">Browse</a> <a target="_blank" rel="noopener" href="https://github.com/miguelgrinberg/microblog/archive/v0.14.zip">Zip</a> <a target="_blank" rel="noopener" href="https://github.com/miguelgrinberg/microblog/compare/v0.13...v0.14">Diff</a></p>
<h3 id="伺服器端對比客戶端"><a href="#伺服器端對比客戶端" class="headerlink" title="伺服器端對比客戶端"></a>伺服器端對比客戶端</h3><p>在我迄今為止所遵循的傳統伺服器端模型中，有一個客戶端（由用戶指揮的網頁瀏覽器）向應用伺服器發出 HTTP 請求。一個請求可以僅僅是請求一個 HTML 頁面，就像當你點擊 “個人資料” 連結時，或者它可以觸發一個動作，就像當你在編輯你的個人資料信息後點擊提交按鈕時。在這兩種類型的請求中，伺服器通過將新網頁發送給客戶端來完成請求，要么直接發送，要么通過發出重定向。然後客戶端用新頁面替換當前頁面。只要用戶停留在應用的網站上，這個循環就會重複。在這個模型中，伺服器做所有工作，而客戶端僅僅顯示網頁並接受用戶輸入。</p>
<p>還有一種模型，客戶端扮演一個更積極的角色。在這種模型中，客戶端向伺服器發出請求，伺服器回應一個網頁，但與之前的情況不同的是，不是所有頁面數據都是 HTML，頁面上還有用通常用 JavaScript 寫的代碼。一旦客戶端接收到頁面，它顯示 HTML 部分，並執行代碼，這通常不會立即運行，而是設置事件處理器，在瀏覽器中作為對用戶觸發的動作的回應運行。從那時起，你就有了一個活躍的客戶端，它可以在幾乎不和伺服器聯繫或完全不聯繫的情況</p>
<p>下自行工作。在嚴格的客戶端應用中，整個應用程式隨著初始頁面請求下載到客戶端，然後應用程式完全在客戶端運行，只與伺服器聯繫以檢索或存儲數據，並對那個首個且唯一的網頁的外觀進行動態更改。這類應用被稱為單頁應用或 SPA。</p>
<p>大多數應用都是兩種模型的混合體，結合了兩者的技術。我的 Microblog 應用主要是伺服器端應用，但今天我將為它添加一點客戶端動作。為了實現用戶帖子的即時翻譯，客戶端瀏覽器將向伺服器發送異步請求，伺服器將回應而不會引起頁面刷新。然後客戶端將翻譯動態插入當前頁面。這種技術被稱為 Ajax，是 Asynchronous JavaScript 和 XML（即使這些天 XML 常常被 JSON 替代）的縮寫。</p>
<h3 id="即時翻譯工作流程"><a href="#即時翻譯工作流程" class="headerlink" title="即時翻譯工作流程"></a>即時翻譯工作流程</h3><p>這個應用程式因為 Flask-Babel 的支持，對外語有很好的支持，這使得支持我能找到翻譯的任何語言成為可能。但當然，還缺少一個元素。用戶將以他們自己的語言寫博客帖子，所以很可能用戶會遇到其他用戶用不知道的語言寫的帖子。自動翻譯的質量並不總是很好，但在大多數情況下，如果你只是想大致了解另一種語言的文字意思，它就足夠好了。</p>
<p>這是一個理想的功能，作為 Ajax 服務來實現。考慮到索引或探索頁面可能顯示幾個帖子，其中一些可能是外語。如果我使用傳統的伺服器端技術實現翻譯，對翻譯的請求將導致原始頁面被新頁面取代。事實是，對許多顯示的博客帖子中的一個請求翻譯不是一個足夠大的動作，需要完整的頁面更新，這個功能如果翻譯文本動態地插入原文下方，同時讓頁面的其餘部分保持不變，會運作得更好。</p>
<p>要實作即時自動翻譯需要幾個步驟。首先，我需要一種方法來識別要翻譯的文字的來源語言。我還需要知道每位使用者的首選語言，因為我只想對用其他語言寫的帖子顯示「翻譯」連結。當提供翻譯連結且使用者點擊時，我將需要向伺服器發送 Ajax 請求，伺服器會聯絡第三方翻譯 API。一旦伺服器返回帶有翻譯文字的回應，客戶端的 JavaScript 程式碼會動態地將這段文字插入頁面中。你肯定會注意到，這裡有一些非小題大作的問題。我將逐一來看這些問題。</p>
<h3 id="語言識別"><a href="#語言識別" class="headerlink" title="語言識別"></a>語言識別</h3><p>第一個問題是識別帖子是用什麼語言寫的。這不是一門精確的科學，因為不總是能夠毫無疑問地確定文本的語言，但對於大多數情況來說，自動檢測效果相當不錯。在 Python 中，有一個不錯的語言檢測函式庫叫做 langdetect。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(venv) $ pip install langdetect<br></code></pre></td></tr></table></figure>

<p>計畫是將每篇部落格帖子餵給這個套件，嘗試確定語言。由於進行這項分析有點耗時，我不想每次將帖子呈現到頁面上時都重複這項工作。我將要做的是在提交帖子時設定檢測到的語言。然後，檢測到的語言將被儲存在帖子表中。</p>
<p>首先要做的是向 Post 模型添加一個語言欄位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">app/models.py: 向 Post 模型添加檢測到的語言。<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Post</span>(<span class="hljs-params">db.Model</span>):</span><br>    <span class="hljs-comment">## ...</span><br>    language: so.Mapped[<span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]] = so.mapped_column(sa.String(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure>

<p>如你所記，每當對資料庫模型進行更改時，需要發出資料庫遷移：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">(venv) $ flask db migrate -m <span class="hljs-string">&quot;add language to posts&quot;</span><br>INFO  [alembic.runtime.migration] Context impl SQLiteImpl.<br>INFO  [alembic.runtime.migration] Will assume non-transactional DDL.<br>INFO  [alembic.autogenerate.compare] Detected added column <span class="hljs-string">&#x27;post.language&#x27;</span><br>  Generating migrations/versions/2b017edaa91f_add_language_to_posts.py ... done<br></code></pre></td></tr></table></figure>

<p>然後需要將遷移應用於資料庫：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">(venv) $ flask db upgrade<br>INFO  [alembic.runtime.migration] Context impl SQLiteImpl.<br>INFO  [alembic.runtime.migration] Will assume non-transactional DDL.<br>INFO  [alembic.runtime.migration] Upgrade ae346256b650 -&gt; 2b017edaa91f, add language to posts<br></code></pre></td></tr></table></figure>

<p>現在我可以在提交帖子時檢測並儲存語言：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">app/routes.py: 為新帖子保存語言。<br><br><span class="hljs-keyword">from</span> langdetect <span class="hljs-keyword">import</span> detect, LangDetectException<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/index&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta"></span></span><br><span class="hljs-params"><span class="hljs-meta"> <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-meta">@login_required</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():</span><br>    form = PostForm()<br>    <span class="hljs-keyword">if</span> form.validate_on_submit():<br>        <span class="hljs-keyword">try</span>:<br>            language = detect(form.post.data)<br>        <span class="hljs-keyword">except</span> LangDetectException:<br>            language = <span class="hljs-string">&#x27;&#x27;</span><br>        post = Post(body=form.post.data, author=current_user,<br>                    language=language)<br>        <span class="hljs-comment">## ...</span><br></code></pre></td></tr></table></figure>

<p>有了這個改變，每次提交帖子時，我都會透過 detect() 函式來嘗試確定語言。如果無法識別語言，langdetect 套件會引發一種 LangDetectException 例外。在這種情況下，我會安全起見，將一個空字串保存到資料庫中。我將採用這樣的慣例：任何將語言設為空字串的帖子都被假定為未知語言。</p>
<h3 id="顯示「翻譯」連結"><a href="#顯示「翻譯」連結" class="headerlink" title="顯示「翻譯」連結"></a>顯示「翻譯」連結</h3><p>第二步涉及在當前使用者激活的語言不是帖子語言的情況下，添加一個「翻譯」連結到帖子旁邊。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">app/templates/_post.html: 為帖子添加翻譯連結。<br><br>                &#123;% <span class="hljs-keyword">if</span> post.language <span class="hljs-keyword">and</span> post.language != g.locale %&#125;<br>                &lt;br&gt;&lt;br&gt;<br>                &lt;a href=<span class="hljs-string">&quot;#&quot;</span>&gt;&#123;&#123; _(<span class="hljs-string">&#x27;Translate&#x27;</span>) &#125;&#125;&lt;/a&gt;<br>                &#123;% endif %&#125;<br></code></pre></td></tr></table></figure>

<p>我是在 _post.html 子模板中做這件事，這樣這個功能就會出現在任何顯示部落格帖子的頁面上。翻譯連結僅出現在檢測到語言且此語言與 Flask-Babel 的 locale_selector 函式裝飾的函式選擇的語言不匹配的帖子上。回想一下第 13 章，選定的語言環境被儲存在 before_request 處理程式中的 g.locale。連結的文字需要以一種可以由 Flask-Babel 翻譯的方式添加，所以我在定義它時使用了 _() 函式。</p>
<p>注意，這個連結還沒有關聯任何動作。首先，我想弄清楚如何進行實際的翻譯。</p>
<h3 id="使用第三方翻譯服務"><a href="#使用第三方翻譯服務" class="headerlink" title="使用第三方翻譯服務"></a>使用第三方翻譯服務</h3><p>兩大主要翻譯服務是 Google Cloud Translation API 和 Microsoft Translator Text API。兩者都是付費服務，並且都有針對低量翻譯的免費入門級選項。在這一章中，我將實現 Microsoft 解決方案，但我會以一種易於替換翻譯服務（如果你希望如此）的方式進行。</p>
<p>在你使用 Microsoft Translator API 之前，你需要在 Azure，即 Microsoft 的雲服務，註冊一個帳戶。你可以在他們的免費層上註冊。在註冊過程中，你將被要求提供信用卡號碼，但只要你留在那個服務層級，你的卡不會被收費。</p>
<p>一旦你擁有了 Azure 帳戶，前往 Azure 門戶並點擊「建立資源」按鈕，於搜索框輸入「translator」並按 Enter 鍵。從搜索結果中找到 Translator 資源，然後點擊「建立」按鈕。你現在將看到一個表單，你可以在其中定義將添加到你帳戶的新翻譯資源。按以下方式完成表單：</p>
<ul>
<li>訂閱：選擇「按需付費」</li>
<li>資源群組：點擊「建立新的」，並輸入名稱「microblog-translator」</li>
<li>區域：選擇離你最近的區域</li>
<li>名稱：輸入「microblog」</li>
<li>定價層：選擇「免費 F0（每月最多 2M 字符翻譯）」</li>
</ul>
<p>點擊「審查 + 建立」按鈕繼續到下一頁，在那裡你將看到你所選擇的選項摘要。點擊「建立」按鈕確認建立翻譯資源。如果你等待幾秒鐘，你將在頂部欄中收到一個通知，說明翻譯資源已部署。點擊「前往資源」按鈕，然後在左側欄中點擊「金鑰和端點」選項。你現在將看到兩個金鑰，標籤分別為「金鑰 1」和「金鑰 2」。複製其中一個金鑰到剪貼板，然後將其輸入到你終端機中的環境變量中（如果你正在使用 Microsoft Windows，請將 export 替換為 set）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(venv) $ export MS_TRANSLATOR_KEY=&lt; 粘貼你的金鑰 &gt;<br></code></pre></td></tr></table></figure>

<p>這個金鑰用於向翻譯服務進行身份驗證，因此需要將其添加到應用程式配置中：</p>
<p>config.py：將 Microsoft Translator API 金鑰添加到配置中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment">## ...</span><br>    MS_TRANSLATOR_KEY = os.environ.get(<span class="hljs-string">&#x27;MS_TRANSLATOR_KEY&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>如同所有配置值，我更喜歡將它們安裝在環境變量中，並從那裡導入到 Flask 配置中。對於使能訪問第三方服務的敏感信息，如金鑰或</p>
<p>密碼，這特別重要。你絕對不想在程式碼中明確寫出這些。</p>
<p>Microsoft Translator API 是一個接受 HTTP 請求的網絡服務。Python 中有幾個 HTTP 客戶端，但最受歡迎且易於使用的是 requests 套件。讓我們將其安裝到虛擬環境中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(venv) $ pip install requests<br></code></pre></td></tr></table></figure>

<p>以下你可以看到我編寫的使用 Microsoft Translator API 翻譯文本的函式。我將其放在一個新的 app/translate.py 模組中：</p>
<p>app/translate.py：文本翻譯函式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> flask_babel <span class="hljs-keyword">import</span> _<br><span class="hljs-keyword">from</span> app <span class="hljs-keyword">import</span> app<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">translate</span>(<span class="hljs-params">text, source_language, dest_language</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;MS_TRANSLATOR_KEY&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> app.config <span class="hljs-keyword">or</span> \<br>            <span class="hljs-keyword">not</span> app.config[<span class="hljs-string">&#x27;MS_TRANSLATOR_KEY&#x27;</span>]:<br>        <span class="hljs-keyword">return</span> _(<span class="hljs-string">&#x27;錯誤：翻譯服務未配置。&#x27;</span>)<br>    auth = &#123;<br>        <span class="hljs-string">&#x27;Ocp-Apim-Subscription-Key&#x27;</span>: app.config[<span class="hljs-string">&#x27;MS_TRANSLATOR_KEY&#x27;</span>],<br>        <span class="hljs-string">&#x27;Ocp-Apim-Subscription-Region&#x27;</span>: <span class="hljs-string">&#x27;westus&#x27;</span>,<br>    &#125;<br>    r = requests.post(<br>        <span class="hljs-string">&#x27;https://api.cognitive.microsofttranslator.com&#x27;</span><br>        <span class="hljs-string">&#x27;/translate?api-version=3.0&amp;from=&#123;&#125;&amp;to=&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<br>            source_language, dest_language), headers=auth, json=[&#123;<span class="hljs-string">&#x27;Text&#x27;</span>: text&#125;])<br>    <span class="hljs-keyword">if</span> r.status_code != <span class="hljs-number">200</span>:<br>        <span class="hljs-keyword">return</span> _(<span class="hljs-string">&#x27;錯誤：翻譯服務失敗。&#x27;</span>)<br>    <span class="hljs-keyword">return</span> r.json()[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;translations&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;text&#x27;</span>]<br></code></pre></td></tr></table></figure>

<p>此函式接受要翻譯的文本和源語言代碼與目標語言代碼作為參數，並返回一個帶有翻譯文本的字串。它首先檢查配置中是否有翻譯服務的金鑰，如果未定義金鑰則返回錯誤。錯誤也是一個字串，所以從外部看，這將看起來像翻譯過的文本。這確保了在出錯的情況下，用戶將看到一個有意義的錯誤訊息。</p>
<p>requests 套件的 post() 方法向作為第一個參數給定的 URL 發送一個帶有 POST 方法的 HTTP 請求。我使用的基本 URL 出現在翻譯資源的「金鑰和端點」頁面中，即 <a target="_blank" rel="noopener" href="https://api.cognitive.microsofttranslator.com/%E3%80%82%E7%BF%BB%E8%AD%AF%E7%AB%AF%E9%BB%9E%E7%9A%84%E8%B7%AF%E5%BE%91%E7%82%BA">https://api.cognitive.microsofttranslator.com/。翻譯端點的路徑為</a> /translate，如文檔中所述。</p>
<p>源語言和目標語言需要作為 URL 中的查詢字串參數給出，分別命名為 from 和 to。API 還要求在查詢字串中給出 api-version=3.0 參數。要翻譯的文本需要以 JSON 格式在請求的主體中給出，格式為 {“Text”: “要翻譯的文本在這裡”}。</p>
<p>要與服務進行認證，我需要傳遞我添加到配置中的密鑰。這個密鑰需要在自定義的 HTTP 標頭中提供，名為 Ocp-Apim-Subscription-Key。同樣需要提供部署翻譯資源的區域，在名為 Ocp-Apim-Subscription-Region 的標頭中提供。你需要提供的區域名稱顯示在「金鑰和端點」頁面下方，就在兩個金鑰下面。在我的案例中，是 westus，代表我選擇的西美地區，但如果你選擇了不同的區域，則會有所不同。我已經用這兩個標頭創建了 auth 字典，然後將其傳遞給 requests 的 headers 參數。</p>
<h4 id="獲取響應物件"><a href="#獲取響應物件" class="headerlink" title="獲取響應物件"></a>獲取響應物件</h4><p>requests.post() 方法返回一個響應物件，其中包含服務提供的所有細節。我首先需要檢查狀態碼是否為 200，這是成功請求的代碼。如果我得到任何其他代碼，我知道出現了錯誤，所以在那種情況下我會返回一個錯誤字串。如果狀態碼是 200，則響應的主體中有一個 JSON 編碼的字串與翻譯，所以我需要做的就是使用響應物件的 json() 方法來解碼 JSON，轉換成我可以使用的 Python 字串。JSON 響應是一個翻譯列表，但由於我們翻譯的是單一文字，我可以獲取第一個元素並在翻譯結構內找到實際的翻譯文字。</p>
<h4 id="使用-translate-函式"><a href="#使用-translate-函式" class="headerlink" title="使用 translate() 函式"></a>使用 translate() 函式</h4><p>你可以在下面看到一個 Python 控制台會話，我在其中使用了新的 translate() 函式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> app.translate <span class="hljs-keyword">import</span> translate<br><span class="hljs-meta">&gt;&gt;&gt; </span>translate(<span class="hljs-string">&#x27;Hi, how are you today?&#x27;</span>, <span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-string">&#x27;es&#x27;</span>)  <span class="hljs-comment">## 英文轉西班牙文</span><br><span class="hljs-string">&#x27;Hola, ¿cómo estás hoy?&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>translate(<span class="hljs-string">&#x27;Hi, how are you today?&#x27;</span>, <span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-string">&#x27;de&#x27;</span>)  <span class="hljs-comment">## 英文轉德文</span><br><span class="hljs-string">&#x27;Are Hallo, how you heute?&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>translate(<span class="hljs-string">&#x27;Hi, how are you today?&#x27;</span>, <span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-string">&#x27;it&#x27;</span>)  <span class="hljs-comment">## 英文轉義大利文</span><br><span class="hljs-string">&#x27;Ciao, come stai oggi?&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>translate(<span class="hljs-string">&#x27;Hi, how are you today?&#x27;</span>, <span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-string">&#x27;fr&#x27;</span>)  <span class="hljs-comment">## 英文轉法文</span><br><span class="hljs-string">&quot;Salut, comment allez-vous aujourd&#x27;hui ?&quot;</span><br></code></pre></td></tr></table></figure>
<p>非常酷，對吧？現在是時候將這個功能整合到應用程式中了。</p>
<h3 id="從-Server-開始實作-Ajax"><a href="#從-Server-開始實作-Ajax" class="headerlink" title="從 Server 開始實作 Ajax"></a>從 Server 開始實作 Ajax</h3><p>我將從實現服務器端部分開始。當用戶點擊帖子下方出現的「翻譯」連結時，將向服務器發出異步 HTTP 請求。我將在下一節中向你展示如何做到這一點，所以現在我將專注於實現服務器對這個請求的處理。</p>
<p>一個異步（或 Ajax）請求與我在應用程式中創建的路由和視圖函式類似，唯一的區別是它不返回 HTML 或重定向，而只返回數據，格式為 XML 或更常見的 JSON。下面你可以看到翻譯視圖函式，它調用 Microsoft Translator API，然後以 JSON 格式返回翻譯後的文字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## app/routes.py: 文字翻譯視圖函式</span><br><span class="hljs-keyword">from</span> app.translate <span class="hljs-keyword">import</span> translate<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/translate&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-meta">@login_required</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">translate_text</span>():</span><br>    data = request.get_json()<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;text&#x27;</span>: translate(data[<span class="hljs-string">&#x27;text&#x27;</span>],<br>                              data[<span class="hljs-string">&#x27;source_language&#x27;</span>],<br>                              data[<span class="hljs-string">&#x27;dest_language&#x27;</span>])&#125;<br></code></pre></td></tr></table></figure>
<p>正如你所看到的，這非常簡短。我將這個路由實現為 POST 請求，這是客戶端需要向服務器提交數據時的首選格式。</p>
<p>request.get_json() 方法返回一個字典，其中包含客戶端以 JSON 格式提交的數據。我在這個函式中所做的是調用上一節的 translate() 函式，直接從提交的請求中的 JSON 數據傳遞三個參數。結果被整合到一個名為 text 的單一鍵的字典中，作為響應返回。Flask 會自動將視圖函式返回的字典轉換為 JSON 格式。</p>
<p>例如，如果客戶端想將字串 Hello, World! 翻譯成西班牙文，這個請求的響應將具有以下有效負載：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;Hola, Mundo!&quot;</span>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="從-Client-實作-Ajax"><a href="#從-Client-實作-Ajax" class="headerlink" title="從 Client 實作 Ajax"></a>從 Client 實作 Ajax</h4><p>所以現在服務器能夠通過 /translate URL 提供翻譯，我需要在用戶點擊我上面添加的「翻譯」連結時調用這個 URL，傳遞要翻譯的文字和源語言和目標語言。如果你不熟悉在瀏覽器中使用 JavaScript，這將是一個很好的學習經驗。</p>
<p>在瀏覽器中使用 JavaScript 時，當前顯示的頁面在內部以文檔物件模型或 DOM 表示。這是一個層次結構，參考頁面中存在的所有元素。在這個上下文中運行的 JavaScript 代碼可以對 DOM 進行更改以觸發頁面中的更改。</p>
<p>讓我們首先討論一下我的 JavaScript 代碼在瀏覽器中運行時如何獲取我需要發送到服務器上運行的 translate() 函式的三個參數。要獲取文字，我需要找到包含博客帖子正文的 DOM 節點並讀取其內容。為了便於識別包含博客帖子的 DOM 節點，我將為它們附加一個唯一的 ID。如果你查看 _post.html 模板，渲染帖子正文的行僅為 。我要做的是將這個內容包裹在一個 <span> 元素中。這不會在視覺上有任何改變，但它提供了一個我可以插入識別符的地方：</p>
<p>app/templates/_post.html：為每篇部落格文章增加一個 ID。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;post&#123;&#123; post.id&#125;&#125;&quot;</span>&gt;</span>&#123;&#123; post.body &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>這會為每篇部落格文章指派一個獨特的識別符，格式為 post1、post2 等等，其中數字對應每篇文章在資料庫中的識別符。現在每篇部落格文章都有了獨特的識別符，我可以使用瀏覽器中可用的 document.getElementById() 函式來定位該文章的 <code>&lt;span&gt;</code> 元素並提取其中的文字。例如，如果我想獲得 ID 為 123 的文章的文字，我會這麼做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScriptt">document.getElementById(&#x27;post123&#x27;).innerText<br></code></pre></td></tr></table></figure>

<p>我也希望有一個地方，一旦從伺服器接收到翻譯後，我可以插入翻譯過的文字。因此，我要把「翻譯」連結替換成翻譯過的文字，所以我也需要有一個獨特的識別符來輕鬆定位它：</p>
<p>app/templates/_post.html：為翻譯連結增加一個 ID。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;translation&#123;&#123; post.id&#125;&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>&#123;&#123; _(&#x27;翻譯&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>所以現在對於一個給定的文章 ID，我有一個 post<ID> 節點用於部落格文章，和一個相應的 translation<ID> 節點，我將需要在收到翻譯後替換翻譯連結為翻譯過的文字。</p>
<p>下一步是撰寫一個可以做所有翻譯工作的函式。這個函式將會接受輸入和輸出的 DOM 節點，以及來源和目標語言。然後它會向伺服器發送異步請求，需要三個參數，最後用伺服器返回的翻譯過的文字替換「翻譯」連結。這聽起來像很多工作，但實現其實相當簡短。為了方便，這個函式將被添加在底部的基本範本中，這樣它就可以在應用程式的所有頁面中使用。</p>
<p>app/templates/base.html：客戶端翻譯函式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">...<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">translate</span>(<span class="hljs-params">sourceElem, destElem, sourceLang, destLang</span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-built_in">document</span>.getElementById(destElem).innerHTML =</span><br><span class="javascript">      <span class="hljs-string">&#x27;&lt;img src=&quot;&#123;&#123; url_for(&#x27;</span><span class="hljs-keyword">static</span><span class="hljs-string">&#x27;, filename=&#x27;</span>loading.gif<span class="hljs-string">&#x27;) &#125;&#125;&quot;&gt;&#x27;</span>;</span><br><span class="javascript">    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/translate&#x27;</span>, &#123;</span><br><span class="javascript">      <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,</span><br><span class="javascript">      <span class="hljs-attr">headers</span>: &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json; charset=utf-8&#x27;</span>&#125;,</span><br><span class="javascript">      <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(&#123;</span><br><span class="javascript">        <span class="hljs-attr">text</span>: <span class="hljs-built_in">document</span>.getElementById(sourceElem).innerText,</span><br><span class="javascript">        <span class="hljs-attr">source_language</span>: sourceLang,</span><br><span class="javascript">        <span class="hljs-attr">dest_language</span>: destLang</span><br><span class="javascript">      &#125;)</span><br><span class="javascript">    &#125;)</span><br><span class="javascript">    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();</span><br><span class="javascript">    <span class="hljs-built_in">document</span>.getElementById(destElem).innerText = data.text;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>translate() 函式的前兩個參數是文章和翻譯連結節點的獨特 ID，分別稱為 sourceElem 和 destElem。第三和第四個參數是來源和目標語言代碼。這個函式使用 async 關鍵字定義，這樣它可以使用 await 關鍵字等待異步函式。</p>
<p>這個函式做的第一件事是化妝性的，但非常酷：它添加了一個旋轉器圖片來替換「翻譯」連結，讓使用者知道翻譯正在進行中。這是通過將 destElem 引用的元素的 innerHTML 屬性賦值來完成的，有效地用新的 HTML 替換了該元素的內容。對於旋轉器，我將使用我添加到 app/static/loading.gif 目錄中的一個小動畫 GIF，Flask 保留此目錄用於靜態檔案。為了產生引用此圖片的 URL，我使用 url_for() 函式，傳入特殊的路由名稱 static 並提供圖片的檔案名稱作為參數。你可以在本章的下載套件中找到 loading.gif 圖片。</p>
<p>現在我有了一個漂亮的旋轉器取代了翻譯連結，所以使用者知道要等待一會兒翻譯出現。下一步是向我在上一節中定義的 /translate URL 發送 POST 請求。為此，我將使用瀏覽器提供的 fetch() 函式。這個函式將數據提交給在第一個參數中給出的 URL 的伺服器。作為第二個參數傳遞的字典定義了請求的特徵，包括要使用的 HTTP 方法、任何標頭和帶有數據的請求主體。</p>
<p>請求主體是使用 JSON.stringify() 函式生成的字串，該函式接受帶有數據的字典並返回帶有該數據的 JSON 有效載荷。Content-Type 標頭被添加到請求中，告訴伺服器數據以 JSON 格式給出。</p>
<p>fetch() 函式是異步的，這意味著它返回一個承諾對象。為了簡化其處理，使用 await 關鍵字等待這個函式完成。返回值是一個響應對象。</p>
<p>伺服器在此請求中返回 JSON 數據，因此使用 response.json() 方法將其轉換為字典（在 JavaScript 中稱為「物件」）。這也是一個異步操作，因此再次使用 await 關鍵字。這種轉換的結果存儲在 data 中。</p>
<p>函式的最後一行將 destElem 節點的 innerText 屬性（現在有一個旋轉器圖片）設置為伺服器返回的文字，這要麼是輸入文字的翻譯版本，要麼是一個錯誤訊息。</p>
<h3 id="翻譯連結處理器"><a href="#翻譯連結處理器" class="headerlink" title="翻譯連結處理器"></a>翻譯連結處理器</h3><p>所以現在唯一剩下的就是在使用者點擊「翻譯」連結時，觸發 <code>translate()</code> 函式，並傳入正確的參數。這裡有幾種方法可以做到這一點，我要做的就是將呼叫函式的程式碼嵌入連結的 <code>href</code> 屬性中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">app/templates/_post.html: 翻譯連結處理器。<br><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;translation&#123;&#123; post.id&#125;&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:translate(</span></span><br><span class="hljs-string"><span class="hljs-tag">                &#x27;post&#123;&#123;post.id&#125;&#125;&#x27;,</span></span><br><span class="hljs-string"><span class="hljs-tag">                &#x27;translation&#123;&#123;post.id&#125;&#125;&#x27;,</span></span><br><span class="hljs-string"><span class="hljs-tag">                &#x27;&#123;&#123;post.language&#125;&#125;&#x27;,</span></span><br><span class="hljs-string"><span class="hljs-tag">                &#x27;&#123;&#123;g.locale&#125;&#125;&#x27;);&quot;</span>&gt;</span>&#123;&#123; _(&#x27;Translate&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>鏈接的 <code>href</code> 元素可以接受任何 JavaScript 程式碼，如果它以 <code>javascript:</code> 為前綴，那就是一個方便的方式來呼叫翻譯函式。因為這個鏈接會在伺服器端渲染，當客戶端請求頁面時，我可以使用 <code>&#123;&#123;&#125;&#125;</code> 表達式來產生函式的四個參數。每篇貼文都會有自己的翻譯鏈接，並且有其獨特生成的參數。</p>
<h3 id="翻譯功能完成"><a href="#翻譯功能完成" class="headerlink" title="翻譯功能完成"></a>翻譯功能完成</h3><p>現在即時翻譯功能完成了！如果你已經在你的環境中設置了有效的 Microsoft Translator API 金鑰，你現在應該能夠觸發翻譯。假設你的瀏覽器設置為偏好英語，你需要用另一種語言撰寫貼文來看到「翻譯」連結。以下你可以看到一個例子：</p>
<p><img src="/img/loading.gif" data-original="/img/python/flask-mega-tutorial/2024-02-02-11-49-59.png"></p>
<p>在本章中，我介紹了一些新的文本，這些文本需要被翻譯成應用程式支援的所有語言，因此需要更新翻譯目錄：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(venv) $ flask translate update<br></code></pre></td></tr></table></figure>

<p>對於你自己的專案，你接下來需要編輯每個語言儲存庫中的 <code>messages.po</code> 檔案，以包含這些新測試的翻譯，但我已經在這章節的下載包或 GitHub 儲存庫中創建了西班牙語翻譯。</p>
<p>要發布新的翻譯，它們需要被編譯：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(venv) $ flask translate compile<br></code></pre></td></tr></table></figure>



</div></article></div><div class="card"><div class="card-content"><div id="mc_embed_signup"><form class="validate" action="https://gmail.us20.list-manage.com/subscribe/post?u=669fab1d59a1d7c3ed727d0f0&amp;amp;id=828d363a35" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" target="_blank" novalidate><div id="mc_embed_signup_scroll"><h2>歡迎訂閱，獲取最新資訊、教學文章，一起變強。</h2><div class="mc-field-group"><input class="required email" type="email" placeholder="請輸入 EMAIL" value="" name="EMAIL" id="mce-EMAIL"></div><div class="clear" id="mce-responses"><div class="response" id="mce-error-response" style="display:none"></div><div class="response" id="mce-success-response" style="display:none"></div></div><div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_fb08e7e4c12d83430b6e6d529_bc712ae0b8" tabindex="-1" value=""></div><div class="clear"><input class="button" type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe"></div></div></form></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5">評論</h3><script src="https://utteranc.es/client.js" repo="LukaHuang/codeshiba.com" issue-term="pathname" label="utterances" theme="github-light" crossorigin="anonymous" async></script></div></div></div><!--!--><div class="column column-right is-3-tablet is-3-desktop is-3-widescreen  order-3"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目錄</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Chapter-14-Ajax"><span class="level-left"><span class="level-item">1</span><span class="level-item">Chapter 14: Ajax</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#伺服器端對比客戶端"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">伺服器端對比客戶端</span></span></a></li><li><a class="level is-mobile" href="#即時翻譯工作流程"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">即時翻譯工作流程</span></span></a></li><li><a class="level is-mobile" href="#語言識別"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">語言識別</span></span></a></li><li><a class="level is-mobile" href="#顯示「翻譯」連結"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">顯示「翻譯」連結</span></span></a></li><li><a class="level is-mobile" href="#使用第三方翻譯服務"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">使用第三方翻譯服務</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#獲取響應物件"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">獲取響應物件</span></span></a></li><li><a class="level is-mobile" href="#使用-translate-函式"><span class="level-left"><span class="level-item">1.5.2</span><span class="level-item">使用 translate() 函式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#從-Server-開始實作-Ajax"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">從 Server 開始實作 Ajax</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#從-Client-實作-Ajax"><span class="level-left"><span class="level-item">1.6.1</span><span class="level-item">從 Client 實作 Ajax</span></span></a></li></ul></li><li><a class="level is-mobile" href="#翻譯連結處理器"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">翻譯連結處理器</span></span></a></li><li><a class="level is-mobile" href="#翻譯功能完成"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">翻譯功能完成</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><span>&copy; 2024 Luka Huang</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-TW");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到頁首" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="請輸入關鍵字..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"請輸入關鍵字...","untitled":"(無標題)","posts":"文章","pages":"頁面","categories":"文章分類","tags":"標籤"});
        });</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 30,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>