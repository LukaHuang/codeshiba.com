<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Chapter 13: I18n and L10n - 程式柴 CodeShiba</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="程式柴 CodeShiba"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="程式柴 CodeShiba"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Posted by on Miguel Grinberg  這是 Flask Mega-Tutorial 系列的第十三篇文章，在這篇文章中，我將告訴你如何擴展 Microblog 以支援多種語言。作為這個努力的一部分，你還將學習如何為 flask 命令建立自己的命令列擴展。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: W"><meta property="og:type" content="website"><meta property="og:title" content="Chapter 13: I18n and L10n"><meta property="og:url" content="https://codeshiba.com/python/flask-mega-tutorial/chapter_13_i18n_and_l10n.html"><meta property="og:site_name" content="程式柴 CodeShiba"><meta property="og:description" content="Posted by on Miguel Grinberg  這是 Flask Mega-Tutorial 系列的第十三篇文章，在這篇文章中，我將告訴你如何擴展 Microblog 以支援多種語言。作為這個努力的一部分，你還將學習如何為 flask 命令建立自己的命令列擴展。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: W"><meta property="og:locale" content="zh_TW"><meta property="og:image" content="https://codeshiba.com/img/python/flask-mega-tutorial/2024-02-02-11-35-01.png"><meta property="og:image" content="https://codeshiba.com/img/python/flask-mega-tutorial/2024-02-02-11-36-09.png"><meta property="article:published_time" content="2024-02-24T23:37:13.050Z"><meta property="article:modified_time" content="2024-02-24T23:37:13.050Z"><meta property="article:author" content="Luka Huang"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/python/flask-mega-tutorial/2024-02-02-11-35-01.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://codeshiba.com/python/flask-mega-tutorial/chapter_13_i18n_and_l10n.html"},"headline":"Chapter 13: I18n and L10n","image":["https://codeshiba.com/img/python/flask-mega-tutorial/2024-02-02-11-35-01.png","https://codeshiba.com/img/python/flask-mega-tutorial/2024-02-02-11-36-09.png"],"datePublished":"2024-02-24T23:37:13.050Z","dateModified":"2024-02-24T23:37:13.050Z","author":{"@type":"Person","name":"Luka Huang"},"publisher":{"@type":"Organization","name":"程式柴 CodeShiba","logo":{"@type":"ImageObject","url":{"text":"程式柴 CodeShiba"}}},"description":"Posted by on Miguel Grinberg  這是 Flask Mega-Tutorial 系列的第十三篇文章，在這篇文章中，我將告訴你如何擴展 Microblog 以支援多種語言。作為這個努力的一部分，你還將學習如何為 flask 命令建立自己的命令列擴展。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: W"}</script><link rel="canonical" href="https://codeshiba.com/python/flask-mega-tutorial/chapter_13_i18n_and_l10n.html"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=417968703" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', '417968703');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="程式柴 CodeShiba" type="application/atom+xml">
</head><body class="is-2-column" id=""><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">程式柴 CodeShiba</a></div><div class="navbar-menu"><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="饅頭計畫" href="/bootcamp">饅頭計畫</a><a class="navbar-item" target="_blank" rel="noopener" title="Youtube" href="https://www.youtube.com/channel/UCDOlnOIq5EjQt1ikKhs4XZg"><i class="fab fa-youtube"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目錄" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜尋" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile">Chapter 13: I18n and L10n</h1><div class="content"><blockquote>
<p>Posted by on <a target="_blank" rel="noopener" href="https://blog.miguelgrinberg.com/author/Miguel%20Grinberg">Miguel Grinberg</a></p>
</blockquote>
<p>這是 Flask Mega-Tutorial 系列的第十三篇文章，在這篇文章中，我將告訴你如何擴展 Microblog 以支援多種語言。作為這個努力的一部分，你還將學習如何為 flask 命令建立自己的命令列擴展。</p>
<h3 id="目錄"><a href="#目錄" class="headerlink" title="目錄"></a>目錄</h3><ul>
<li><a href="/python/flask-mega-tutorial/chapter_1_hello_world">Chapter 1: Hello, World!</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_2_templates">Chapter 2: Templates</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_3_web_forms">Chapter 3: Web Forms</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_4_database">Chapter 4: Database</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_5_user_logins">Chapter 5: User Logins</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_6_profile_page_and_avatars">Chapter 6: Profile Page and Avatars</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_7_error_handling">Chapter 7: Error Handling</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_8_followers">Chapter 8: Followers</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_9_pagination">Chapter 9: Pagination</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_10_email_support">Chapter 10: Email Support</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_11_facelift">Chapter 11: Facelift</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_12_dates_and_times">Chapter 12: Dates and Times</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_13_i18n_and_l10n">Chapter 13: I18n and L10n</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_14_ajax">Chapter 14: Ajax</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_15_a_better_application_structure">Chapter 15: A Better Application Structure</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_16_full_text_search">Chapter 16: Full-Text Search</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_17_deployment_on_linux">Chapter 17: Deployment on Linux</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_19_deployment_on_docker_containers">Chapter 19: Deployment on Docker Containers</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_20_some_javascript_magic">Chapter 20: Some JavaScript Magic</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_21_user_notifications">Chapter 21: User Notifications</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_22_background_jobs">Chapter 22: Background Jobs</a></li>
<li><a href="/python/flask-mega-tutorial/chapter_23_application_programming_interfaces_apis">Chapter 23: Application Programming Interfaces （APIs）</a></li>
</ul>
<blockquote>
<p>你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 <a target="_blank" rel="noopener" href="https://amzn.to/3ahVnPN">Amazon</a> 以電子書和平裝書的形式訂購。感謝你的支持！<br>如果你正在尋找 2018 年版本的課程，你可以在<a target="_blank" rel="noopener" href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-2018">這裡</a>找到它。</p>
</blockquote>
<p>本章的主題是國際化和本地化，通常縮寫為 I18n 和 L10n。為了讓不會說英語的人也能友善地使用我的應用程式，我將實現一個翻譯流程。藉助於一個翻譯團隊的幫助，將允許我以多種語言向使用者提供應用程式。</p>
<p>本章的 GitHub 連結包括：瀏覽、壓縮檔、差異。<a target="_blank" rel="noopener" href="https://github.com/miguelgrinberg/microblog/tree/v0.13">Browse</a> <a target="_blank" rel="noopener" href="https://github.com/miguelgrinberg/microblog/archive/v0.13.zip">Zip</a> <a target="_blank" rel="noopener" href="https://github.com/miguelgrinberg/microblog/compare/v0.12...v0.13">Diff</a></p>
<h3 id="介紹-Flask-Babel"><a href="#介紹-Flask-Babel" class="headerlink" title="介紹 Flask-Babel"></a>介紹 Flask-Babel</h3><p>如你所猜，有一個 Flask 擴展使得處理翻譯變得非常容易。這個擴展叫做 Flask-Babel，可以通過 pip 安裝：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(venv) $ pip install flask-babel<br></code></pre></td></tr></table></figure>
<p>在這一章中，我將展示如何將應用程式翻譯成西班牙語，因為我恰好會說這門語言。我也可以與其他語言流利的翻譯者合作，同樣支援這些語言。為了追蹤支援的語言列表，我將加入一個配置變數：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## config.py: 支援的語言列表。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-comment">## ...</span><br>    LANGUAGES = [<span class="hljs-string">&#x27;en&#x27;</span>, <span class="hljs-string">&#x27;es&#x27;</span>]<br></code></pre></td></tr></table></figure>
<p>我在這個應用程式中使用了兩個字母的語言程式碼，但如果你需要更具體，也可以加入國家程式碼。例如，你可以使用 <code>en-US</code>、<code>en-GB</code> 和 <code>en-CA</code> 分別支援美國英語、英國英語和加拿大英語作為不同的語言。</p>
<p><code>Babel</code> 實例是使用一個 <code>locale_selector</code> 參數初始化的，這個參數必須設定為一個函式，該函式將在每個請求中被調用。這個函式可以查看使用者請求並為該請求選擇最佳語言翻譯。以下是 Flask-Babel 擴展的初始化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## app/__init__.py: 初始化 Flask-Babel。</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> request<br><span class="hljs-comment">## ...</span><br><span class="hljs-keyword">from</span> flask_babel <span class="hljs-keyword">import</span> Babel<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_locale</span>():</span><br>    <span class="hljs-keyword">return</span> request.accept_languages.best_match(app.config[<span class="hljs-string">&#x27;LANGUAGES&#x27;</span>])<br><br>app = Flask(__name__)<br><span class="hljs-comment">## ...</span><br>babel = Babel(app, locale_selector=get_locale)<br><span class="hljs-comment">## ...</span><br></code></pre></td></tr></table></figure>

<p>在這裡，我使用了 Flask 的請求物件的一個屬性，稱為 accept_languages。這個物件提供了一個高級接口，用於處理客戶端隨請求發送的 Accept-Language 頭部。這個</p>
<p>頭部指定了客戶端的語言和地區偏好作為一個加權列表。這個頭部的內容可以在瀏覽器的偏好設定頁面中配置，預設值通常從電腦作業系統的語言設定中導入。大多數人甚至不知道這樣的設定存在，但這是有用的，因為使用者可以提供一個首選語言列表，每種語言都有一個權重。如果你好奇，這裡有一個複雜的 Accept-Languages 頭部範例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Accept-Language: da, en-gb;q=0.8, en;q=0.7<br></code></pre></td></tr></table></figure>

<p>這表示丹麥語（da）是首選語言（預設權重 = 1.0），其次是英國英語（en-GB）權重為 0.8，最後是通用英語（en）權重為 0.7。</p>
<p>為了選擇最佳語言，你需要將客戶端請求的語言列表與應用程式支援的語言進行比較，並使用客戶端提供的權重來找到最佳語言。這個邏輯有點複雜，但都封裝在 request.accept_languages 的 best_match() 方法中，它以應用程式提供的語言列表作為參數，並返回最佳選擇。</p>
<h5 id="在-Python-源碼中標記待翻譯文本"><a href="#在-Python-源碼中標記待翻譯文本" class="headerlink" title="在 Python 源碼中標記待翻譯文本"></a>在 Python 源碼中標記待翻譯文本</h5><p>好的，現在來說說壞消息。當讓應用程式支援多種語言時的正常工作流程是在源碼中標記所有需要翻譯的文本。在文本被標記後，Flask-Babel 將掃描所有檔案，並使用 gettext 工具將這些文本提取到一個單獨的翻譯檔案中。不幸的是，這是一項繁瑣的任務，需要完成以啟用翻譯。</p>
<p>我將在這裡展示幾個這種標記的範例，但你可以從上面顯示的本章的 GitHub 庫連結獲得完整的變更集。</p>
<p>為翻譯標記文本的方式是將它們包裹在一個函式呼叫中，習慣上稱為 _()，只是一個底線。最簡單的情況是源碼中出現的字面字符串。這裡是一個 flash() 語句的範例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask_babel <span class="hljs-keyword">import</span> _<br><span class="hljs-comment">## ...</span><br>flash(_(<span class="hljs-string">&#x27;Your post is now live!&#x27;</span>))<br></code></pre></td></tr></table></figure>

<p>這個想法是 <code>_()`` 函式包裹了基礎語言中的文本（在這個案例中是英語）。這個函式將使用 </code>get_locale()<code> 函式選擇的語言來找到給定客戶端的正確翻譯。</code>_()` 函式然後返回翻譯後的文本，在這個案例中將成為 flash() 的參數。</p>
<p>不幸的是，並非所有案例都這麼簡單。考慮應用程式中的另一個 <code>flash()</code> 呼叫：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">flash(<span class="hljs-string">f&#x27;User <span class="hljs-subst">&#123;username&#125;</span> not found.&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>這篇文章中有一個動態組件，它被插入到靜態文本的中間。<code>_()</code> 函式的語法支援這類文本，但它是基於 Python 舊版的字串替代語法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">flash(_(<span class="hljs-string">&#x27;使用者 %(username)s 未找到。&#x27;</span>, username=username))<br></code></pre></td></tr></table></figure>

<p>還有一個更難處理的情況。一些字串常數是在網頁請求外部分配的，通常是在應用程式啟動時，所以在這些文本評估時，無法知道要使用什麼語言。這類的例子包括與表單欄位相關的標籤。處理這些文本的唯一解決方案是找到一種方法，延遲字串的評估，直到它們被使用，這將在實際的請求下進行。Flask-Babel 提供了一個 <code>_()</code> 的延遲評估版本，稱為 <code>lazy_gettext()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask_babel <span class="hljs-keyword">import</span> lazy_gettext <span class="hljs-keyword">as</span> _l<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginForm</span>(<span class="hljs-params">FlaskForm</span>):</span><br>    username = StringField(_l(<span class="hljs-string">&#x27;使用者名稱&#x27;</span>), validators=[DataRequired()])<br>    <span class="hljs-comment">## ...</span><br></code></pre></td></tr></table></figure>

<p>這裡我導入了這個替代翻譯函式，並將它重命名為 <code>_l()</code>，這樣它看起來與原始的 <code>_()</code> 相似。這個新函式將文本包裹在一個特殊物件中，觸發翻譯在稍後執行，當字串在請求內部使用時。</p>
<p>Flask-Login 擴充套件在每次將使用者重定向到登入頁面時都會閃爍一條訊息。這條訊息是英文的，來自擴充套件本身。為了確保這條訊息也被翻譯，我將覆蓋預設訊息，並提供我自己的，用 <code>_l()</code> 函式包裹以進行延遲處理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">login = LoginManager(app)<br>login.login_view = <span class="hljs-string">&#x27;login&#x27;</span><br>login.login_message = _l(<span class="hljs-string">&#x27;請登入以訪問此頁面。&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="在模板中標記待翻譯的文本"><a href="#在模板中標記待翻譯的文本" class="headerlink" title="在模板中標記待翻譯的文本"></a>在模板中標記待翻譯的文本</h3><p>在前一節中，你已經看到如何在 Python 源程式碼中標記可翻譯的文本，但這只是這個過程的一部分，因為模板檔案也有文本。<code>_()</code> 函式也可在模板中使用，因此過程相當類似。例如，請考慮來自 404.html 的 HTML 片段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> 檔案未找到 <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>啟用翻譯的版本變成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; _(&#x27;檔案未找到&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>請注意，這裡除了使用 <code>_()</code> 包裹文本外，還需要加入 <code>&#123;&#123; ...&#125;&#125;</code>，以強制評估 <code>_()</code>，而不是被視為模板中的字面量。</p>
<p>對於有動態組件的更複雜短語，也可以使用參數：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; _(&#x27;嗨，%(username)s！&#x27;, username=current_user.username) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在 <code>_post.html</code> 中有一個特別棘手的情況，讓我花了一段時間才弄明白：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">        &#123;% set user_link %&#125;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">=<span class="hljs-string">&quot;&#123;&#123;url_for(&#x27;user&#x27;, username=post.author.username) &#125;&#125;&quot;</span>&gt;</span><br>                &#123;&#123;post.author.username&#125;&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        &#123;% endset %&#125;<br>        &#123;&#123;_(&#x27;%(username)s 說 %(when)s&#x27;,<br>            username=user_link, when=moment(post.timestamp).fromNow()) &#125;&#125;<br></code></pre></td></tr></table></figure>

<p>這裡的問題是我希望 <code>username</code> 是指向使用者個人檔案頁面的連結，而不僅僅是名稱，所以我必須使用 <code>set</code> 和 <code>endset</code> 模板指令建立一個名為 <code>user_link</code> 的中間變數，然後將其作為參數傳遞給翻譯函式。</p>
<p>如我上面提到的，你可以下載一個應用程式版本，其中所有 Python 源程式碼和模板中的可翻譯文本都已標記。</p>
<h3 id="提取待翻譯文本"><a href="#提取待翻譯文本" class="headerlink" title="提取待翻譯文本"></a>提取待翻譯文本</h3><p>一旦你有了應用程式，所有的 <code>_()</code> 和 <code>_l()</code> 都到位了，你可以使用 pybabel 命令將它們提取到一個 .pot 檔案中，這代表可攜物件模板。這是一個文本檔案，包括所有被標記為需要翻譯的文本。這個檔案的目的是作為為每種語言建立翻譯檔案的模板。</p>
<p>提取過程需要一個小的配置檔案，告訴 pybabel 哪些檔案應該掃描可翻譯的文本。以下是我為這個應用程式建立的 babel.cfg：</p>
<p>babel.cfg: PyBabel 配置檔案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[python: app/**.py]<br>[jinja2: app/templates/**.html]<br></code></pre></td></tr></table></figure>

<p>這些行分別定義了 Python 和 Jinja 模板檔案的檔名模式。Flask-Babel 將尋找匹配這些模式的任何檔案，並掃描它們以尋找被包裹以進行翻譯的文本。</p>
<p>要將所有文本提取到一個 .pot 檔案中，你可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot .<br></code></pre></td></tr></table></figure>

<p><code>pybabel extract</code> 命令讀取在 <code>-F</code> 選項中給定的配置檔案，然後掃描與配置的源匹配的目錄中的所有程式碼和模板檔案，從命令中給定的目錄開始（在這個例子中是當前目錄或 .）。預設情況下，pybabel 將尋找 _() 作為文本標記，但我也使用了 lazy 版本，我導入為 _l()，所以我需要告訴工具也用 -k _l 尋找這些。-o 選項提供輸出檔案的名稱。</p>
<p>我應該指出，messages.pot 檔案不是需要納入項目的檔案。這是一個可以在需要時輕鬆重新生成的檔案，只需再次運行上面的命令。因此，無需將此檔案提交到源程式控制中。</p>
<h3 id="生成語言目錄"><a href="#生成語言目錄" class="headerlink" title="生成語言目錄"></a>生成語言目錄</h3><p>接下來的步驟是為除基礎語言（本案例中為英文）之外的每種語言建立翻譯。我說我要開始加入西班牙語（語言程式碼 es），所以這是執行該操作的指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(venv) $ pybabel init -i messages.pot -d app/translations -l es<br>creating catalog app/translations/es/LC_MESSAGES/messages.po based on messages.pot<br></code></pre></td></tr></table></figure>

<p><code>pybabel init</code> 指令將 <code>messages.pot</code> 檔案作為輸入，並為在 <code>-l</code> 選項中指定的語言，在 <code>-d</code> 選項中給出的目錄寫入新的語言目錄。我將在 <code>app/translations</code> 目錄中安裝所有翻譯，因為 Flask-Babel 預設會在這裡尋找翻譯檔案。該指令將在該目錄內建立一個用於西班牙語資料檔的 <code>es</code> 子目錄。特別地，會有一個新檔案 <code>app/translations/es/LC_MESSAGES/messages.po</code>，需要在那裡進行翻譯。</p>
<p>如果你想支援其他語言，只需重複上述指令，為你想要的每種語言程式碼，以便每種語言都有其自己的帶有 <code>messages.po</code> 檔案的儲存庫。</p>
<p>每個語言儲存庫中建立的 <code>messages.po</code> 檔案使用的格式是語言翻譯的標準格式，即 gettext 工具所使用的格式。這裡有一些西班牙語 <code>messages.po</code> 開頭的幾行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">## PROJECT 的西班牙語翻譯。<br>## 版權所有 (C) 2021 ORGANIZATION<br>## 此檔案在與 PROJECT 項目相同的許可下分發。<br>## FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, 2021.<br>#<br>msgid &quot;&quot;<br>msgstr &quot;&quot;<br>&quot;Project-Id-Version: PROJECT VERSION\n&quot;<br>&quot;Report-Msgid-Bugs-To: EMAIL@ADDRESS\n&quot;<br>&quot;POT-Creation-Date: 2021-06-29 23:23-0700\n&quot;<br>&quot;PO-Revision-Date: 2021-06-29 23:25-0700\n&quot;<br>&quot;Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\n&quot;<br>&quot;Language: es\n&quot;<br>&quot;Language-Team: es &lt;LL@li.org&gt;\n&quot;<br>&quot;Plural-Forms: nplurals=2; plural=(n != 1)\n&quot;<br>&quot;MIME-Version: 1.0\n&quot;<br>&quot;Content-Type: text/plain; charset=utf-8\n&quot;<br>&quot;Content-Transfer-Encoding: 8bit\n&quot;<br>&quot;Generated-By: Babel 2.5.1\n&quot;<br><br>#: app/email.py:21<br>msgid &quot;[Microblog] Reset Your Password&quot;<br>msgstr &quot;&quot;<br><br>#: app/forms.py:12 app/forms.py:19 app/forms.py:50<br>msgid &quot;Username&quot;<br>msgstr &quot;&quot;<br><br>#: app/forms.py:13 app/forms.py:21 app/forms.py:43<br>msgid &quot;Password&quot;<br>msgstr &quot;&quot;<br></code></pre></td></tr></table></figure>

<p>如果跳過標頭，你會看到接下來是從 _() 和 _l() 呼叫中提取的字串列表。對於每個文本，你會得到你應用中文本位置的參考。然後 <code>msgid</code> 行包含基礎語言的文本，接下來的 <code>msgstr</code> 行包含一個空字串。這些空字串需要被編輯以包含目標語言中的文本版本。</p>
<p>有許多與 <code>.po</code> 檔案一起工作的翻譯應用。如果你覺得編輯文本檔案就足夠了，但如果你正在處理一個大型項目，則可能建議使用專業的翻譯編輯器。最受歡迎的翻譯應用是開源的  <a target="_blank" rel="noopener" href="http://www.poedit.net/">poedit</a>，那麼 <a target="_blank" rel="noopener" href="https://vim.sourceforge.io/scripts/script.php?script_id=695">po.vim</a><br> 插件提供了一些鍵映射，使這些檔案的工作更容易。</p>
<p>下面你可以看到我加入翻譯後的西班牙語 <code>messages.po</code> 的一部分：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#: app/email.py:21</span><br>msgid <span class="hljs-string">&quot;[Microblog] Reset Your Password&quot;</span><br>msgstr <span class="hljs-string">&quot;[Microblog] Nueva Contraseña&quot;</span><br><br><span class="hljs-comment">#: app/forms.py:12 app/forms.py:19 app/forms.py:50</span><br>msgid <span class="hljs-string">&quot;Username&quot;</span><br>msgstr <span class="hljs-string">&quot;Nombre de usuario&quot;</span><br><br><span class="hljs-comment">#: app/forms.py:13 app/forms.py:21 app/forms.py:43</span><br>msgid <span class="hljs-string">&quot;Password&quot;</span><br>msgstr <span class="hljs-string">&quot;Contraseña&quot;</span><br></code></pre></td></tr></table></figure>

<p>本章的下載包也包含了這個檔案，所有翻譯都已就位，所以你不必為這個應用擔心這部分。</p>
<p><code>messages.po</code> 檔案是翻譯的一種源檔案。當你想開始使用這些翻譯文本時，需要將此檔案編譯成一種在應用運行時使用的高效格式。要編譯應用的所有翻譯，可以按以下方式使用 <code>pybabel compile</code> 指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">(venv) $ pybabel compile -d app/translations<br>compiling catalog app/translations/es/LC_MESSAGES/messages.po to<br>app/translations/es/LC_MESSAGES/messages.mo<br></code></pre></td></tr></table></figure>

<p>這個操作在每個語言儲存庫中的 <code>messages.po</code> 旁邊加入了一個 <code>messages.mo</code> 檔案。<code>.mo</code> 檔案是 Flask-Babel 將用於加載應用翻譯的檔案。</p>
<p>在為西班牙語或你加入到專案中的任何其他語言建立了 <code>messages.mo</code> 檔案後，這些語言就準備好在應用中使用了。如果你想看看應用以西班牙語顯示的樣子，你可以編輯網頁瀏覽器中的語言配置，將西班牙語設為首選語言。對於 Chrome，這在設置頁面的進階部分：</p>
<p><img src="/img/loading.gif" data-original="/img/python/flask-mega-tutorial/2024-02-02-11-35-01.png"></p>
<p>如果你不想更改瀏覽器設置，另一種選擇是通過使 <code>get_locale()</code> 函式始終返回你想使用的語言來強制設置語言。對於西班牙語，你可以這樣做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">app/__init__.py: 選擇最佳語言。<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_locale</span>():</span><br>    <span class="hljs-comment">## return request.accept_languages.best_match(app.config[&#x27;LANGUAGES&#x27;])</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;es&#x27;</span><br></code></pre></td></tr></table></figure>

<p>以西班牙語配置瀏覽器運行應用，或 <code>get_locale()</code> 函式返回 es，將使所有文本在使用應用時以西班牙語顯示。</p>
<h3 id="更新翻譯"><a href="#更新翻譯" class="headerlink" title="更新翻譯"></a>更新翻譯</h3><p>當使用翻譯時，一個常見情況是你可能想要開始使用一個尚未完成的翻譯檔案。這完全沒問題，你可以編譯一個不完整的 messages.po 檔案，任何可用的翻譯將被使用，而任何缺失的翻譯將使用基礎語言。然後你可以繼續進行翻譯，並再次編譯以更新 messages.mo 檔案，隨著你的進展。</p>
<p>另一個常見情況是，當你加入 _() 包裝器時，可能漏掉了一些文本。在這種情況下，你會發現那些你漏掉的文本將保持英文，因為 Flask-Babel 對它們一無所知。在這種情況下，當你發現沒有包裝器的文本時，你會想要加入 _() 或 _l() 包裝器，然後進行更新程式，這包括兩個步驟：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot .<br>(venv) $ pybabel update -i messages.pot -d app/translations<br></code></pre></td></tr></table></figure>

<p>extract 命令與我之前發出的命令相同，但現在它將生成一個新版本的 messages.pot，其中包含所有之前的文本以及你最近使用 _() 或 _l() 包裝的任何新文本。update 命令將新的 messages.pot 檔案合併到與專案關聯的所有 messages.po 檔案中。這將是一個智能合併，其中任何現有文本將保持不變，而僅在 messages.pot 中加入或刪除的條目將受到影響。</p>
<p>更新了 messages.po 之後，你可以繼續翻譯任何新文本，然後再次編譯訊息，使其可供應用程式使用。</p>
<h3 id="翻譯日期和時間"><a href="#翻譯日期和時間" class="headerlink" title="翻譯日期和時間"></a>翻譯日期和時間</h3><p>現在我有了 Python 程式碼和範本中所有文本的完整西班牙文翻譯，但如果你以西班牙文運行應用程式並且觀察仔細，你會注意到還有一些東西出現在英文中。我指的是由 Flask-Moment 和 moment.js 生成的時間戳，顯然它們沒有被包括在翻譯努力中，因為這些包生成的文本都不是應用程式的原始程式碼或範本的一部分。</p>
<p>moment.js 函式庫確實支援本地化和國際化，所以我需要做的就是配置適當的語言。Flask-Babel 透過 get_locale() 函式為給定請求返回選擇的語言和地區，所以我打算做的是在 before_request 處理器中將地區加入到 g 物件中，這樣我就可以從基礎範本中訪問它：</p>
<p>app/routes.py：在 flask.g 中儲存選擇的語言。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## ...</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> g<br><span class="hljs-keyword">from</span> flask_babel <span class="hljs-keyword">import</span> get_locale<br><br><span class="hljs-comment">## ...</span><br><br><span class="hljs-meta">@app.before_request</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">before_request</span>():</span><br>    <span class="hljs-comment">## ...</span><br>    g.locale = <span class="hljs-built_in">str</span>(get_locale())<br></code></pre></td></tr></table></figure>

<p>Flask-Babel 的 get_locale() 函式返回一個地區物件，但我只想要有語言程式碼，可以通過將物件轉換為字串</p>
<p>獲得。現在我有了 g.locale，我可以從基礎範本中訪問它，以配置 moment.js 的正確語言：</p>
<p>app/templates/base.html：為 moment.js 設定地區。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">...<br><br>    &#123;&#123;moment.include_moment() &#125;&#125;<br>    &#123;&#123;moment.lang(g.locale) &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>現在所有的日期和時間應該以與文本相同的語言出現。以下你可以看到應用程式以西班牙文的樣子：</p>
<p><img src="/img/loading.gif" data-original="/img/python/flask-mega-tutorial/2024-02-02-11-36-09.png"></p>
<p>此時，除了使用者在部落格帖子或個人簡介中提供的文本之外，所有文本都應該可以翻譯成其他語言。</p>
<h4 id="命令行增強"><a href="#命令行增強" class="headerlink" title="命令行增強"></a>命令行增強</h4><p>你可能會同意我認為 pybabel 命令有點長且難以記住。我將利用這個機會向你展示如何建立與 flask 命令集成的自定義命令。到目前為止，你已經看到我使用 flask run、flask shell 和 Flask-Migrate 擴充功能提供的幾個 flask db 子命令。實際上，向 flask 加入特定於應用程式的命令也很容易。所以我現在要做的是建立一些簡單的命令，觸發特定於此應用程式的所有參數的 pybabel 命令。我要加入的命令是：</p>
<ul>
<li><code>flask translate init LANG</code> 來加入新語言</li>
<li><code>flask translate update</code> 來更新所有語言儲存庫</li>
<li><code>flask translate compile</code> 來編譯所有語言儲存庫</li>
</ul>
<p>babel export 步驟不會是一個命令，因為生成 messages.pot 檔案總是運行 init 或 update 命令的先決條件，因此這些命令的實現將生成翻譯範本檔案作為臨時檔案。</p>
<p>Flask 依賴於 Click 進行所有命令行操作。像 translate 這樣的命令，是幾個子命令的根，通過 app.cli.group() 裝飾器建立。我將這些命令放在一個名為 app/cli.py 的新模組中：</p>
<p>app/cli.py：翻譯命令組。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> app <span class="hljs-keyword">import</span> app<br><br><span class="hljs-meta">@app.cli.group()</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">translate</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;翻譯和本地化命令。&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

<p>命令的名稱來自被裝飾的函式，幫助訊息來自文件字串。由於這是一個僅用於為子命令提供基礎的父命令，該函式本身不需要做任何事情。</p>
<p>update 和 compile 實現起來很簡單，因為它們不需要任何參數：</p>
<p>app/cli.py：更新和編譯子命令。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment">## ...</span><br><br><span class="hljs-meta">@translate.command()</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;更新所有語言。&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> os.system(<span class="hljs-string">&#x27;pybabel extract -F babel.cfg -k _l -o messages.pot .&#x27;</span>):<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;extract 命令失敗&#x27;</span>)<br>    <span class="hljs-keyword">if</span> os.system(<span class="hljs-string">&#x27;pybabel update -i messages.pot -d app/translations&#x27;</span>):<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;update 命令失敗&#x27;</span>)<br>    os.remove(<span class="hljs-string">&#x27;messages.pot&#x27;</span>)<br><br><span class="hljs-meta">@translate.command()</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compile</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;編譯所有語言。&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> os.system(<span class="hljs-string">&#x27;pybabel compile -d app/translations&#x27;</span>):<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;compile 命令失敗&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h4 id="注意函式裝飾器的來源"><a href="#注意函式裝飾器的來源" class="headerlink" title="注意函式裝飾器的來源"></a>注意函式裝飾器的來源</h4><p>請注意這些函式的裝飾器是來自 translate 父函式。這可能看起來令人困惑，因為 translate() 是一個函式，但這是 Click 構建命令群組的標準方式。與 translate() 函式一樣，這些函式的文件字串用作 –help 輸出中的幫助訊息。</p>
<p>你可以看到對於所有命令，我執行它們並確保返回值是零，這意味著命令沒有返回任何錯誤。如果命令出錯，那麼我將引發 RuntimeError，這將導致腳本停止。update() 函式將 extract 和 update 步驟結合在同一個命令中，如果一切成功，它會在更新完成後刪除 messages.pot 檔案，因為這個檔案在需要時可以輕鬆重新生成。</p>
<h4 id="初始化命令"><a href="#初始化命令" class="headerlink" title="初始化命令"></a>初始化命令</h4><p>init 命令以新語言程式碼為參數。實現如下：</p>
<p>app/cli.py：Init 子命令。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> click<br><br><span class="hljs-meta">@translate.command()</span><br><span class="hljs-meta">@click.argument(<span class="hljs-params"><span class="hljs-string">&#x27;lang&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span>(<span class="hljs-params">lang</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;初始化一種新語言。&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> os.system(<span class="hljs-string">&#x27;pybabel extract -F babel.cfg -k _l -o messages.pot .&#x27;</span>):<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;extract 命令失敗&#x27;</span>)<br>    <span class="hljs-keyword">if</span> os.system(<br>            <span class="hljs-string">&#x27;pybabel init -i messages.pot -d app/translations -l&#x27;</span> + lang):<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;init 命令失敗&#x27;</span>)<br>    os.remove(<span class="hljs-string">&#x27;messages.pot&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>這個命令使用 @click.argument 裝飾器來定義語言程式碼。Click 將命令中提供的值作為參數傳遞給處理函式，然後我將該參數納入 init 命令中。</p>
<h4 id="啟用這些命令的最後一步"><a href="#啟用這些命令的最後一步" class="headerlink" title="啟用這些命令的最後一步"></a>啟用這些命令的最後一步</h4><p>要讓這些命令工作的最後一步是導入它們，以便命令得到註冊。我決定在頂層目錄的 microblog.py 檔案中這樣做：</p>
<p>microblog.py：註冊命令行命令。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> app <span class="hljs-keyword">import</span> cli<br></code></pre></td></tr></table></figure>

<p>在這裡，我需要做的就是導入新的 cli.py 模組，無需進行任何操作，因為導入會使命令裝飾器運行並註冊每個命令。</p>
<p>此時，運行 flask –help 將列出 translate 命令作為一個選項。而 flask translate –help 將顯示我定義的三個子命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">(venv) $ flask translate --help<br>用法：flask translate [選項] 命令 [參數]...<br><br>  翻譯和本地化命令。<br><br>選項：<br>  --help  顯示此訊息並退出。<br><br>命令：<br>  compile  編譯所有語言。<br>  init     初始化一種新語言。<br>  update   更新所有語言。<br></code></pre></td></tr></table></figure>

<p>所以現在，工作流程更簡單了，不需要記住長而複雜的命令。要加入新語言，你使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(venv) $ flask translate init &lt; 語言程式碼 &gt;<br></code></pre></td></tr></table></figure>

<p>在對 _() 和 _l() 語言標記進行更改後更新所有語言：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(venv) $ flask translate update<br></code></pre></td></tr></table></figure>

<p>在更新翻譯檔案後編譯所有</p>
<p>語言：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(venv) $ flask translate compile<br></code></pre></td></tr></table></figure>






</div></article></div><div class="card"><div class="card-content"><div id="mc_embed_signup"><form class="validate" action="https://gmail.us20.list-manage.com/subscribe/post?u=669fab1d59a1d7c3ed727d0f0&amp;amp;id=828d363a35" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" target="_blank" novalidate><div id="mc_embed_signup_scroll"><h2>歡迎訂閱，獲取最新資訊、教學文章，一起變強。</h2><div class="mc-field-group"><input class="required email" type="email" placeholder="請輸入 EMAIL" value="" name="EMAIL" id="mce-EMAIL"></div><div class="clear" id="mce-responses"><div class="response" id="mce-error-response" style="display:none"></div><div class="response" id="mce-success-response" style="display:none"></div></div><div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_fb08e7e4c12d83430b6e6d529_bc712ae0b8" tabindex="-1" value=""></div><div class="clear"><input class="button" type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe"></div></div></form></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5">評論</h3><script src="https://utteranc.es/client.js" repo="LukaHuang/codeshiba.com" issue-term="pathname" label="utterances" theme="github-light" crossorigin="anonymous" async></script></div></div></div><!--!--><div class="column column-right is-3-tablet is-3-desktop is-3-widescreen  order-3"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目錄</h3><ul class="menu-list"><li><a class="level is-mobile" href="#目錄"><span class="level-left"><span class="level-item">1</span><span class="level-item">目錄</span></span></a></li><li><a class="level is-mobile" href="#介紹-Flask-Babel"><span class="level-left"><span class="level-item">2</span><span class="level-item">介紹 Flask-Babel</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#在-Python-源碼中標記待翻譯文本"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">在 Python 源碼中標記待翻譯文本</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#在模板中標記待翻譯的文本"><span class="level-left"><span class="level-item">3</span><span class="level-item">在模板中標記待翻譯的文本</span></span></a></li><li><a class="level is-mobile" href="#提取待翻譯文本"><span class="level-left"><span class="level-item">4</span><span class="level-item">提取待翻譯文本</span></span></a></li><li><a class="level is-mobile" href="#生成語言目錄"><span class="level-left"><span class="level-item">5</span><span class="level-item">生成語言目錄</span></span></a></li><li><a class="level is-mobile" href="#更新翻譯"><span class="level-left"><span class="level-item">6</span><span class="level-item">更新翻譯</span></span></a></li><li><a class="level is-mobile" href="#翻譯日期和時間"><span class="level-left"><span class="level-item">7</span><span class="level-item">翻譯日期和時間</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#命令行增強"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">命令行增強</span></span></a></li><li><a class="level is-mobile" href="#注意函式裝飾器的來源"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">注意函式裝飾器的來源</span></span></a></li><li><a class="level is-mobile" href="#初始化命令"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">初始化命令</span></span></a></li><li><a class="level is-mobile" href="#啟用這些命令的最後一步"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">啟用這些命令的最後一步</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><span>&copy; 2024 Luka Huang</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-TW");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到頁首" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="請輸入關鍵字..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"請輸入關鍵字...","untitled":"(無標題)","posts":"文章","pages":"頁面","categories":"文章分類","tags":"標籤"});
        });</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 30,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>