{"pages":[{"title":"【 JavaScript 】Ajax 小學堂","text":"回呼地獄 (Callback Hell)讓我們使用 AJAX 來模擬通過一系列關卡的過程，並展示回呼地獄（Callback hell）的情況。在這個例子中，我們將使用 jQuery 的 AJAX 函式來發送非同步請求，成功後呼叫回呼函式。 假設每個關卡需要獲取一些資源，我們將透過 AJAX 來模擬這個過程。以下是範例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function passStage1(callback) { console.log(&quot;通過關卡 1...&quot;); $.ajax({ url: &quot;/passStage1&quot;, method: &quot;GET&quot;, success: function() { console.log(&quot;關卡 1 完成！&quot;); callback(); }, error: function() { console.error(&quot;通過關卡 1 時發生錯誤！&quot;); } });}function passStage2(callback) { console.log(&quot;通過關卡 2...&quot;); $.ajax({ url: &quot;/passStage2&quot;, method: &quot;GET&quot;, success: function() { console.log(&quot;關卡 2 完成！&quot;); callback(); }, error: function() { console.error(&quot;通過關卡 2 時發生錯誤！&quot;); } });}function passStage3(callback) { console.log(&quot;通過關卡 3...&quot;); $.ajax({ url: &quot;/passStage3&quot;, method: &quot;GET&quot;, success: function() { console.log(&quot;關卡 3 完成！&quot;); callback(); }, error: function() { console.error(&quot;通過關卡 3 時發生錯誤！&quot;); } });}passStage1(function() { passStage2(function() { passStage3(function() { console.log(&quot;恭喜你！你通過了所有關卡並贏得了遊戲！&quot;); }); });}); 在這個例子中，我們定義了三個函式 passStage1、passStage2 和 passStage3，每個函式代表一個關卡。當玩家通過一個關卡後，將執行下一個關卡的函式。使用 AJAX 發送請求，當請求成功後，執行回呼函式，通過巢狀的回呼函式來模擬玩家通過一系列關卡的過程。 這樣看起來「不夠地獄」，實務上可能寫成這樣： 1234567891011121314151617181920212223242526272829303132333435console.log(&quot;通過關卡 1...&quot;);$.ajax({ url: &quot;/passStage1&quot;, method: &quot;GET&quot;, success: function() { console.log(&quot;關卡 1 完成！&quot;); console.log(&quot;通過關卡 2...&quot;); $.ajax({ url: &quot;/passStage2&quot;, method: &quot;GET&quot;, success: function() { console.log(&quot;關卡 2 完成！&quot;); console.log(&quot;通過關卡 3...&quot;); $.ajax({ url: &quot;/passStage3&quot;, method: &quot;GET&quot;, success: function() { console.log(&quot;關卡 3 完成！&quot;); console.log(&quot;恭喜你！你通過了所有關卡並贏得了遊戲！&quot;); }, error: function() { console.error(&quot;通過關卡 3 時發生錯誤！&quot;); } }); }, error: function() { console.error(&quot;通過關卡 2 時發生錯誤！&quot;); } }); }, error: function() { console.error(&quot;通過關卡 1 時發生錯誤！&quot;); }}); 這種巢狀的回呼函式導致了程式碼巢狀層級過深，形成回呼地獄，讓程式碼難以閱讀和維護。這會增加程式碼出錯的可能性，並讓程式碼難以擴展和修改。 當聊到回呼地獄 (Callback Hell) 的時候，很常看到這張圖，可以很貼切的說明上方的情況。 Promise為了解決這個回呼函式的問題，Promise 誕生了！我們使用現在瀏覽器已經內建的 fetch 來說明 Promise 的使用方式。來看一個實際的例子來說明 fetch 和 Promise 的關係以及如何使用它們。 假設我們想要從一個提供 JSON 資料的 API 獲取一些資訊。這個過程包含發出請求、接收響應並處理這個響應。我們將使用 fetch 函式來發出請求，然後使用 Promise 的方法來處理結果。 1234567891011121314151617// 向一個 API 發出請求來獲取使用者資訊fetch('https://jsonplaceholder.typicode.com/users/1') .then(response =&gt; { // 首先檢查請求是否成功，如果成功，我們將響應轉換為 JSON 格式 if (!response.ok) { throw new Error('網路請求失敗'); } return response.json(); // 返回一個新的 Promise 物件，這個物件解析了 JSON 資料 }) .then(data =&gt; { // 處理轉換後的 JSON 資料 console.log(data); }) .catch(error =&gt; { // 處理任何在請求過程中發生的錯誤 console.error('請求失敗:', error); }); 在這個例子中： 我們使用 fetch 向 https://jsonplaceholder.typicode.com/users/1 發出 GET 請求。 fetch 返回一個 Promise 物件，這個物件最終會被解析成 HTTP 響應。 使用 .then() 方法來設定當 Promise 物件解析成功時的回調函式。如果 HTTP 響應表明請求成功（response.ok 為真），我們將響應體轉換為 JSON。response.json() 也返回一個 Promise 物件，因此我們可以在它後面再接一個 .then() 來處理 JSON 資料。 第二個 .then() 接收到從 JSON 轉換的資料，並將其輸出到控制台。 如果在任何一步驟發生錯誤（例如網路問題或 JSON 解析錯誤），.catch() 方法將捕獲這些錯誤，並允許我們處理它們。 這個例子展示了 fetch 和 Promise 如何共同工作來處理非同步 HTTP 請求，以及如何使用 .then() 和 .catch() 方法來處理成功和失敗的情況。 fetch vs Axios接下來我們來進行一個常見的比較 fetch vs Axios。我們分別使用 fetch 和 axios 來發送 GET 請求，並進行比較。假設我們需要從一個 API 獲取使用者列表，以下是使用 fetch 和 axios 的範例程式碼。 使用 fetch12345678910111213fetch('https://jsonplaceholder.typicode.com/users') .then(response =&gt; { if (!response.ok) { throw new Error('Network response was not ok'); } return response.json(); }) .then(data =&gt; { console.log('Fetch Users:', data); }) .catch(error =&gt; { console.error('Fetch Error:', error); }); 使用 axios1234567axios.get('https://jsonplaceholder.typicode.com/users') .then(response =&gt; { console.log('Axios Users:', response.data); }) .catch(error =&gt; { console.error('Axios Error:', error); }); 比較我們進一步比較 fetch 和 axios 在其他方面的差異。 特性 fetch axios 支援度 fetch 是 Web APIs 的一部分，支援度較好，可以在現代瀏覽器中直接使用。 axios 是一個基於 Promise 的 HTTP 客戶端，可以在瀏覽器和 Node.js 中使用，支援度也很好。 攔截器 不支援攔截器，需要手動處理每個請求和回應。 支援攔截器，可以在請求和回應被發送或接收之前進行一些處理，例如添加公共的請求 header、logger 等。 取消請求 不支援取消請求功能，一旦請求發送就無法取消。 支援取消請求功能，可以在需要時取消正在進行的請求，以節省資源和提高性能。 自動轉換 JSON 數據 需要手動調用. json() 方法將回應轉換為 JSON 格式。 自動將回應的 JSON 數據轉換為 JavaScript 物件，無需手動處理。 客製化配置 不支援設置全局的默認配置，每次請求需要手動設置相關選項。 支援設置全局的默認配置，例如設置基本的 URL、超時時間、請求頭等，方便統一管理和使用。 axios 提供了許多 fetch 所不具備的便利功能，例如攔截器、取消請求、自動轉換 JSON 數據等，這使得 axios 在實際應用中更加靈活和方便。","link":"/javascript/ajax.html"},{"title":"","text":"Flask Mega-Tutorial Posted by on Miguel Grinberg 歡迎！你即將開始學習如何使用 Python 和 Flask 框架建立網頁應用程式。在這第一章中，你將學習如何設置一個 Flask 專案。在本章結束時，你將能夠讓一個簡單的 Flask 網頁應用程式在你的電腦上運行！ 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs）","link":"/python/flask-mega-tutorial.html"},{"title":"饅頭計畫 #3","text":"訓練目標用六個月的時間，用任務導向的方式，將你訓練成一名有競爭力的工程師。六個月後將會完成專屬個人作品， 講師介紹嗨，大家好！我是Luka，曾在外商擔任資深工程師。我擅長將前後端技術相互結合，打造各種不同類型的網站，並以直白的教學方式，解釋複雜的技術，讓初學者能夠輕鬆學習。 我專注於初學者教學，經營著 程式柴 Youtube 頻道 ，提供大量免費的教學內容，包括 HTML、CSS、JS、Python … 等等的教學。 如果你想更了解我，請看我過去在 Medium 撰寫的文章，包含了一些技術文章與一些軟性的文章。 此外，我也喜歡研究硬技術，曾經在 COSCUP、MOPCON、RubyConf 等大型研討會上擔任講師。如果你對我過去的演講內容有興趣，請參考我過去的投影片。 訓練方式全線上進行，Level 1 &amp; 2 有需要時進行線上會議。Level 3 &amp; 4 每週線上開會同步學習進度，展示學習成果，討論技術難點。如果選擇「背水一戰」，每週請準備 50 小時以上的學習時間。如果選擇「持久戰」，每週請自行設定學習時間。(詳細定義請參照背水一戰 vs 持久戰) 時程列表 申請時間：即日起 ~ 2023/12/28 結果通知：提出申請後的兩週內回覆是否通過申請。 Level 1 (4 週)：2024/01/01 ~ 2024/01/28 Level 2 (4 週)：2024/01/29 ~ 2024/02/25 Level 3 (8 週)：2024/02/26 ~ 2024/04/21 Level 4 (10 週)： 2024/04/22 ~ 2024/06/16 適合怎樣的人Q：沒接觸過程式，適合嗎？A：饅頭計畫是為零基礎程式小白設計的訓練計畫，身為程式小白，有非常多的技術需要進修，每個禮拜需要花 60 小時的學習時間才可以跟上進度。 Q：已經有程式基礎的人，適合嗎？A：有程式基礎的話起步會比較輕鬆，但如果稍不注意，在不熟悉的領域，可能一不小心就落後了。饅頭計畫的最終產出的專屬個人作品，依照個人實力的不同，呈現的結果也會不一樣。因此非常歡迎想要挑戰自己的人來參加。 Q：一邊工作一邊轉職的人適合申請嘛？A：適合，因為饅頭計畫的設計「可以讓學生自行安排進度」。如果沒有辦法如果無法在六個月內完成，也可以依照任務逐步進行。 Q：辭去工作轉職的人適合嘛A：適合，因為饅頭計畫的設計就是讓一個零基礎的人，在六個月後可以變成一個合格、有競爭力的工程師。 這邊要再次提醒，裸辭轉職風險很大。尤其現在景氣不好，你的求職競爭對手可能比你更有經驗，那麼求職時間便會拉長。 Level 1 - 踏出第一步，建立信心，累積成就感學習目標在等級一的關卡，瞭解了網際網路如何運作，了解程式語言基礎，並且用 Python 與 JS 實作了一個簡易的網路應用 (Web Application)。 每週進度 初學 Python / JS 雙刀流 網頁設計流程與切板 (HTML, CSS, RWD) 用 jQuery 理解 JS Web API 初探後端 (Python Flask) 與網路基礎 訓練時間：四週相關技術：HTML、CSS、JavaScript、Flask解鎖課程：HTML &amp; CSS 基礎、Python 基礎、 JavaScript 基礎、jQuery 基礎 Level 2 - 更進一步，小型專案開發學習目標在等級二的關卡，我們將升級上一個關卡中的前端與後端技術，打造一個麻雀雖小、卻很完全的有趣應用。讓 Web 技術覆蓋的面積更加的完整 每週進度 完整學習 Python Flask 基礎 MySQL 關聯式資料庫入門 會員系統開發 Ajax 前後端串接小型專案 訓練時間：四週相關技術：HTML、CSS、JavaScript、Flask解鎖課程：Flask 基礎、SQL 基礎、Bootstrap 基礎 Level 3 - 獨立開發電商網站學習目標在等級三的關卡中，你需要獨立開發電商網站。前端使用現代化的前端技術和 React.js 框架，後端使用 Flask 開發網頁實作前端需要的 API。並且串接金流，並需要將成品佈署到 AWS 上。 每週進度 需求分析 + 可行性評估 爬蟲獲取資料 + 資料庫設計 首頁功能實作 汽車瀏覽頁面功能實作 預約看車功能實作 支付訂金功能實作 會員功能整合 (Google / Fb 登入) 佈署上雲端 (AWS) 訓練時間：八週相關技術：AWS、Python、現代前端開發工具、React、Webpack、Babel、Bootstrap解鎖課程：React 基礎課程、現代前端工具課程、Flask 進階課程、AWS 基礎 Level 4 - 打造個人專屬作品 (專精前端 / 後端)學習目標在等級四的關卡中，第一步要做的是熟悉專精知識，包含理論與實作。最終你將打造個人專屬作品，如果的目標是轉職，成為你的面試作品。如果你是來進修的，你將學會完成一個完成度高的 Side Project。 每週進度 專精技術（一）前端專精 React.js &amp; 後端專精 Django 專精技術（二）&amp; 專屬作品發想 打造專屬作品 (一) 使用者故事撰寫、頁面流程、資料庫規劃 打造專屬作品 (二) 技術難點研究 打造專屬作品 (三) 開發主要功能 打造專屬作品 (四) 開發次要功能 打造專屬作品 (五) 優化與除錯 打造專屬作品 (六) 完成專屬作品 面試準備(一) 履歷撰寫、面試練習、解題練習 面試準備(二) 模擬面試練習 訓練時間：十週相關技術：React、Django、AWS、Docker解鎖課程：React 實戰、Django 實戰、Docker 基礎、AWS 進階 課程進行方式線上影音教材饅頭計畫提供專屬的課程教材平台提供給學員觀看，讓學員可以快速掌握一門技術。在學習期間可無限次數重複觀看。部分影片跟Youtube 頻道相同，雖然部分影片相同，但是學習的成效大不同。透過「解任務」的方式使用影片中的技術實際解決問題，確實掌握技術的精髓。這也是為何免費公開部分教材的原因。 任務導向學習課程提供大量的影音教材讓學員得以獲得充足的知識。然而單向的學習不足以培養出足以勝任職場的能力，因此使用「任務導向」的方式來學習。 完成每週任務的過程中，你可以使用任何你想得到的方式。例如：你可以問程度比較好的同學，或是你可以問以前的朋友，工作上現在正在寫程式的，或是你可以到任何的開放社群發問，只要對你有幫助的都可以嘗試。 這樣做的目的是幫助你建立一套學習系統，而不是單純學會課堂上的內容，一旦遇到未知的問題就會手足無措。 專案導向學習數週的學習成果，相互呼應，形成較具規模的專案。 Level 1 &amp; Level 2使用 Python + JS 開發一個的一體式架構網站。讓學員感受到開發的樂趣，培養成就感。 Level 3 開始比較硬一點，但也可以學到更多。「獨立開發」一個 MPA + SPA 混合型電商網站。開發的專案題目是相同的，在這個階段中，大家可以體會到在需求的壓力下，如何分配學習的時間，並進而找出方法解決問題。 Level 4 選擇專精前端或者專精後端，打造個人專屬作品。專精前端使用的技術為 React，專精後端使用的技術為 Django。專精前端、專精後端可以兩個人組隊，建構出更完整的作品。如果你是屬於硬派的學習者，也可以前端、後端都自己寫。 多場線上直播Level 1、Level 2 大約兩個禮拜一次線上直播。Level 3、Level 4 每週一次線上會議，同步進度、展示成果，問題討論。 說明「每週任務」與說明每週需要學習的目標 回顧上一週的任務大家的執行狀況，看看有沒有什麼地方需要修正的。 透過學員的反饋，即時補強一些缺乏的重要概念，打通任督二脈。 ps：如果遇到國定假日可能會取消該次直播交流。比較沒有事情的時候直播就以關注學員學習成果為主。 課程規則模擬上班打卡上班開始學習的時候進行「打卡上班」，結束學習時「打卡下班」。學習時間可以自行決定，希望可以規律一點，比較容易持之以恆，例如：每週固定兩個晚上、週末固定一天進行學習。 找得到人每日打卡設計的出發點是讓學員有儀式感，開始學習的時候就專心學習，透過每日打卡，可以知道目前上線學習的同學有哪些。使得在線上的同學們可以互相交流，增加學習動力。 蹺班機制打卡的同時請登入 Discord 頻道，方便同學互相交流。如果私訊超過 1 小時以上未回覆，記錄當日蹺班。 了解自主學習時間打卡可以準確的估算當週的學習時間，方便自我檢視實際學習時間是否跟最初設定的是否有落差。 學習日誌學習時順手記錄筆記，使用「學習日誌」記錄下來，讓日後可以花更少的時間回憶，將破碎的記憶片段組織成具體的知識點。學習日誌格式： (必填) 今天要做什麼？ (必填) 遇到了什麼困難？ps: 沒有的話就寫沒有即可 (必填) 明天要做什麼？ (必填) 今日速記：學習到什麼馬上隨手記錄下來，讓大腦可以專注於重要的事情 (選填) 本日心得：推薦使用 ORID 焦點描述法撰寫心得 每週回顧以週為單位來檢視自己的學習成果，主要檢視的幾點有： 這週學到了哪些東西？ 有沒有遇到什麼困難？ 這週的學習效率好嗎？好的話寫下原因，繼續保持。不好的話寫下原因，下週修正。 下週要做的事情有哪 本週學習心得 透過以上資訊學習教練可以更準確的掌握學員狀況，給予幫助。 每週任務每週指派一定數量的任務，需在截止期限前繳交。每週任務「沒有」手把手的教學，需要用你任何想得到的方式，來解決這個任務。更詳細的說明，請見「任務導向學習」。 課程資訊背水一戰 vs 持久戰根據過往的經驗參加的學員大致上可分為兩種： 背水一戰：目前無正職工作，全力學習，每週可花 50 個小時以上學習。 持久戰：有工作的狀況下想要學習，根據之前統計的結果，如果有工作的狀態下，一個禮拜大約有 15 小時左右的學習時間。 背水一戰背水一戰可以更專心的準備轉職，但相對來說有更大的經濟壓力，如果沒有先存一筆錢，不工作 6 個月很容易斷糧。 如果你能夠有 6 個月的完全空白學習時間，並且能夠保持紀律性，持之以恆的學習。饅頭計畫的課程設計將幫助你轉職成工程師。 持久戰整體來說「持久戰」是我更推薦的方案，因為參加「背水一戰」班的人往往想要壓力更大，但後來發現自己根本沒那麼多時間，或是沒準備那麼多的生活費，最後斷糧只能失敗作收。一邊工作一邊轉職的話只要能撐下去，完成個人專屬的作品，累積面試經驗，最後會有不錯的結果。 求職時間比較採用「背水一戰」模式的話，找到工作時間約略是 6-8 個月之間。以每週可學習時數來換算的話，使用「持久戰」模式的人大約需要花三倍左右的時間，也就是 18 個月 ~ 24 個月左右。實務上，也有「持久戰」的零基礎同學在一年內就找到工作的成功案例。 心得現在的大環境下建議大家多保留一些緩衝空間，如果不是經濟上有餘裕，建議先保留原本的工作，選擇「持久戰」方案即可。如果真的要拼半年轉職，請先準備好 6 個月的學習時間與 2 個月求職緩衝時間的生活費，以免真的辭職了，卻因經濟因素沒辦法專心學習，得不償失。 零元挑戰如果你是「背水一戰」辭去工作轉職，並且能夠做到以下幾點。在結訓六個月之後的兩個月內沒有找到工作，全額退費。如果使用這個方案有找到工作的話，收費會是 1.5 個月的月薪。 每週固定學習 50 小時以上(以打卡時間為準) 每週任務準時繳交 準時完成各個關卡的魔王專案 撰寫學習日誌(有學習的日子都要記錄) 撰寫每週回顧 這次的規則定的比較嚴格，因為上一屆規則定的太鬆，沒有一定的自制力真的無法成功轉職。如果辭去工作背水一戰，努力訓練六個月努力還是無法找到工作，那就是課程設計有問題，全額退費。 每個月不分項目有 3 次容錯空間，超過即判定零元挑戰失敗。例如：缺交作業 1 次、當週學習時數未滿 50 小時 1 次、未撰寫學習日誌 2 次，合計違規 4 次，判定失格。 學習方案 闖關模式 台幣戰士 方案說明 完成一個關卡後，才能接關下一個關卡。 一次購入需要的訓練關卡。 適合對象 對自己是否對寫程式有興趣抱持疑問，使用這個方案最為保險。 1. 已確定要投入大量時間在轉職上2. 可用時間較零碎3. 沒有充足時間 設計原理 通過各個關卡逐步瞭解自己是否適合寫程式。 透過完整的方案學習就業所需的所有技能 卡關機制 有。當前關卡中的任務和魔王專案未完成，無法開啟下一關的內容。 無。當前關卡未破之前可以直接進行下一關卡，有空時再回去破之前關卡。 整體費用 價格較高 經濟實惠Level 1 ~ 3 省 5000Level 1 ~ 4 省 9000 繳費方式 每個關卡分開繳納，逐步體驗。 買斷課程，可選擇一次付清或是分期。分期下來一個月約 6000 元，相當優惠。 價格方案簡單說明一下價格方案，如果還未確定對程式是否有興趣，選擇闖關模式風險更小。如果下定決心，那麼合購的價格更加划算。 類型 級別 價格 上課時間 鑑賞期 闖關模式 Level 1 3000 4 週 5 天 闖關模式 Level 2 5500 4 週 5 天 闖關模式 Level 3 16500 8 週 5 天 闖關模式 Level 4 20000 10 週 5 天 如果選擇台幣戰士，有以下幾種可以選擇 類型 關卡列表 原價 特價 上課時間 平均每個月 鑑賞期 合購優惠 Level 1 + 2 + 3 25000 20000 4 個月 5000元/月 14 天 合購優惠 Level 1 + 2 + 3 + 4 45000 36000 6 個月 6000元/月 14 天 如果選擇「零元挑戰」，在時限內求職成功，則需繳交(1.5個月薪水 - 已繳交學費)的差額。如果在遵守規則的情況下，在時限內無法找到工作，已繳交學費全額退還。如果未遵守規則，則判定零元挑戰失敗，還是可以依照購買的方案繼續上課。 退費說明：在鑑賞期內，如果你不滿意，將無條件退還課程費用的 90%。這項退費政策是基於軟體訂閱和其他不可逆轉的成本考量，因此原課程費用的 10% 將作為辦理退費的手續費。 報名資訊招生人數根據報名人數而定，原則上 Level 3, Level 4 希望是小班制教學，如果人數已滿將停止招生。 報名流程填寫報名表單 + 寄一封信，做完這兩個步驟之後才算完成報名呦。 填寫 報名表單，在這邊選擇你想要選擇的方案。 寄一封信到 codeshiba@gmail.com，標題：饅頭計畫#3 報名_你的姓名，內容如下方範本。 報名後兩個禮拜內寄送報名結果通知，錄取後，根據選擇方案繳交第一期費用完成報名。 信件範本嗨，你好！我是 XXX 我來報名饅頭計畫 3 了 說說你是怎麼樣的人，過著怎麼樣的生活，為什麼要學程式 以前有學過程式嘛？你做了哪些努力來學程式？ 開始做作品了嘛？ 小練習也不要不好意思，讓我可以了解你程度。 想透過參加饅頭計畫獲得哪些幫助？ 你的短期目標是？例如：半年內你想達成什麼事情 你的長期目標是什麼呢? 例如：兩年目標想達成些什麼事情 任何想說的話或是想問的問題 饅頭計畫演化史零 - 起源「饅頭計畫 第零彈」是一個帶領新手快速突破技術瓶頸的計畫。作者 Luka 分享了計畫的初衷、自己的背景，以及學生 Moo Jing 在計畫中的學習成果。透過一對一的密集指導，Moo Jing 從前端工程師轉型學習後端技術，並在一個月內取得顯著進步，包括網站規劃、學習方法和技術實作等多方面的成長。 壹 - 設計理念經過一段時間的，發布了「饅頭計畫第一彈」。分為三個階段：衝刺的嬰兒、翻轉教學和 YouTube 教學。 衝刺的嬰兒：這階段適合能夠承受壓力、有大量時間投入學習的人。課程節奏快速，涵蓋基礎網頁開發知識。 翻轉教學：這階段適合有長期學習目標的學生。學生可以根據自己的步調學習，透過觀看預先錄製的教學影片和參與互動式問答來學習。 YouTube 教學：最後階段，將課程內容公開於 YouTube，讓更多人能夠自行學習。 雖然這是一個免費的教學計畫，但學生應該認真對待，並且自己的努力是關鍵。課程的目標是打下扎實的基礎，培養成為一名工程師所需的思維和技能。 最後的成果：饅頭計畫第一彈 最後成果：15 人跟課到最後，10 人轉職成功！ 貳 - 極限就業的雙面刃饅頭計畫第二彈是以極速就業為導向的一個就業服務，執行之後，有部分同學的確很快的就找到了工作，但是也有些同學為了追求快，而忽略了些重要的基礎。 整體來說，課程設計的還行，節錄一段： 培養你成為一個工程師應該有的思維和技能。打下扎實的基礎，讓你可以在學習程式的路上有一個很好的開始。在你之後挑戰更高的職缺時，你會感受到基礎的重要性的。 詳細內容可以看這一篇。後來執行的結果，覺得不算好，因為這一屆盡量降低學習曲線，這樣的情況下盡量不給學員太大壓力。因為我想說要培養興趣。後來證實，這樣做的效果似乎不太好。還是要有一定的壓力才能使人有突破的成長。 成果記錄在這篇文章：饅頭計畫第二彈成果報告. 14 人參加，順利找到工作的 6人，成功率 42% 。 歷屆過程記錄 饅頭計畫第零期 -不管你是前端、後端，兇狠的變強吧 ！ 饅頭計畫第一彈 — 從零開始茁壯吧！ 一步一腳印，扎實成長. 饅頭計畫前端幼幼班教材釋出｜HTML、CSS、JS、jQuery、Git 、CMD Line 教學一次滿足 饅頭計畫第一彈成果分享 最後成果：15 人跟課到最後，10 人轉職成功！ 饅頭計畫第二彈 | 挑戰最難的教學，以成果為導向的就業服務 饅頭計畫第二彈成果報告. 14 人參加，順利找到工作的 6人，成功率 42% 。 歷屆學員心得 順序 學員名稱 1 饅頭計畫 #2 學員心得 (1) Phoebe 2 饅頭計畫 #2 學員心得 (2) 慶慶 3 饅頭計畫 #2 學員心得 (3) Eva 4 饅頭計畫 #2 學員心得 (4) 鈺涵 5 饅頭計畫 #2 學員心得 (5) Michael 6 饅頭計畫 #2 學員心得 (6) Shawn 7 饅頭計畫 #2 學員心得 (7) Lily 8 饅頭計畫 #1 學員心得 (1) Joanne 9 饅頭計畫 #1 學員心得 (2) GK 10 饅頭計畫 #1 學員心得 (3) Genie 11 饅頭計畫 #1 學員心得 (4) TsungYu 12 饅頭計畫 #1 學員心得 (5) Leah 13 饅頭計畫 #1 學員心得 (6) Shirley 14 饅頭計畫 #1 學員心得 (7) Theo 15 饅頭計畫 #1 學員心得 (8) Windy 16 饅頭計畫 #1 學員心得 (9) Phoenix 17 饅頭計畫 #1 學員心得 (10) 昱穎 18 饅頭計畫 #1 學員心得 (11) Trista 19 饅頭計畫 #1 學員心得 (12) Celine 20 饅頭計畫 #1 學員心得 (13) Sherry 21 饅頭計畫 #1 學員心得 (14) Orow 22 饅頭計畫 #1 學員心得 (15) Old Mo 23 饅頭計畫 #0 學員心得 Moojing 聯絡方式有任何問題，歡迎使用電子郵件聯繫，請寄信至 codeshiba.gmail.com也可以傳訊息至程式柴 FB 粉絲專頁。","link":"/bootcamp/index.html"},{"title":"如何從 jQuery 轉換到原生 JS 語法","text":"從 jQuery 轉換到原生 JS 的重要性可以從幾個方面來解釋： 性能優化：原生 JS 比起依賴於 jQuery 的程式碼，通常會有更好的性能。這是因為原生 JS 直接與瀏覽器的 API 互動，沒有額外的抽象層，這減少了執行時間和記憶體使用。 現代瀏覽器的改進：過去，jQuery 是很受歡迎的，主要是因為它能夠解決跨瀏覽器的兼容性問題。但隨著時間的推移，現代瀏覽器已經大幅改進，許多原生 JS API 現在在主流瀏覽器中都有很好的支援，這使得直接使用原生 JS 變得更加可行。 學習和理解底層：了解原生 JS 對於任何前端開發者來說都是一項重要的技能。它不僅僅是學習語法，更是理解 JavaScript 如何工作的基礎。這對於深入了解程式語言和瀏覽器的運作方式非常重要。 依賴性減少：使用原生 JS 可以減少對第三方庫的依賴。這意味著程式碼更加獨立，避免了因為依賴的庫不再維護或更新而造成的風險。 現代框架和工具鏈：現代的前端開發趨勢是使用如 React、Vue 或 Angular 這樣的框架，這些框架大多基於原生 JS 和新的網頁標準。因此，掌握原生 JS 對於使用這些現代工具非常有幫助。 學習和使用原生 JavaScript 是為了提高性能，與現代瀏覽器和框架保持一致，減少外部依賴，並深入理解 JavaScript 的工作原理。這些都是對前端開發者而言非常重要的。 選擇器 Selector1. ID 選擇器效果說明使用 jQuery 和原生 JavaScript 選擇具有特定 ID（”myElement”）的元素，並將其文字內容更改為 “哇！這個盒子變成了火箭！”，然後將文字顏色設定為紅色。 使用 jQuery 實現12$(&quot;#myElement&quot;).html(&quot;哇！這個盒子變成了火箭！&quot;);$(&quot;#myElement&quot;).css(&quot;color&quot;, &quot;red&quot;); 使用原生 JavaScript 實現123var element = document.getElementById(&quot;myElement&quot;);element.innerHTML = &quot;哇！這個盒子變成了火箭！&quot;;element.style.color = &quot;red&quot;; 詳細說明 使用 jQuery，我們使用 $() 函數來選擇 ID 為 “myElement” 的元素，然後使用 .html() 方法來設定內容，使用 .css() 方法來設定文字顏色。 使用原生 JavaScript，我們使用 document.getElementById(&quot;myElement&quot;) 來選擇具有特定 ID 的元素，然後使用 .innerHTML 屬性來設定內容，使用 .style.color 屬性來設定文字顏色。 Class 選擇器效果說明使用 jQuery 和原生 JavaScript 選擇所有帶有 “myClass” 類別的元素，將它們的文字內容更改為 “大家都變成了魔法師！”，然後將它們的背景顏色設定為黃色。 使用 jQuery 實現12$(&quot;.myClass&quot;).html(&quot;大家都變成了魔法師！&quot;);$(&quot;.myClass&quot;).css(&quot;background-color&quot;, &quot;yellow&quot;); 使用原生 JavaScript 實現12345var elements = document.querySelectorAll(&quot;.myClass&quot;);elements.forEach(function(element) { element.innerHTML = &quot;大家都變成了魔法師！&quot;; element.style.backgroundColor = &quot;yellow&quot;;}); 詳細說明 使用 jQuery，我們使用 $() 函數來選擇具有 “myClass” 類別的所有元素，然後使用 .html() 方法來設定內容，使用 .css() 方法來設定背景顏色。 使用原生 JavaScript，我們使用 document.querySelectorAll(&quot;.myClass&quot;) 來選擇所有帶有特定類別的元素，然後使用 .forEach() 方法遍歷它們，對每個元素使用 .innerHTML 屬性來設定內容，使用 .style.backgroundColor 屬性來設定背景顏色。 元素選擇器效果說明使用 jQuery 和原生 JavaScript 選擇所有 &lt;p&gt; 元素，將它們的文字內容更改為 “咦，我變成了魔法書！”，並加入點擊事件監聽器，以在點擊時顯示警示框以顯示秘密資料。 使用 jQuery 實現1234$(&quot;p&quot;).html(&quot;咦，我變成了魔法書！&quot;);$(&quot;p&quot;).click(function() { alert(&quot;快看，這個魔法書有秘密！&quot;);}); 使用原生 JavaScript 實現12345678var paragraphs = document.querySelectorAll(&quot;p&quot;);paragraphs.forEach(function(paragraph) { paragraph.innerHTML = &quot;咦，我變成了魔法書！&quot;; paragraph.addEventListener(&quot;click&quot;, function() { alert(&quot;快看，這個魔法書有秘密！&quot;); });}); 詳細說明 使用 jQuery，我們使用 $() 函數來選擇所有 &lt;p&gt; 元素，然後使用 .html() 方法來設定內容，使用 .click() 方法加入點擊事件監聽器。 使用原生 JavaScript，我們使用 document.querySelectorAll(&quot;p&quot;) 來選擇所有指定元素，然後使用 .forEach() 方法遍歷它們，對每個元素使用 .innerHTML 屬性來設定內容，並使用 .addEventListener() 方法加入點擊事件監聽器。 事件 Event以下是針對每個效果的詳細解釋和範例程式碼 滑鼠事件，點擊 (click) 與連續兩次點擊 (dblclick)效果說明 使用 jQuery 實現點擊一次元素時觸發單擊事件，連續兩次點擊時觸發雙擊事件。 使用原生 JavaScript 實現點擊一次元素時觸發單擊事件，連續兩次點擊時觸發雙擊事件。 使用 jQuery 實現123456789// 單擊事件$(&quot;#myElement&quot;).click(function() { alert(&quot;單擊事件發生！&quot;);});// 雙擊事件$(&quot;#myElement&quot;).dblclick(function() { alert(&quot;雙擊事件發生！&quot;);}); 使用原生 JavaScript 實現12345678910111213141516var element = document.getElementById(&quot;myElement&quot;);var clicks = 0;// 單擊事件element.addEventListener(&quot;click&quot;, function() { clicks++; if (clicks === 2) { alert(&quot;雙擊事件發生！&quot;); clicks = 0; }});// 防止連續單擊事件element.addEventListener(&quot;dblclick&quot;, function(event) { event.preventDefault();}); 詳細說明 使用 jQuery，我們使用 .click() 和 .dblclick() 方法來加入單擊和雙擊事件的監聽器。 使用原生 JavaScript，我們使用 .addEventListener() 來加入單擊事件的監聽器，並使用變數 clicks 來追蹤點擊次數，以實現連續兩次點擊事件。為了防止連續單擊事件，我們還阻止了雙擊事件的預設行為。 滑鼠事件，移入 (mouseenter) 與移出(mouseout)效果說明 使用 jQuery 實現當滑鼠移入元素時觸發移入事件，當滑鼠移出元素時觸發移出事件。 使用原生 JavaScript 實現當滑鼠移入元素時觸發移入事件，當滑鼠移出元素時觸發移出事件。 使用 jQuery 實現123456789// 移入事件$(&quot;#myElement&quot;).mouseenter(function() { alert(&quot;滑鼠移入事件發生！&quot;);});// 移出事件$(&quot;#myElement&quot;).mouseout(function() { alert(&quot;滑鼠移出事件發生！&quot;);}); 使用原生 JavaScript 實現1234567891011var element = document.getElementById(&quot;myElement&quot;);// 移入事件element.addEventListener(&quot;mouseenter&quot;, function() { alert(&quot;滑鼠移入事件發生！&quot;);});// 移出事件element.addEventListener(&quot;mouseout&quot;, function() { alert(&quot;滑鼠移出事件發生！&quot;);}); 詳細說明 使用 jQuery，我們使用 .mouseenter() 和 .mouseout() 方法來加入滑鼠移入和移出事件的監聽器。 使用原生 JavaScript，我們使用 .addEventListener() 來加入 mouseenter 和 mouseout 事件的監聽器。 如何在 vscode 中快速產生 ready code snippet對於在 Visual Studio Code (VSCode) 中快速生成 ready 事件程式碼塊，無論是使用 jQuery 還是原生 JavaScript，都有相應的方法 使用 jQuery 實現在 VSCode 中輸入 “ready” 並按下 Tab 鍵，即可生成 ready 事件程式碼塊。VSCode 會自動識別你想要使用 jQuery 的 ready 函數，然後生成以下程式碼 123$(document).ready(function() { // 在這裡放置你的程式碼}); 使用原生 JavaScript 實現VSCode 也可以自動生成 DOMContentLoaded 事件的程式碼塊，無需特殊程式碼。 只需在 HTML 文件中輸入以下部分 12345&lt;script&gt;document.addEventListener(&quot;DOMContentLoaded&quot;, function() { // 在這裡放置你的程式碼});&lt;/script&gt; 當你輸入上述部分時，VSCode 通常會自動提供提示，讓你輕鬆生成 DOMContentLoaded 事件程式碼塊。 這樣，無論你是使用 jQuery 還是原生 JavaScript，都可以輕鬆生成 ready 事件程式碼塊，以確保在 DOM 完全就緒時執行你的 JavaScript 程式碼。 詳細說明 在 VSCode 中，當你輸入 “ready” 並按下 Tab 鍵，它會自動生成 ready 事件的程式碼塊，不論是使用 jQuery 還是原生 JavaScript。 我們怎麼知道 DOM 是否已經就緒 - 使用 ready效果說明 使用 jQuery 實現使用 ready 函數確保 DOM 已經就緒並可以操作。 使用原生 JavaScript 實現使用 DOMContentLoaded 事件確保 DOM 已經就緒並可以操作。 使用 jQuery 實現123$(document).ready(function() { // 在這裡放置你的程式碼}); 使用原生 JavaScript 實現123document.addEventListener(&quot;DOMContentLoaded&quot;, function() { // 在這裡放置你的程式碼}); 詳細說明 使用 jQuery，我們使用 $(document).ready() 來確保文件已經完全加載並且 DOM 可以被操縱。 滑鼠的 hover 事件效果說明 當滑鼠移入元素時，將改變元素的外觀（例如，改變背景顏色）。 當滑鼠移出元素時，恢復元素的初始外觀。 使用 jQuery 實現123456789101112$(document).ready(function() { $(&quot;#myElement&quot;).hover( function() { // 滑鼠移入事件 $(this).css(&quot;background-color&quot;, &quot;yellow&quot;); }, function() { // 滑鼠移出事件 $(this).css(&quot;background-color&quot;, &quot;&quot;); // 恢復初始背景顏色 } );}); 使用原生 JavaScript 實現12345678910111213document.addEventListener(&quot;DOMContentLoaded&quot;, function() { var element = document.getElementById(&quot;myElement&quot;); element.addEventListener(&quot;mouseenter&quot;, function() { // 滑鼠移入事件 this.style.backgroundColor = &quot;yellow&quot;; }); element.addEventListener(&quot;mouseleave&quot;, function() { // 滑鼠移出事件 this.style.backgroundColor = &quot;&quot;; // 恢復初始背景顏色 });}); 詳細說明 使用 jQuery，我們使用 .hover() 方法，接受兩個函數作為參數，第一個函數處理滑鼠移入事件，第二個函數處理滑鼠移出事件。 使用原生 JavaScript，我們使用 .addEventListener() 來加入 mouseenter 和 mouseleave 事件的監聽器，分別處理滑鼠移入和移出事件。 如果遇到沒看過的滑鼠事件該怎麼辦效果說明 學習如何處理未知的滑鼠事件。 使用 jQuery 實現12345$(document).ready(function() { $(&quot;#myElement&quot;).on(&quot;unknownMouseEvent&quot;, function(event) { alert(&quot;未知的滑鼠事件發生&quot; + event.type); });}); 使用原生 JavaScript 實現1234567document.addEventListener(&quot;DOMContentLoaded&quot;, function() { var element = document.getElementById(&quot;myElement&quot;); element.addEventListener(&quot;unknownMouseEvent&quot;, function(event) { alert(&quot;未知的滑鼠事件發生&quot; + event.type); });}); 詳細說明 無論是 jQuery 還是原生 JavaScript，你都可以加入一個事件監聽器來處理滑鼠事件。當發生未知的滑鼠事件時，你可以使用 event.type 屬性來獲取事件的類型並進行處理。 on(‘click’, ..) 與 click() 是等價的效果說明 介紹 on('click', ...) 和 click(...) 方法之間的等價性。 使用 jQuery 實現123456789$(document).ready(function() { $(&quot;#myElement&quot;).on(&quot;click&quot;, function() { alert(&quot;使用 on 方法處理點擊事件！&quot;); }); $(&quot;#myElement2&quot;).click(function() { alert(&quot;使用 click 方法處理點擊事件！&quot;); });}); 使用原生 JavaScript 實現123456789101112document.addEventListener(&quot;DOMContentLoaded&quot;, function() { var element = document.getElementById(&quot;myElement&quot;); var element2 = document.getElementById(&quot;myElement2&quot;); element.addEventListener(&quot;click&quot;, function() { alert(&quot;使用 addEventListener 方法處理點擊事件！&quot;); }); element2.addEventListener(&quot;click&quot;, function() { alert(&quot;使用 addEventListener 方法處理點擊事件！&quot;); });}); 詳細說明 在 jQuery 中，on('click', ...) 和 click(...) 方法都用於處理點擊事件，它們是等價的。你可以選擇使用其中之一，根據你的喜好和程式碼風格。 在原生 JavaScript 中，我們使用 addEventListener(&quot;click&quot;, ...) 來處理點擊事件。同樣，你可以根據個人偏好選擇不同的方法。 這些範例展示了如何使用 jQuery 和原生 JavaScript 實現不同滑鼠事件以及處理未知事件。同時，它們還強調了 on('click', ...) 和 click(...) 方法之間的等價性。 Traversal選擇器的進階 Traversal - 鄰居、爸爸與小孩效果說明 學習如何使用 Traversal 選擇器獲取元素的鄰居、父元素和子元素。 使用 jQuery 實現12345678// 選擇 ID 為 &quot;myElement&quot; 的元素的下一個兄弟元素var nextSibling = $(&quot;#myElement&quot;).next();// 選擇 ID 為 &quot;myElement&quot; 的元素的父元素var parentElement = $(&quot;#myElement&quot;).parent();// 選擇 ID 為 &quot;myElement&quot; 的元素的所有子元素var childElements = $(&quot;#myElement&quot;).children(); 使用 jQuery，我們可以使用 .next() 選擇下一個兄弟元素，使用 .parent() 選擇父元素，使用 .children() 選擇所有子元素。 使用原生 JavaScript，我們使用 .nextElementSibling 屬性選擇下一個兄弟元素，使用 .parentElement 屬性選擇父元素，使用 .children 屬性選擇所有子元素。 使用原生 JavaScript 實現以下是如何使用原生 JavaScript 將 jQuery 程式碼進行重寫 123456789// 選擇 ID 為 &quot;myElement&quot; 的元素的下一個兄弟元素var myElement = document.getElementById(&quot;myElement&quot;);var nextSibling = myElement.nextElementSibling;// 選擇 ID 為 &quot;myElement&quot; 的元素的父元素var parentElement = myElement.parentElement;// 選擇 ID 為 &quot;myElement&quot; 的元素的所有子元素var childElements = Array.from(myElement.children); 詳細說明 選擇 ID 為 “myElement” 的元素的下一個兄弟元素 我們首先使用 document.getElementById(&quot;myElement&quot;) 來選擇具有 ID 為 “myElement” 的元素，將其存儲在 myElement 變數中。 然後，使用 myElement.nextElementSibling 可以獲取 myElement 元素的下一個兄弟元素，實現了與 $(&quot;#myElement&quot;).next() 類似的效果。 選擇 ID 為 “myElement” 的元素的父元素 我們直接使用 myElement.parentElement 可以獲取 myElement 元素的父元素，實現了與 $(&quot;#myElement&quot;).parent() 類似的效果。 選擇 ID 為 “myElement” 的元素的所有子元素 我們首先使用 document.getElementById(&quot;myElement&quot;) 來選擇具有 ID 為 “myElement” 的元素，將其存儲在 myElement 變數中。 然後，使用 myElement.children 可以獲取 myElement 元素的所有子元素，但它返回的是一個 HTMLCollection，我們使用 Array.from() 將其轉換為數組，這樣就實現了與 $(&quot;#myElement&quot;).children() 類似的效果。 jQuery 中怎麼找爸爸，怎麼找孩子效果說明 學習如何使用 jQuery 找到元素的父元素和子元素。 使用 jQuery 實現12345// 使用 .parent() 找到元素的父元素var parentElement = $(&quot;#myElement&quot;).parent();// 使用 .children() 找到元素的所有子元素var childElements = $(&quot;#myElement&quot;).children(); 使用原生 JavaScript 實現以下是如何使用原生 JavaScript 將 jQuery 程式碼進行重寫 1234567// 使用 .parent() 找到元素的父元素var myElement = document.getElementById(&quot;myElement&quot;);var parentElement = myElement.parentElement;// 使用 .children() 找到元素的所有子元素var childElements = Array.from(myElement.children); 詳細說明 使用 .parent() 找到元素的父元素 我們首先使用 document.getElementById(&quot;myElement&quot;) 來選擇具有 ID 為 “myElement” 的元素，將其存儲在 myElement 變數中。 然後，使用 myElement.parentElement 可以獲取 myElement 元素的父元素，實現了與 $(&quot;#myElement&quot;).parent() 類似的效果。 使用 .children() 找到元素的所有子元素 我們首先使用 document.getElementById(&quot;myElement&quot;) 來選擇具有 ID 為 “myElement” 的元素，將其存儲在 myElement 變數中。 然後，使用 myElement.children 可以獲取 myElement 元素的所有子元素，但它返回的是一個 HTMLCollection，我們使用 Array.from() 將其轉換為數組，這樣就實現了與 $(&quot;#myElement&quot;).children() 類似的效果。 parant(), parents(), parentsUntil() 的差異效果說明我們將探討 jQuery 中的 parent()、parents() 和 parentsUntil() 這三個方法之間的差別以及它們的使用情況。 使用 jQuery 實現 使用 parent() 方法選擇元素的直接父元素。 使用 parents() 方法選擇元素的所有祖先元素。 使用 parentsUntil() 方法選擇元素的祖先元素，直到特定的祖先元素為止。 12345678// 使用 parent() 選擇元素的直接父元素var directParent = $(&quot;#myElement&quot;).parent();// 使用 parents() 選擇元素的所有祖先元素var allAncestors = $(&quot;#myElement&quot;).parents();// 使用 parentsUntil() 選擇元素的祖先元素，直到特定祖先元素為止var ancestorsUntil = $(&quot;#myElement&quot;).parentsUntil(&quot;#container&quot;); 使用原生 JavaScript 實現我們將使用原生 JavaScript 來模擬這三個 jQuery 方法的功能。 123456789101112131415161718192021// 使用原生 JavaScript 實現 parent() 方法選擇元素的直接父元素var directParent = document.getElementById(&quot;myElement&quot;).parentNode;// 使用原生 JavaScript 實現 parents() 方法選擇元素的所有祖先元素var allAncestors = [];var currentNode = document.getElementById(&quot;myElement&quot;).parentNode;while (currentNode) { allAncestors.push(currentNode); currentNode = currentNode.parentNode;}// 使用原生 JavaScript 實現 parentsUntil() 方法選擇元素的祖先元素，直到特定的祖先元素為止var containerElement = document.getElementById(&quot;container&quot;);var ancestorsUntil = [];currentNode = document.getElementById(&quot;myElement&quot;).parentNode;while (currentNode &amp;&amp; currentNode !== containerElement) { ancestorsUntil.push(currentNode); currentNode = currentNode.parentNode;} 詳細說明 parent() 方法選擇元素的直接父元素，它返回一個包含一個元素的 jQuery 對象。 parents() 方法選擇元素的所有祖先元素，它返回一個包含所有祖先元素的 jQuery 對象。 parentsUntil() 方法選擇元素的祖先元素，直到特定的祖先元素為止，它返回一個包含符合條件的祖先元素的 jQuery 對象。 在原生 JavaScript 中，我們使用 parentNode 屬性來獲取元素的父元素，並使用循環來模擬 parents() 和 parentsUntil() 方法的功能。 parentsUntil() 方法需要額外的條件檢查來確保選擇的祖先元素在特定的祖先元素之前停止。 Traversal: first(), last(), find()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來執行三個不同的選擇操作：first()、last() 和 find()。 使用 jQuery 實現使用 jQuery，我們可以輕鬆實現這些選擇操作： 12345678// 使用 first() 選取第一個匹配的元素var firstElement = $(&quot;p&quot;).first();// 使用 last() 選取最後一個匹配的元素var lastElement = $(&quot;p&quot;).last();// 使用 find() 選取子元素中匹配的元素var foundElements = $(&quot;div&quot;).find(&quot;.child&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 12345678910// 使用 first() 選取第一個匹配的元素var firstElement = document.querySelector(&quot;p&quot;);// 使用 last() 選取最後一個匹配的元素var allParagraphs = document.querySelectorAll(&quot;p&quot;);var lastElement = allParagraphs[allParagraphs.length - 1];// 使用 find() 選取子元素中匹配的元素var parentElement = document.querySelector(&quot;div&quot;);var foundElements = parentElement.querySelectorAll(&quot;.child&quot;); 詳細說明 使用 jQuery 的 first() 方法可以輕鬆地選取第一個匹配的元素。它返回一個 jQuery 對象，可以進一步處理。 同樣地，last() 方法用於選取最後一個匹配的元素。 find() 方法可用於在選定的元素內查找所有匹配的子元素。在這個案例中，我們使用它來在 div 元素中查找所有具有 .child 類的子元素。 在原生 JavaScript 中，我們使用 querySelector() 方法來選取第一個匹配的元素，使用 querySelectorAll() 方法來選取所有匹配的元素。通過簡單的索引操作，我們可以獲取最後一個元素。對於 find() 的操作，我們首先選擇父元素，然後使用 querySelectorAll() 來選擇所有子元素，再進行過濾。這些方法可以讓你以原生 JavaScript 方式實現與 jQuery 相同的選擇操作。 Traversal: eq(), filter(), not()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來執行三個不同的選擇操作：eq()、filter() 和 not()。 使用 jQuery 實現使用 jQuery，我們可以輕鬆實現這些選擇操作： 12345678// 使用 eq() 選取特定索引位置的元素var specificElement = $(&quot;p&quot;).eq(2); // 選取第三個 &lt;p&gt; 元素（索引從 0 開始）// 使用 filter() 選取符合特定條件的元素var filteredElements = $(&quot;div&quot;).filter(&quot;.special&quot;); // 選取具有 .special 類的 &lt;div&gt; 元素// 使用 not() 選取不符合特定條件的元素var notElements = $(&quot;p&quot;).not(&quot;.exclude&quot;); // 選取不具有 .exclude 類的 &lt;p&gt; 元素 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456789101112131415// 使用 eq() 選取特定索引位置的元素var allParagraphs = document.querySelectorAll(&quot;p&quot;);var specificElement = allParagraphs[2]; // 選取第三個 &lt;p&gt; 元素（索引從 0 開始）// 使用 filter() 選取符合特定條件的元素var allDivs = document.querySelectorAll(&quot;div&quot;);var filteredElements = Array.from(allDivs).filter(function(element) { return element.classList.contains(&quot;special&quot;);});// 使用 not() 選取不符合特定條件的元素var allParagraphs = document.querySelectorAll(&quot;p&quot;);var notElements = Array.from(allParagraphs).filter(function(element) { return !element.classList.contains(&quot;exclude&quot;);}); 詳細說明 使用 jQuery 的 eq() 方法可以輕鬆地選取特定索引位置的元素。注意，索引從 0 開始，所以 eq(2) 選取的是第三個元素。 filter() 方法用於選取符合特定條件的元素，並返回一個新的 jQuery 對象。在原生 JavaScript 中，我們需要使用 querySelectorAll() 來選取所有元素，然後使用 filter() 方法對元素進行過濾，最後轉換成陣列進行處理。 not() 方法用於選取不符合特定條件的元素，並返回一個新的 jQuery 對象。在原生 JavaScript 中，我們使用 querySelectorAll() 來選取所有元素，然後使用 filter() 方法對元素進行過濾，這次選取不符合特定條件的元素。這些方法可以讓你以原生 JavaScript 方式實現與 jQuery 相同的選擇操作。 特效類特效類 API: hide() 與 show()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來執行元素的隱藏 hide() 和顯示 show() 操作。 使用 jQuery 實現使用 jQuery，我們可以輕鬆實現隱藏和顯示元素的效果： 123456789// 隱藏元素$(&quot;button#hide-button&quot;).click(function(){ $(&quot;p&quot;).hide(); // 將所有 &lt;p&gt; 元素隱藏});// 顯示元素$(&quot;button#show-button&quot;).click(function(){ $(&quot;p&quot;).show(); // 顯示所有 &lt;p&gt; 元素}); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456789101112131415// 隱藏元素document.querySelector(&quot;button#hide-button&quot;).addEventListener(&quot;click&quot;, function(){ var paragraphs = document.querySelectorAll(&quot;p&quot;); for (var i = 0; i &lt; paragraphs.length; i++) { paragraphs[i].style.display = &quot;none&quot;; }});// 顯示元素document.querySelector(&quot;button#show-button&quot;).addEventListener(&quot;click&quot;, function(){ var paragraphs = document.querySelectorAll(&quot;p&quot;); for (var i = 0; i &lt; paragraphs.length; i++) { paragraphs[i].style.display = &quot;block&quot;; }}); 詳細說明 使用 jQuery 的 hide() 方法可以隱藏選定的元素，而 show() 方法則用於顯示它們。這些方法可以輕鬆地在單擊按鈕等事件觸發時實現元素的隱藏和顯示。 在原生 JavaScript 中，我們首先使用 querySelector() 方法來選取按鈕元素，然後使用 addEventListener() 方法來加入點擊事件的監聽器。當按鈕被點擊時，我們使用 querySelectorAll() 來選取所有需要隱藏或顯示的元素，然後使用遍歷的方式設置它們的 style.display 屬性，來達到隱藏或顯示的效果。這樣就實現了與 jQuery 中 hide() 和 show() 方法相同的效果。 Callback 回調函式效果說明我們想要實現在 DOM 操作中使用回調函式 (callback function) 的效果。這將允許我們在元素被操作後執行其他操作，例如在元素淡出 (fade out) 後執行某些程式碼。 使用 jQuery 實現使用 jQuery，我們可以使用回調函式 (callback function) 來實現這一效果： 1234567// 使用回調函式實現淡出效果$(&quot;button#fade-out-button&quot;).click(function(){ $(&quot;p&quot;).fadeOut(&quot;slow&quot;, function(){ // 在淡出完成後執行的程式碼 alert(&quot;段落已經淡出了！&quot;); });}); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456789101112131415161718192021222324252627282930// 使用回調函式實現淡出效果document.querySelector(&quot;button#fade-out-button&quot;).addEventListener(&quot;click&quot;, function(){ var paragraphs = document.querySelectorAll(&quot;p&quot;); var fadeDuration = 1000; // 淡出時間，以毫秒為單位 var interval = 50; // 更新間隔，以毫秒為單位 var fadeOut = function(element, callback) { var opacity = 1; var timer = setInterval(function(){ if (opacity &lt;= 0) { clearInterval(timer); element.style.display = &quot;none&quot;; // 隱藏元素 if (typeof callback === &quot;function&quot;) { callback(); // 執行回調函式 } } else { opacity -= 50 / fadeDuration; // 更新不透明度 element.style.opacity = opacity; } }, interval); }; // 淡出所有段落 for (var i = 0; i &lt; paragraphs.length; i++) { fadeOut(paragraphs[i], function(){ // 在淡出完成後執行的程式碼 alert(&quot;段落已經淡出了！&quot;); }); }}); 詳細說明 在 jQuery 中，我們可以使用 fadeOut() 方法來實現淡出效果，並在函式的第二個參數中傳遞回調函式 (callback function)。回調函式將在淡出效果完成後執行。 在原生 JavaScript 中，我們首先選取按鈕元素，然後使用 addEventListener() 方法加入點擊事件的監聽器。當按鈕被點擊時，我們遍歷所有段落元素，並使用 fadeOut() 函式實現淡出效果。該函式使用 setInterval() 定期更新元素的不透明度，直到不透明度達到 0 為止，然後執行回調函式以觸發在淡出完成後執行的程式碼。這樣就實現了與 jQuery 中 fadeOut() 方法相同的效果，包括回調函式的功能。 方法鏈 (Method Chaining)效果說明我們想要實現在 DOM 操作中使用方法鏈 (Method Chaining) 的效果，這將允許我們連續對多個元素進行操作，而不必多次選擇它們。 使用 jQuery 實現使用 jQuery，方法鏈 (Method Chaining) 是一種方便的方法，可以將多個操作連接在一起： 12345// 使用方法鏈來設置多個屬性$(&quot;p&quot;) .css(&quot;color&quot;, &quot;red&quot;) .addClass(&quot;highlight&quot;) .fadeOut(&quot;slow&quot;); 使用原生 JavaScript 實現在原生 JavaScript 中，方法鏈 (Method Chaining) 需要更多的工作，但也是可行的： 1234567891011121314151617181920212223// 使用原生 JavaScript 實現方法鏈var paragraphs = document.querySelectorAll(&quot;p&quot;);for (var i = 0; i &lt; paragraphs.length; i++) { paragraphs[i].style.color = &quot;red&quot;; paragraphs[i].classList.add(&quot;highlight&quot;); fadeOut(paragraphs[i]);}// 淡出函式function fadeOut(element) { var opacity = 1; var interval = 50; // 更新間隔，以毫秒為單位 var fadeDuration = 1000; // 淡出時間，以毫秒為單位 var timer = setInterval(function(){ if (opacity &lt;= 0) { clearInterval(timer); } else { opacity -= 50 / fadeDuration; // 更新不透明度 element.style.opacity = opacity; } }, interval);} 詳細說明 在 jQuery 中，方法鏈 (Method Chaining) 非常容易實現。只需將多個方法連接起來，每個方法返回的是 jQuery 對象，允許對同一組元素進行連續操作。 在原生 JavaScript 中，實現方法鏈需要手動對每個元素進行操作，並根據需要連續調用不同的函式。在上面的例子中，我們遍歷了所有的段落元素，設置它們的顏色、加入類名、以及調用 fadeOut() 函式來執行淡出效果。這樣可以實現與 jQuery 中方法鏈相似的效果，但需要更多的程式碼來達到同樣的目標。 特效類動畫: 使用 animate()效果說明我們想要實現在 DOM 中使用動畫效果，使元素以動畫方式改變位置或屬性。具體而言，我們希望將一個元素從左側移動到右側。 使用 jQuery 實現使用 jQuery，我們可以使用 animate() 方法來實現這種簡單的動畫效果： 123456// 使用 animate() 實現元素移動$(&quot;button#animate-button&quot;).click(function(){ $(&quot;div#animated-box&quot;).animate({ left: &quot;200px&quot; // 將 left 屬性從 0px 改變為 200px }, 1000); // 動畫持續 1 秒}); 使用原生 JavaScript 實現在原生 JavaScript 中，實現動畫效果需要更多的程式碼和計時器： 12345678910111213141516171819202122// 使用原生 JavaScript 實現元素移動document.querySelector(&quot;button#animate-button&quot;).addEventListener(&quot;click&quot;, function(){ var animatedBox = document.querySelector(&quot;div#animated-box&quot;); var startPosition = 0; var endPosition = 200; var duration = 1000; // 動畫持續 1 秒 var interval = 10; // 更新間隔，以毫秒為單位 var distance = endPosition - startPosition; var steps = duration / interval; var stepSize = distance / steps; var currentStep = 0; var timer = setInterval(function(){ if (currentStep&gt;= steps) { clearInterval(timer); } else { startPosition += stepSize; animatedBox.style.left = startPosition + &quot;px&quot;; currentStep++; } }, interval);}); 詳細說明 在 jQuery 中，我們使用 animate() 方法來實現動畫效果。該方法接受一個對象，其中包含要改變的屬性和相應的目標值。在這個例子中，我們改變 left 屬性，使元素從 0px 移動到 200px，動畫持續 1 秒。 在原生 JavaScript 中，實現動畫效果需要使用計時器。我們計算出每一步的變化量，然後使用 setInterval() 定期更新元素的位置，直到達到目標位置為止。這樣就實現了類似於 jQuery 中 animate() 方法的動畫效果，但需要更多的程式碼和計算。 淡入和淡出效果: 使用 fadeIn() 和 fadeOut()效果說明我們想實現在 DOM 中使用淡入 (fadeIn()) 和淡出 (fadeOut()) 效果，以使元素以漸變的方式顯示和隱藏。 使用 jQuery 實現使用 jQuery，我們可以使用 fadeIn() 和 fadeOut() 方法來實現淡入和淡出效果： 123456789// 使用 fadeIn() 實現淡入效果$(&quot;button#fade-in-button&quot;).click(function(){ $(&quot;div#fading-box&quot;).fadeIn(&quot;slow&quot;); // 慢速淡入});// 使用 fadeOut() 實現淡出效果$(&quot;button#fade-out-button&quot;).click(function(){ $(&quot;div#fading-box&quot;).fadeOut(&quot;slow&quot;); // 慢速淡出}); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456789101112131415161718192021222324252627282930313233343536// 使用原生 JavaScript 實現淡入效果document.querySelector(&quot;button#fade-in-button&quot;).addEventListener(&quot;click&quot;, function(){ var fadingBox = document.querySelector(&quot;div#fading-box&quot;); var opacity = 0; var interval = 50; // 更新間隔，以毫秒為單位 var fadeDuration = 1000; // 淡入時間，以毫秒為單位 var timer = setInterval(function(){ if (opacity&gt;= 1) { clearInterval(timer); } else { opacity += 50 / fadeDuration; // 更新不透明度 fadingBox.style.opacity = opacity; } }, interval); fadingBox.style.display = &quot;block&quot;; // 顯示元素});// 使用原生 JavaScript 實現淡出效果document.querySelector(&quot;button#fade-out-button&quot;).addEventListener(&quot;click&quot;, function(){ var fadingBox = document.querySelector(&quot;div#fading-box&quot;); var opacity = 1; var interval = 50; // 更新間隔，以毫秒為單位 var fadeDuration = 1000; // 淡出時間，以毫秒為單位 var timer = setInterval(function(){ if (opacity &lt;= 0) { clearInterval(timer); fadingBox.style.display = &quot;none&quot;; // 隱藏元素 } else { opacity -= 50 / fadeDuration; // 更新不透明度 fadingBox.style.opacity = opacity; } }, interval);}); 詳細說明 在 jQuery 中，我們使用 fadeIn() 方法實現淡入效果，而使用 fadeOut() 方法實現淡出效果。可以指定動畫的速度，例如 “slow” 代表慢速。這些方法會自動處理不透明度和顯示 / 隱藏的細節，使元素以漸變的方式顯示和隱藏。 在原生 JavaScript 中，我們使用計時器和不透明度屬性來實現淡入和淡出效果。計時器定期更新元素的不透明度，從而實現漸變效果。在淡出完成後，我們使用 style.display 來控制元素的顯示狀態。這樣可以實現與 jQuery 中 fadeIn() 和 fadeOut() 方法相似的效果，但需要更多的程式碼和計算。 「取得」與「覆寫」值屬性操作: 使用 attr()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來取得或改變元素的屬性。 使用 jQuery 實現使用 jQuery，我們可以使用 attr() 方法來取得或改變元素的屬性： 12345// 取得元素的屬性值var linkHref = $(&quot;a#my-link&quot;).attr(&quot;href&quot;);// 改變元素的屬性值$(&quot;img#my-image&quot;).attr(&quot;src&quot;, &quot;new-image.jpg&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 1234567// 取得元素的屬性值var linkElement = document.querySelector(&quot;a#my-link&quot;);var linkHref = linkElement.getAttribute(&quot;href&quot;);// 改變元素的屬性值var imageElement = document.querySelector(&quot;img#my-image&quot;);imageElement.setAttribute(&quot;src&quot;, &quot;new-image.jpg&quot;); 詳細說明 在 jQuery 中，我們使用 attr() 方法來取得元素的屬性值或改變元素的屬性。第一個參數是要操作的屬性名稱，第二個參數是要設置的新值（如果是改變屬性的話）。 在原生 JavaScript 中，我們使用 getAttribute() 方法來取得元素的屬性值，並使用 setAttribute() 方法來改變元素的屬性。注意，原生 JavaScript 中需要明確指定要取得或改變的屬性名稱，而在 jQuery 中，屬性名稱作為參數傳遞給 attr() 方法。這樣可以實現相同的效果，但語法略有不同。 操作 DOM 內容: 使用 html()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來取得或修改元素的 HTML 內容。 使用 jQuery 實現使用 jQuery，我們可以使用 html() 方法來取得或修改元素的 HTML 內容： 12345// 取得元素的 HTML 內容var content = $(&quot;div#my-div&quot;).html();// 修改元素的 HTML 內容$(&quot;div#my-div&quot;).html(&quot;&lt;p&gt;New Content&lt;/p&gt;&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456// 取得元素的 HTML 內容var divElement = document.querySelector(&quot;div#my-div&quot;);var content = divElement.innerHTML;// 修改元素的 HTML 內容divElement.innerHTML = &quot;&lt;p&gt;New Content&lt;/p&gt;&quot;; 詳細說明 在 jQuery 中，我們使用 html() 方法來取得元素的 HTML 內容或設置新的 HTML 內容。如果不傳遞參數，它將返回元素的 HTML 內容；如果傳遞參數，則將設置元素的 HTML 內容為指定的值。 在原生 JavaScript 中，我們使用 innerHTML 屬性來取得元素的 HTML 內容或設置新的 HTML 內容。如果要取得 HTML 內容，只需獲取該屬性的值；如果要設置 HTML 內容，只需將新的 HTML 字符串賦值給該屬性。這樣可以實現相同的效果，但語法略有不同。 表單操作: 使用 val()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來取得或修改表單 (form) 元素的值。 使用 jQuery 實現使用 jQuery，我們可以使用 val() 方法來取得或修改表單元素的值： 12345// 取得表單輸入框的值var inputValue = $(&quot;input#my-input&quot;).val();// 修改表單輸入框的值$(&quot;input#my-input&quot;).val(&quot;新的值&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456// 取得表單輸入框的值var inputElement = document.querySelector(&quot;input#my-input&quot;);var inputValue = inputElement.value;// 修改表單輸入框的值inputElement.value = &quot;新的值&quot;; 詳細說明 在 jQuery 中，我們使用 val() 方法來取得表單元素的值或設置新的值。如果不傳遞參數，它將返回表單元素的值；如果傳遞參數，則將設置表單元素的值為指定的值。 在原生 JavaScript 中，我們使用 value 屬性來取得表單元素的值或設置新的值。如果要取得值，只需獲取該屬性的值；如果要設置值，只需將新的值賦值給該屬性。這樣可以實現相同的效果，但語法略有不同。 操作元素文字內容: 使用 text()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來取得元素的文字內容。 使用 jQuery 實現使用 jQuery，我們可以使用 text() 方法來取得元素的文字內容： 12// 取得元素的文字內容var textContent = $(&quot;p#my-paragraph&quot;).text(); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123// 取得元素的文字內容var paragraphElement = document.querySelector(&quot;p#my-paragraph&quot;);var textContent = paragraphElement.textContent; 詳細說明 在 jQuery 中，我們使用 text() 方法來取得元素的文字內容。這個方法返回元素包含的文字，不包含 HTML 標記。 在原生 JavaScript 中，我們使用 textContent 屬性來取得元素的文字內容。這個屬性也只包含文字，不包含 HTML 標記。兩種方法都可以實現取得元素的文字內容，具體選擇哪種取決於你的需求和程式碼風格。 DOM 的操作在容器內插入內容: 使用 before() 和 after()效果說明我們想要在 DOM 中使用 jQuery 或原生 JavaScript 來在特定容器內的元素前面或後面插入新的內容。 使用 jQuery 實現使用 jQuery，我們可以使用 before() 和 after() 方法來在元素前面或後面插入內容： 12345// 在元素前面插入內容$(&quot;p#my-paragraph&quot;).before(&quot;&lt;p&gt;New content before&lt;/p&gt;&quot;);// 在元素後面插入內容$(&quot;p#my-paragraph&quot;).after(&quot;&lt;p&gt;New content after&lt;/p&gt;&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 12345678910// 在元素前面插入內容var paragraphElement = document.querySelector(&quot;p#my-paragraph&quot;);var newElementBefore = document.createElement(&quot;p&quot;);newElementBefore.textContent = &quot;New content before&quot;;paragraphElement.parentNode.insertBefore(newElementBefore, paragraphElement);// 在元素後面插入內容var newElementAfter = document.createElement(&quot;p&quot;);newElementAfter.textContent = &quot;New content after&quot;;paragraphElement.parentNode.insertBefore(newElementAfter, paragraphElement.nextSibling); 詳細說明 在 jQuery 中，我們使用 before() 方法來在元素前面插入新的內容，使用 after() 方法來在元素後面插入新的內容。我們只需將要插入的 HTML 程式碼作為參數傳遞給這些方法即可。 在原生 JavaScript 中，我們首先選擇要插入內容的元素，然後使用 createElement() 方法來建立一個新的元素，設置其內容，然後使用 parentNode.insertBefore() 方法來將新元素插入到指定元素前面或後面。要在元素後面插入，我們使用元素的 nextSibling 屬性來確定插入位置。這樣可以實現與 jQuery 中 before() 和 after() 方法相似的效果，但需要更多的程式碼。 修改 DOM 結構: 使用 append() 和 prepend()效果說明我們想要在 DOM 中使用 jQuery 或原生 JavaScript 來向容器元素加入新的子元素，可以選擇將其追加到容器的末尾或插入到容器的開頭。 使用 jQuery 實現使用 jQuery，我們可以使用 append() 方法將新的子元素追加到容器的末尾，使用 prepend() 方法將新的子元素插入到容器的開頭： 12345// 將新的子元素追加到容器末尾$(&quot;div#my-container&quot;).append(&quot;&lt;p&gt;New content at the end&lt;/p&gt;&quot;);// 將新的子元素插入到容器開頭$(&quot;div#my-container&quot;).prepend(&quot;&lt;p&gt;New content at the beginning&lt;/p&gt;&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 12345678910// 將新的子元素追加到容器末尾var containerElement = document.querySelector(&quot;div#my-container&quot;);var newElementEnd = document.createElement(&quot;p&quot;);newElementEnd.textContent = &quot;New content at the end&quot;;containerElement.appendChild(newElementEnd);// 將新的子元素插入到容器開頭var newElementStart = document.createElement(&quot;p&quot;);newElementStart.textContent = &quot;New content at the beginning&quot;;containerElement.insertBefore(newElementStart, containerElement.firstChild); 詳細說明 在 jQuery 中，我們使用 append() 方法將新的子元素追加到容器的末尾，使用 prepend() 方法將新的子元素插入到容器的開頭。我們只需將要插入的 HTML 程式碼作為參數傳遞給這些方法。 在原生 JavaScript 中，我們首先選擇容器元素，然後使用 createElement() 方法來建立新的子元素，設置其內容，然後使用 appendChild() 方法將新元素追加到容器末尾。要將新元素插入到開頭，我們使用 insertBefore() 方法，將新元素插入到容器的第一個子元素之前。這樣可以實現與 jQuery 中 append() 和 prepend() 方法相似的效果，但需要更多的程式碼。 清空內容和移除元素: 使用 empty() 和 remove()效果說明我們想要在 DOM 中使用 jQuery 或原生 JavaScript 來清空元素的內容或將元素從 DOM 中移除。 使用 jQuery 實現使用 jQuery，我們可以使用 empty() 方法來清空元素的內容，使用 remove() 方法將元素從 DOM 中移除： 12345// 清空元素的內容$(&quot;div#my-element&quot;).empty();// 將元素從 DOM 中移除$(&quot;div#my-element&quot;).remove(); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 1234567// 清空元素的內容var elementToEmpty = document.querySelector(&quot;div#my-element&quot;);elementToEmpty.innerHTML = &quot;&quot;;// 將元素從 DOM 中移除var elementToRemove = document.querySelector(&quot;div#my-element&quot;);elementToRemove.parentNode.removeChild(elementToRemove); 注意事項 使用 empty() 方法僅清空元素的內容，但保留元素本身。使用 remove() 方法將元素從 DOM 中永久移除。 在使用 remove() 方法時，被移除的元素將無法再次使用，並且無法通過 JavaScript 對其進行操作。請謹慎使用 remove()，特別是對於需要保留的元素。 刪除元素屬性: 使用 removeAttr()效果說明我們想要在 DOM 中使用 jQuery 或原生 JavaScript 來刪除元素的特定屬性。 使用 jQuery 實現使用 jQuery，我們可以使用 removeAttr() 方法來刪除元素的屬性： 12// 刪除元素的特定屬性$(&quot;img#my-image&quot;).removeAttr(&quot;alt&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123// 刪除元素的特定屬性var imageElement = document.querySelector(&quot;img#my-image&quot;);imageElement.removeAttribute(&quot;alt&quot;); 詳細說明 在 jQuery 中，我們使用 removeAttr() 方法來刪除元素的特定屬性。只需將要刪除的屬性名稱作為參數傳遞給該方法即可。 在原生 JavaScript 中，我們使用 removeAttribute() 方法來刪除元素的特定屬性。同樣，只需將要刪除的屬性名稱作為參數傳遞給該方法即可。這兩種方法都可以實現刪除元素屬性的效果，具體選擇哪種取決於你的需求和程式碼風格。 在容器中插入內容: 使用 append() 和 prepend()效果說明我們想要在 DOM 中使用 jQuery 或原生 JavaScript 來向容器元素加入新的子元素，可以選擇將其追加到容器的末尾或插入到容器的開頭。 使用 jQuery 實現使用 jQuery，我們可以使用 append() 方法將新的子元素追加到容器的末尾，使用 prepend() 方法將新的子元素插入到容器的開頭： 12345// 將新的子元素追加到容器末尾$(&quot;div#my-container&quot;).append(&quot;&lt;p&gt;New content at the end&lt;/p&gt;&quot;);// 將新的子元素插入到容器開頭$(&quot;div#my-container&quot;).prepend(&quot;&lt;p&gt;New content at the beginning&lt;/p&gt;&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 12345678910// 將新的子元素追加到容器末尾var containerElement = document.querySelector(&quot;div#my-container&quot;);var newElementEnd = document.createElement(&quot;p&quot;);newElementEnd.textContent = &quot;New content at the end&quot;;containerElement.appendChild(newElementEnd);// 將新的子元素插入到容器開頭var newElementStart = document.createElement(&quot;p&quot;);newElementStart.textContent = &quot;New content at the beginning&quot;;containerElement.insertBefore(newElementStart, containerElement.firstChild); 詳細說明 在 jQuery 中，我們使用 append() 方法將新的子元素追加到容器的末尾，使用 prepend() 方法將新的子元素插入到容器的開頭。我們只需將要插入的 HTML 程式碼作為參數傳遞給這些方法。 在原生 JavaScript 中，我們首先選擇容器元素，然後使用 createElement() 方法來建立新的子元素，設置其內容，然後使用 appendChild() 方法將新元素追加到容器末尾。要將新元素插入到開頭，我們使用 insertBefore() 方法，將新元素插入到容器的第一個子元素之前。這樣可以實現與 jQuery 中 append() 和 prepend() 方法相似的效果，但需要更多的程式碼。 包覆元素: 使用 wrap()效果說明我們想要在 DOM 中使用 jQuery 或原生 JavaScript 來包覆一個元素，將其放入新的容器中。 使用 jQuery 實現使用 jQuery，我們可以使用 wrap() 方法將元素包覆在新的容器內： 12// 包覆元素$(&quot;p#my-paragraph&quot;).wrap(&quot;&lt;div class='wrapper'&gt;&lt;/div&gt;&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456// 包覆元素var paragraphElement = document.querySelector(&quot;p#my-paragraph&quot;);var wrapperElement = document.createElement(&quot;div&quot;);wrapperElement.className = &quot;wrapper&quot;;paragraphElement.parentNode.insertBefore(wrapperElement, paragraphElement);wrapperElement.appendChild(paragraphElement); 詳細說明 在 jQuery 中，我們使用 wrap() 方法來將元素包覆在指定的 HTML 元素內。我們只需將要包覆的 HTML 程式碼作為參數傳遞給該方法。 在原生 JavaScript 中，我們首先選擇要包覆的元素和新容器元素，然後使用 createElement() 方法來建立新的容器元素，設置其類名等屬性，然後使用 insertBefore() 方法將新容器插入到原始元素的前面，最後使用 appendChild() 方法將原始元素移動到新容器內。這樣可以實現與 jQuery 中 wrap() 方法相似的效果，但需要更多的程式碼。包覆元素通常不是經常使用的操作，所以較少用到。 用 CSS 的類別來控制視覺: 使用 addClass() 和 removeClass()效果說明我們想要了解如何使用 jQuery 的 addClass() 和 removeClass() 方法來加入或移除元素的 CSS 類別，從而控制其視覺樣式。 使用 jQuery 實現使用 jQuery，我們可以使用 addClass() 方法來加入一個或多個 CSS 類別到元素，使用 removeClass() 方法來從元素中移除一個或多個 CSS 類別： 12345// 加入 CSS 類別到元素$(&quot;p#my-paragraph&quot;).addClass(&quot;highlight&quot;);// 移除 CSS 類別從元素$(&quot;p#my-paragraph&quot;).removeClass(&quot;highlight&quot;); 使用原生 JavaScript 實現要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456// 加入 CSS 類別到元素var paragraphElement = document.querySelector(&quot;p#my-paragraph&quot;);paragraphElement.classList.add(&quot;highlight&quot;);// 移除 CSS 類別從元素paragraphElement.classList.remove(&quot;highlight&quot;); 詳細說明 使用 jQuery 的 addClass() 方法可以將一個或多個 CSS 類別加入到元素，從而改變其視覺樣式。使用 removeClass() 方法可以從元素中移除一個或多個 CSS 類別，還原其樣式。 在原生 JavaScript 中，我們使用 classList 屬性來加入或移除 CSS 類別。使用 classList.add() 方法可以加入一個或多個 CSS 類別，使用 classList.remove() 方法可以從元素中移除一個或多個 CSS 類別。這兩種方法可以實現與 jQuery 中 addClass() 和 removeClass() 方法相似的效果，但需要更多的程式碼。控制 CSS 類別是調整元素視覺樣式的重要方法之一。","link":"/m3/jquery2js.html"},{"title":"","text":"","link":"/m3/network101.html"},{"title":"【 Python x JS 】雙刀流","text":"基本型別文字的世界： 字串 (String)在這裡，我們探討了 Python 和 JavaScript 中的字串（String）型別。字串是程式語言中的基本概念，用於存儲和操作文本資料。雖然 Python 和 JavaScript 在語法上有所不同，但它們對字串的處理方式有許多相似之處。 Python 中的字串 (str) 在 Python 中，字串是由單引號 ('') 或雙引號 (&quot; &quot;) 包圍的一系列字符。 字串是不可變的，這意味著一旦建立，字串的內容就不能被修改。 字串型別在 Python 中用 str 表示。 Python 程式碼範例 123my_str = &quot;Hello, World!&quot;print(my_str) # 輸出: Hello, World!print(type(my_str)) # 輸出: &lt;class 'str'&gt; JavaScript 中的字串 (string) 與 Python 類似，JavaScript 中的字串也是由單引號、雙引號，或反引號（用於模板字串）包圍的字符序列。 JavaScript 的字串同樣是不可變的。 字串型別在 JavaScript 中用 string 表示。 JavaScript 程式碼範例 123let myString = &quot;Hello, World!&quot;;console.log(myString); // 輸出: Hello, World!console.log(typeof myString); // 輸出: 'string' 綜合比較 在 Python 和 JavaScript 中，字串用來表示文本資料。 兩種語言中，字串的操作和處理方法類似，提供了許多內建的方法來檢查、處理和操作字串。 字串在這兩種語言中都是不可變的，一旦建立，其內容就不能被修改。 數字的世界：int、float、Number、BigInt在這個例子中，我們探討了 Python 和 JavaScript 中的數字型別，包括整數 (int), 浮點數 (float), 數字 (Number), 大整數 (BigInt)。每種語言對這些型別的處理方式有所不同。 Python 的數字型別整數 (int) 代表整數，沒有小數部分。 例如：my_int = 10。 浮點數 (float) 代表帶有小數的數字。 例如：my_float = 10.5。 Python 程式碼範例： 1234my_int = 10my_float = 10.5print(my_int, my_float) # 輸出: 10 10.5print(type(my_int), type(my_float)) # 輸出: &lt;class 'int'&gt; &lt;class 'float'&gt; JavaScript 的數字型別數字 (Number)當在 JavaScript 中使用 Number 型別時，可以表示整數和浮點數。JavaScript 不區分整數和浮點數，所有數字都被視為 Number 型別。以下是一些示範： 以下是加上程式碼突顯的版本： 整數 123let integerNumber = 42;console.log(integerNumber); // 42console.log(typeof integerNumber); // 'number' 在這個範例中，我們宣告了一個整數變數 integerNumber，並賦予它值 42。我們使用 console.log 來輸出它的值，結果是 42，同時我們使用 typeof 來確認它的型別，結果是 'number'。 浮點數 123let floatingPointNumber = 3.14;console.log(floatingPointNumber); // 3.14console.log(typeof floatingPointNumber); // 'number' 這裡我們宣告了一個浮點數變數 floatingPointNumber，賦予它值 3.14。同樣地，我們使用 console.log 輸出它的值（3.14），並使用 typeof 確認它的型別為 'number'。 整數和浮點數都是 Number 123let combinedNumber = 100.0;console.log(combinedNumber); // 100console.log(typeof combinedNumber); // 'number' 這個範例中，我們宣告了一個數字變數 combinedNumber，它的值是 100.0。儘管它包含小數點，但 JavaScript 仍然將其視為 'number' 型別。我們輸出了它的值（100）以及型別（'number'）。 數字運算 123let result = integerNumber + floatingPointNumber; // 整數和浮點數相加console.log(result); // 45.14console.log(typeof result); // 'number' 最後，我們執行了一個數字運算，將整數和浮點數相加，並將結果存儲在 result 變數中。結果 result 包含了計算的結果（45.14），同樣它的型別仍然是 'number'。 在上述示範中，我們展示了 JavaScript 中的數字 (Number) 型別的用法。無論是整數還是浮點數，它們都被視為 Number 型別。你可以進行數學運算，包括整數和浮點數之間的運算。 JavaScript 會自動處理型別轉換，使得整數和浮點數之間的運算成為可能。 大整數 (BigInt)當使用 Number 型別來表示太大的數字時，會出現數值精度丟失或溢出的情況。以下是一個示範，展示了使用 Number 表示超出範圍的數字時會出現的問題。 1234567let largeNumber = 1234567890123456789012345678901234567890;console.log(largeNumber); // 正確顯示數字console.log(largeNumber + 1); // 結果不正確，精度丟失console.log(largeNumber - 1234567890); // 結果不正確，精度丟失console.log(largeNumber * 2); // 結果不正確，溢出console.log(largeNumber / 3); // 結果不正確，精度丟失 在這個示範中，largeNumber 是一個非常大的整數，超出了 Number 型別的表示範圍，因此在進行數學運算時會出現精度丟失或溢出的問題。 為了解決這些問題，你可以使用 BigInt 型別，如下所示： 1234567let largeBigInt = 1234567890123456789012345678901234567890n;console.log(largeBigInt); // 正確顯示大整數console.log(largeBigInt + 1n); // 正確計算，不會精度丟失console.log(largeBigInt - 1234567890n); // 正確計算，不會精度丟失console.log(largeBigInt * 2n); // 正確計算，不會溢出console.log(largeBigInt / 3n); // 正確計算，不會精度丟失 使用 BigInt 型別可以保持數值的精確度，並且不會出現溢出或精度丟失的問題，特別適用於處理非常大的整數。 綜合比較 在 Python 中，整數和浮點數是分開的型別，分別由 int 和 float 表示。 在 JavaScript 中，Number 既可以是整數也可以是浮點數，而 BigInt 是一種特殊的型別，用於處理極大的整數。 是非對錯：布林值 (Boolean)布林值就像是開關，只有「開」（True）和「關」（False）兩種狀態。這在 Python 和 JavaScript 中都一樣。 Python 123my_bool = Trueprint(my_bool) # Trueprint(type(my_bool)) # &lt;class 'bool'&gt; JavaScript 123let myBoolean = true;console.log(myBoolean); // trueconsole.log(typeof myBoolean); // 'boolean' 以下是詳細的操作方式： Python 的布林值 (bool)在 Python 中，布林值用 bool 這個資料型別來表示。Python 的布林值有兩個可能的值：True 和 False。以下是範例： 定義布林變數123my_bool = Trueprint(my_bool) # Trueprint(type(my_bool)) # &lt;class 'bool'&gt; 使用布林運算12result = 5 &gt; 3 # 5 大於 3，結果是 Trueprint(result) # True 布林運算123and_result = True and False # and 運算，結果是 Falseor_result = True or False # or 運算，結果是 Truenot_result = not True # not 運算，結果是 False JavaScript 的布林值 (Boolean)在 JavaScript 中，布林值用 Boolean 這個資料型別來表示。JavaScript 的布林值同樣有兩個可能的值：true 和 false。以下是範例： 定義布林變數123let myBoolean = true;console.log(myBoolean); // trueconsole.log(typeof myBoolean); // 'boolean' 使用布林運算12let result = 5 &gt; 3; // 5 大於 3，結果是 trueconsole.log(result); // true 布林運算123let andResult = true &amp;&amp; false; // and 運算，結果是 falselet orResult = true || false; // or 運算，結果是 truelet notResult = !true; // not 運算，結果是 false 布林值通常用於控制流程、判斷條件、邏輯運算和其他需要表示真假的情況。無論是在 Python 還是 JavaScript 中，布林值都是程式中非常重要的資料型別之一。 空空如也：None, null, undefinedPython 中的「None」在 Python 中，None 是一個特殊的型別，用於表示「什麼都沒有」或缺少值的情況。它通常用來初始化變數，或者作為函式的返回值，以表明沒有有效的返回值。 以下是用 Python 程式碼說明這兩個範例的用處： 初始化變數12my_none = Noneprint(my_none) # None 在這個範例中，我們將變數 my_none 設置為 None，這表示這個變數目前沒有任何值或資料。這在程式中的一些情況下很有用，例如當你希望在稍後的程式中為變數指派值，但還不知道初始值是什麼時。使用 None 來初始化變數可以讓你明確地表示變數的未定義狀態。 函式的返回值12345def find_element(arr, target): for element in arr: if element == target: return element return None # 如果找不到目標元素，返回 None 在這個範例中，我們定義了一個名為 find_element 的函式，該函式接受一個陣列 arr 和一個目標值 target 作為參數。函式的用處是在陣列中尋找目標值，如果找到目標值，則返回該值；如果在整個陣列中找不到目標值，則返回 None。這種設計允許函式明確地指示特殊情況，即目標值不存在於陣列中。在呼叫這個函式後，你可以檢查返回值是否為 None，以確定是否找到了目標元素。 總之，None 在這兩個情況下都用於表示缺少值或未定義的情況，以提供程式碼中的明確性和處理特殊情況的能力。 JavaScript 中的「null」和「undefined」在 JavaScript 中，有兩個值用來表示「空」的狀態，分別是 null 和 undefined。 null：這裡什麼都沒有它通常是由程式開發者明確賦值的，用來表示變數目前沒有有效的值。 12let myNull = null;console.log(myNull); // null undefined：變數存在，但尚未定義undefined：表示變數或屬性存在，但尚未賦值，或者尚未被定義。它通常是變數被聲明但未賦值時的默認值。 12let myUndefined;console.log(myUndefined); // undefined 在上述範例中，我們分別展示了 null 和 undefined 的使用方式。它們用來表示不同的情況，但都代表著某種形式的「空」。在不同的程式語言中，有不同的方式來表達「空」或缺少值的狀態，這些方式在特定情況下很有用，可以幫助程式開發者處理不同的情況。 運算子Python 和 JavaScript 運算子的通用寫法基本算術運算子 Python: 12345a = 5 + 3 # 加法，結果為 8b = 5 - 3 # 減法，結果為 2c = 5 * 3 # 乘法，結果為 15d = 5 / 2 # 除法，結果為 2.5e = 5 % 2 # 取餘，結果為 1 這些基本算術運算子在 Python 中與數學中的使用方式相同。你可以使用加法（+）、減法（-）、乘法（*）、除法（/）和取餘（%）來進行數值計算。 JavaScript: 12345let a = 5 + 3; // 加法，結果為 8let b = 5 - 3; // 減法，結果為 2let c = 5 * 3; // 乘法，結果為 15let d = 5 / 2; // 除法，結果為 2.5let e = 5 % 2; // 取餘，結果為 1 在 JavaScript 中，這些基本算術運算子的使用方式與 Python 相似。你可以使用加法（+）、減法（-）、乘法（*）、除法（/）和取餘（%）來執行數值運算。 比較運算子 Python: 1234print(5&gt; 3) # Trueprint(5 &lt; 3) # Falseprint(5&gt;= 5) # Trueprint(5 &lt;= 4) # False 在 Python 中，比較運算子（大於、小於、大於等於、小於等於）用於比較數值，並返回布林值（True 或 False）。 JavaScript: 1234console.log(5&gt; 3); // trueconsole.log(5 &lt; 3); // falseconsole.log(5&gt;= 5); // trueconsole.log(5 &lt;= 4); // false 在 JavaScript 中，比較運算子的使用方式與 Python 相似。它們也用於比較數值，並返回布林值。 賦值運算子 Python: 12345x = 10 # 賦值x += 5 # x = x + 5x -= 3 # x = x - 3x *= 2 # x = x * 2x /= 4 # x = x / 4 在 Python 中，賦值運算子（+=、-=、*=、/=）用於更新變數的值。它們可以實現簡潔的變數更新操作。 JavaScript: 12345let x = 10; // 賦值x += 5; // x = x + 5x -= 3; // x = x - 3x *= 2; // x = x * 2x /= 4; // x = x / 4 在 JavaScript 中，賦值運算子的使用方式也與 Python 相似。它們用於更新變數的值。 邏輯運算子 Python: 123a = True and False # Falseb = True or False # Truec = not True # False 在 Python 中，邏輯運算子（and、or、not）用於執行布林邏輯操作。它們可以用於組合和改變布林值。 JavaScript: 123let a = true &amp;&amp; false; // falselet b = true || false; // truelet c = !true; // false 在 JavaScript 中，邏輯運算子的使用方式也與 Python 相似。它們用於執行布林邏輯操作。 位元運算子 Python: 123456a = 5 &amp; 3 # 位元 AND，結果為 1b = 5 | 3 # 位元 OR，結果為 7c = 5 ^ 3 # 位元 XOR，結果為 6d = ~5 # 位元非，結果為 -6e = 5 &lt;&lt; 1 # 左移，結果為 10f = 5 &gt;&gt; 1 # 右移，結果為 2 在 Python 中，位元運算子（位元 AND、位元 OR、位元 XOR、位元非、左移、右移）用於執行位元級別的操作。 JavaScript: 123456let a = 5 &amp; 3; // 位元 AND，結果為 1let b = 5 | 3; // 位元 OR，結果為 7let c = 5 ^ 3; // 位元 XOR，結果為 6let d = ~5; // 位元非，結果為 -6let e = 5 &lt;&lt; 1; // 左移，結果為 10let f = 5 &gt;&gt; 1; // 右移，結果為 2 在 JavaScript 中，位元運算子的使用方式也與 Python 相似。它們用於執行位元級別的操作，例如位元 AND、位元 OR 和位元 XOR。 這些範例展示了 Python 和 JavaScript 在基本運算子的使用上的相似之處，讓你更清楚地了解它們之間的相似性和差異。 運算說明好的，我將逐步解釋每個二進位運算，並以 Markdown 表格的形式輸出。 位元 AND (&amp;): 5 的二進位表示是 0101。 3 的二進位表示是 0011。 位元 AND 運算後，只有兩個相應的位都是 1 時，結果位才是 1。因此 0101 &amp; 0011 結果是 0001，即 1。 位元 OR (|): 5 的二進位表示是 0101。 3 的二進位表示是 0011。 位元 OR 運算後，如果兩個相應的位中有任何一個是 1，則結果位是 1。因此 0101 | 0011 結果是 0111，即 7。 位元 XOR (^): 5 的二進位表示是 0101。 3 的二進位表示是 0011。 位元 XOR 運算後，只有兩個相應的位不同時，結果位才是 1。因此 0101 ^ 0011 結果是 0110，即 6。 位元 NOT (~): 5 的二進位表示是 0101。 位元 NOT 運算後，所有位的 0 和 1 互換，並且在最前面加上一個符號位（對於正數是 0，對於負數是 1）。~0101 變成 1010（二進位補碼表示），即 -6。 左移 (&lt;&lt;): 5 的二進位表示是 0101。 左移一位意味著將所有位向左移動一位，右邊補 0。0101 左移一位變成 1010，即 10。 右移 (&gt;&gt;): 5 的二進位表示是 0101。 右移一位意味著將所有位向右移動一位，左邊補上原本最左邊的位（在這裡是 0）。0101 右移一位變成 0010，即 2。 以下是對應的表格 運算 表達式 二進位運算 結果 位元 AND 5 &amp; 3 0101 &amp; 0011 = 0001 1 位元 OR 5 3 0101 位元 XOR 5 ^ 3 0101 ^ 0011 = 0110 6 位元 NOT ~5 ~0101 = 1010 (二進位補碼) -6 左移 5 &lt;&lt; 1 0101 &lt;&lt; 1 = 1010 10 右移 5 &gt;&gt; 1 0101 &gt;&gt; 1 = 0010 2 Python 和 JavaScript 運算子的不同之處嚴格等於運算子 JavaScript: 12console.log(1 == &quot;1&quot;); // true - 僅比較值console.log(1 === &quot;1&quot;); // false - 比較值和類型 在 JavaScript 中，== 運算子比較兩個值，而 === 運算子不僅比較值還比較數據類型。因此，1 == &quot;1&quot; 返回 true，因為它們的值相等，但數據類型不同，而 1 === &quot;1&quot; 返回 false，因為它們的數據類型不同。 整數除法和冪運算 Python: 12a = 10 // 3 # 整數除法，結果為 3b = 2 3 # 冪運算，結果為 8 在 Python 中，// 運算子執行整數除法，返回整數結果。`` 運算子用於計算冪，即指數運算。 JavaScript: 12let a = Math.floor(10 / 3); // 整數除法的模擬，結果為 3let b = 2 3; // 冪運算，結果為 8 在 JavaScript 中，沒有專門的整數除法運算子，因此我們使用 Math.floor() 函數來模擬整數除法。`` 運算子用於計算冪，與 Python 中的操作相同。 三元運算子 Python: 12condition = Trueresult = &quot;Yes&quot; if condition else &quot;No&quot; 在 Python 中，我們可以使用三元運算子 condition ? value_if_true : value_if_false 來根據條件選擇不同的值。 JavaScript: 12let condition = true;let result = condition ? &quot;Yes&quot; : &quot;No&quot;; 在 JavaScript 中，三元運算子的語法與 Python 相同，用於根據條件選擇不同的值。 邏輯運算子的語法 Python: 123a = True and False # Falseb = True or False # Truec = not True # False 在 Python 中，邏輯運算子（and、or、not）用於執行布林邏輯操作，其語法比較直觀。 JavaScript: 123let a = true &amp;&amp; false; // falselet b = true || false; // truelet c = !true; // false 在 JavaScript 中，邏輯運算子的語法也與 Python 相似，用於執行布林邏輯操作。 特殊運算子 Python (海象運算子): 12if (n := 10) &gt; 5: print(&quot;Greater than 5&quot;) # n 在這裡被賦值為 10 在 Python 中，使用海象運算子（:=）可以同時賦值和比較。這是 Python 3.8+ 中的新特性。 JavaScript (類型運算子, 實例運算子, 空值合併運算子): 12345console.log(typeof &quot;Hello&quot;); // &quot;string&quot;console.log(&quot;Hello&quot; instanceof String); // falselet name = null;let displayName = name ?? &quot;Anonymous&quot;;console.log(displayName); // &quot;Anonymous&quot; 在 JavaScript 中，我們使用 typeof 運算子來獲得變數或值的數據類型。instanceof 運算子用於檢查對象是否是指定類型的實例。?? 運算子用於提供默認值，如果左邊的值為 null 或 undefined，則使用右邊的值。 位元運算的差異 JavaScript (無符號右移運算子): 1let a = -8 &gt;&gt;&gt; 1; // 將 -8 視為無符號整數進行右移，結果為 2147483644 在 JavaScript 中，存在無符號右移運算子 &gt;&gt;&gt;，它將數字視為無符號整數進行右移。這是 Python 中不具備的位元運算功能。 這些範例突顯了 Python 和 JavaScript 在運算子使用上的一些重要差異，這些差異反映了它們各自的語言特性和設計理念。瞭解這些差異對於有效地使用這兩種語言來進行編程是很重要的。 資料結構多彩多姿的集合： 列表 (List) 和 陣列 (Array)在 Python 的世界裡，我們有個叫列表 list 的東西。它就像一個大胃王，什麼都能吞。數字、字串、甚至是小數，都能裝進去。嗯，我們來看看 my_list 是不是真的這麼厲害： 123my_list = [1, &quot;hello&quot;, 3.14]print(my_list) # [1, 'hello', 3.14]print(type(my_list)) # &lt;class 'list'&gt; 在 JavaScript 的宇宙中，陣列 Array 就是這個角色。它也能存放各種各樣的元素。讓我們看看 myArray 是不是也一樣多才多藝。 123let myArray = [1, &quot;hello&quot;, 3.14];console.log(myArray); // [1, 'hello', 3.14]console.log(typeof myArray); // 'object' Python 中的列表 (List)列表是一種有序的集合，它可以容納不同類型的元素，包括整數、字串、小數等。以下是列表的主要特點和使用方式。 建立列表 1my_list = [1, &quot;hello&quot;, 3.14] 在這個範例中，我們建立了一個名為 my_list 的列表，其中包含了整數、字串和浮點數。 存取列表元素 12print(my_list[0]) # 存取第一個元素，結果是 1print(my_list[1]) # 存取第二個元素，結果是 &quot;hello&quot; 你可以使用索引來存取列表中的元素，索引從 0 開始計數。 加入元素 1my_list.append(42) # 在列表末尾加入一個新元素 42 使用 append 方法可以在列表的末尾加入新的元素。 刪除元素 1del my_list[1] # 刪除第二個元素，my_list 變為 [1, 3.14] 你可以使用 del 關鍵字來刪除列表中的元素。 列表長度 1length = len(my_list) # 獲得列表的長度，結果是 2 你可以使用 len 函式獲得列表的長度。 JavaScript 中的陣列 (Array)陣列也是一種有序的集合，它和 Python 的列表在概念上相似，但在使用上有些許不同。以下是陣列的主要特點和使用方式： 建立陣列 1let myArray = [1, &quot;hello&quot;, 3.14]; 在這個範例中，我們建立了一個名為 myArray 的陣列，其中包含了整數、字串和浮點數。 存取陣列元素 12console.log(myArray[0]); // 存取第一個元素，結果是 1console.log(myArray[1]); // 存取第二個元素，結果是 &quot;hello&quot; 你同樣可以使用索引來存取陣列中的元素，索引也是從 0 開始計數。 加入元素 1myArray.push(42); // 在陣列末尾加入一個新元素 42 使用 push 方法可以在陣列的末尾加入新的元素。 刪除元素 1myArray.splice(1, 1); // 刪除第二個元素，myArray 變為 [1, 3.14] 你可以使用 splice 方法來刪除陣列中的元素。 陣列長度 1let length = myArray.length; // 獲得陣列的長度，結果是 2 你可以使用 length 屬性獲得陣列的長度。 列表 (List) 和陣列 (Array) 都是用來存儲一系列元素的資料結構，它們在不同的程式語言中都具有類似的功能，但具體的使用方式和方法可能有所不同。無論你選擇使用哪種語言，都可以靈活地操作這些集合來處理資料。 鍵值對的魔法： 字典 (Dict) 和 物件 (Object)Python 的 字典 就像一本魔法書，裡面用鍵和值的配對記錄了許多秘密。比如說，愛麗絲的年齡和名字： 123my_dict = {&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30}print(my_dict) # {'name': 'Alice', 'age': 30}print(type(my_dict)) # &lt;class 'dict'&gt; 而在 JavaScript 的世界，物件 是這樣的存在。它也保存著類似的秘密，只不過寫法有點不一樣。 123let myObject = {name: &quot;Alice&quot;, age: 30};console.log(myObject); // {name: 'Alice', age: 30}console.log(typeof myObject); // 'object' Python 中的字典 (Dict)字典是一種無序的集合，它使用鍵值對的方式來存儲資料，每個鍵都對應一個值。以下是字典的主要特點和使用方式： 建立字典 123my_dict = {&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30}print(my_dict) # {'name': 'Alice', 'age': 30}print(type(my_dict)) # &lt;class 'dict'&gt; 存取字典元素 1234name_value = my_dict[&quot;name&quot;] # 存取鍵為 &quot;name&quot; 的值age_value = my_dict[&quot;age&quot;] # 存取鍵為 &quot;age&quot; 的值print(&quot;Name:&quot;, name_value) # Name: Aliceprint(&quot;Age:&quot;, age_value) # Age: 30 加入新的鍵值對 12my_dict[&quot;city&quot;] = &quot;New York&quot; # 加入一個新的鍵值對print(my_dict) # {'name': 'Alice', 'age': 30, 'city': 'New York'} 刪除鍵值對 12del my_dict[&quot;age&quot;] # 刪除鍵為 &quot;age&quot; 的鍵值對print(my_dict) # {'name': 'Alice', 'city': 'New York'} 字典的長度 12length = len(my_dict) # 獲得字典的長度，結果是 2print(length) JavaScript 中的物件 (Object)物件也是一種無序的集合，它使用鍵值對的方式來存儲資料，每個鍵都對應一個值。以下是物件的主要特點和使用方式： 建立物件 123let myObject = {name: &quot;Alice&quot;, age: 30};console.log(myObject); // {name: 'Alice', age: 30}console.log(typeof myObject); // 'object' 存取物件元素方法 1：用括號存取 1234let nameValue = myObject[&quot;name&quot;]; // 存取鍵為 &quot;name&quot; 的值let ageValue = myObject[&quot;age&quot;]; // 存取鍵為 &quot;age&quot; 的值console.log(&quot;Name:&quot;, nameValue); // Name: Aliceconsole.log(&quot;Age:&quot;, ageValue); // Age: 30 方法 2：用屬性存取 1234let nameValue = myObject.name; // 存取鍵為 &quot;name&quot; 的值let ageValue = myObject.age; // 存取鍵為 &quot;age&quot; 的值console.log(&quot;Name:&quot;, nameValue); // Name: Aliceconsole.log(&quot;Age:&quot;, ageValue); // Age: 30 加入新的鍵值對方法 1：括號用法 12myObject[&quot;city&quot;] = &quot;New York&quot;; // 使用 [] 加入一個新的鍵值對console.log(myObject); // {name: 'Alice', age: 30, city: 'New York'} 方法 2：物件屬性用法 12myObject.city = &quot;New York&quot;; // 加入一個新的鍵值對console.log(myObject); // {name: 'Alice', age: 30, city: 'New York'} 刪除鍵值對方法 1：括號用法 12delete myObject[&quot;age&quot;]; // 刪除鍵為 &quot;age&quot; 的鍵值對console.log(myObject); // {name: 'Alice', city: 'New York'} 方法 2：物件屬性用法 12delete myObject.age; // 刪除鍵為 &quot;age&quot; 的鍵值對console.log(myObject); // {name: 'Alice', city: 'New York'} 物件的屬性數量 12let numProperties = Object.keys(myObject).length; // 獲得物件的屬性數量，結果是 2console.log(numProperties); 在每個範例中，我們都印出了結果，展示了字典 (Dict) 和物件 (Object) 的使用方法和操作的效果。 堅固小組： 元組 (Tuple)在 Python 裡，tuple 就像是一個不能被改變的小組。一旦建立，就無法改變它的成員。來看看我們的 my_tuple 123my_tuple = (1, &quot;hello&quot;, 3.14)print(my_tuple) # (1, 'hello', 3.14)print(type(my_tuple)) # &lt;class 'tuple'&gt; JavaScript 則沒有這麼嚴格的小組，但我們可以用 Array 加上一些魔法（Object.freeze）來模擬這種不變性。 123let myTuple = Object.freeze([1, &quot;hello&quot;, 3.14]);console.log(myTuple); // [1, 'hello', 3.14]console.log(typeof myTuple); // 'object' Python 元組（Tuple）在 Python 中，元組是一種不可變的資料結構。這意味著一旦建立，就無法更改元組中的元素。這使得元組在某些場景中非常有用，特別是當你需要保證資料不被修改時。例如： 123456789my_tuple = (1, &quot;hello&quot;, 3.14)print(my_tuple) # (1, 'hello', 3.14)print(type(my_tuple)) # &lt;class 'tuple'&gt;# 嘗試修改元組，但會引發錯誤try: my_tuple[0] = 42except TypeError as e: print(f&quot;Error: {e}&quot;) 我們首先建立了一個名為 my_tuple 的元組，它包含了整數、字串和浮點數。 然後，我們嘗試修改這個元組的第一個元素，但會引發 TypeError 錯誤，證明無法更改元組的成員。 在 JS 中模擬元組不變性JavaScript 則沒有這麼嚴格的小組，但我們可以用 Array 加上一些魔法（Object.freeze）來模擬這種不變性。以下是範例，包括一個嘗試修改凍結的結構的例子： 1234567let myTuple = Object.freeze([1, &quot;hello&quot;, 3.14]);console.log(myTuple); // [1, 'hello', 3.14]console.log(typeof myTuple); // 'object'// 嘗試修改凍結的結構，但不會成功myTuple[0] = 42;console.log(myTuple); // [1, 'hello', 3.14] 我們首先使用 Object.freeze 函數來凍結一個包含整數、字串和浮點數的陣列，以模擬元組的不變性。 然後，我們嘗試修改這個凍結的陣列的第一個元素，但不會成功，並輸出了原始的內容，證明無法更改凍結的結構。 在這個 JavaScript 例子中，即使變數名稱是 myTuple，它實際上仍是一個陣列，只是被凍結以防止修改。這是模擬 Python 元組行為的一種方式，但需要注意的是，這個凍結的陣列在 JavaScript 中仍被視為一個對象，而非一個新的或特殊的資料類型。 獨一無二的 集合 (set)Python 的 set 就像一個派對，但不允許重複的客人。每個元素都是獨一無二的。 123456guest_set = {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;}print(guest_set) # {'Alice', 'Bob', 'Charlie'}# 嘗試加入重複的客人guest_set.add(&quot;Bob&quot;) # Bob 已經存在於集合中，不會重複加入print(guest_set) # {'Alice', 'Bob', 'Charlie'} 在 JavaScript 的派對（Set）也是這樣，不歡迎重複的客人。 123456let guestSet = new Set([&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]);console.log(guestSet); // Set(3) {'Alice', 'Bob', 'Charlie'}// 嘗試加入重複的客人guestSet.add(&quot;Bob&quot;); // Bob 已經存在於集合中，不會重複加入console.log(guestSet); // Set(3) {'Alice', 'Bob', 'Charlie'} 大致了解 Set 的用途後，接著我們分別介紹 Python, JS 中 Set 的詳細用法。 Python 的 集合 (Set)在 Python 中， 集合 (Set) 是一個無序的可變容器，它是由一組獨一無二的元素所組成的。這意味著集合中不允許有重複的元素，每個元素都是唯一的。你可以使用大括號 {} 或 set() 建立一個集合，然後將元素加入到集合中。以下是一些範例： 建立一個集合1my_set = {1, 2, 3} 增加元素到集合1my_set.add(4) 刪除元素1my_set.remove(2) 檢查元素是否存在1print(1 in my_set) # True 遍歷集合12for item in my_set: print(item) 輸出集合及其類型12print(my_set) # {1, 3, 4}print(type(my_set)) # &lt;class 'set'&gt; JavaScript 的 Set在 JavaScript 中，Set 也是一個無序的集合，它用於存儲唯一的值。你可以使用 new Set() 構造函式建立一個 Set 對象，然後使用 add() 方法加入值。與 Python 不同的是，JavaScript 的 Set 是一個對象，而不是原始的資料類型。以下是一些範例： 建立一個 Set1let mySet = new Set([1, 2, 3]); 增加值到 Set1mySet.add(4); 刪除值1mySet.delete(2); 檢查值是否存在1console.log(mySet.has(1)); // true 遍歷 Set123mySet.forEach(item =&gt; { console.log(item);}); 輸出 Set 及其類型12console.log(mySet); // Set(3) {1, 3, 4}console.log(typeof mySet); // 'object' 綜合比較雖然 Python 的 集合 (Set) 和 JavaScript 的 Set 在功能上很相似，但要注意它們之間的一些差異： 類型差異：Python 的 集合 (Set) 的類型是 set，而 JavaScript 的 Set 是一個對象。 語法差異：Python 使用大括號 {} 定義集合，而 JavaScript 使用 new Set() 建立 Set 對象。 遍歷方式：Python 使用 for item in my_set 遍歷集合，而 JavaScript 使用 forEach 方法。 儘管有這些差異，兩者的基本功能都是相同的，都可以用來儲存唯一的值，並進行相關操作。 流程控制 (一) 條件判斷用餐廳點菜學 if-elseif-else 就像在一家餐廳點菜一樣。如果你有特定的食物喜好，比如大門口的餐廳有你喜歡的食物，你就走進去，否則你去下一家。 Python 中的 if-else在 Python 中，if 與 else 語句的最後要加上冒號 :，符合條件判斷後的執行程式需要縮排。 12345food_preference = &quot;披薩&quot;if food_preference == &quot;壽司&quot;: print(&quot;我要壽司&quot;)else: print(&quot;我找下一家餐廳&quot;) JavaScript 中的 if-else在 JavaScript 中，語法多了括號和分號，但不會嚴格限制縮排的空格。空格數量錯誤還是可以執行。 123456let restaurant = &quot;義大利料理&quot;;if (restaurant === &quot;日本料理&quot;) { console.log(&quot;我想吃壽司。&quot;);} else { console.log(&quot;讓我們試試下一家餐廳吧。&quot;);} 不同的語法：elif 與 else if重點比較 elif 在 Python 和 JavaScript 中的用法。 Python 中的 elif12345678910# 假設你在餐廳，要決定今天吃什麼食物food_preference = &quot;披薩&quot;# 使用 elif 來進行多個條件的選擇if food_preference == &quot;壽司&quot;: print(&quot;我要壽司&quot;)elif food_preference == &quot;披薩&quot;: print(&quot;我要披薩&quot;)else: print(&quot;我找下一家餐廳&quot;) 在 Python 中，elif 是一個關鍵字，用於在多個條件之間進行選擇。當第一個 if 條件不滿足時，Python 將檢查 elif 條件，如果其中一個為 True，則執行相對應的程式碼區塊。 JavaScript 中的 else if1234567891011// 假設你在餐廳，要決定今天吃什麼食物let restaurant = &quot;義大利料理&quot;;// 使用 else if 來進行多個條件的選擇if (restaurant === &quot;日本料理&quot;) { console.log(&quot;我想吃壽司。&quot;);} else if (restaurant === &quot;義大利料理&quot;) { console.log(&quot;我想嘗試義大利料理。&quot;);} else { console.log(&quot;讓我們試試下一家餐廳吧。&quot;);} 在 JavaScript 中，我們使用 else if 來實現相同的功能。當第一個 if 條件不滿足時，JavaScript 將檢查 else if 條件，如果其中一個為 True，則執行相對應的程式碼區塊。在 JavaScript 中，你也可以連續使用多個 else if 來處理多個條件。 總之，無論是 elif（Python）還是 else if（JavaScript），它們都是用於處理多個條件的語言結構，允許根據不同情況執行不同的程式碼。這使得程式碼更具靈活性，可以應對多種不同的情況。如果有任何其他疑問或需要更多詳細訊息，請隨時提出。 用服飾風格學 switch-case我們要示範的題目是「在試衣間試穿不同風格的服裝時，可根據喜好選擇服裝風格。」，在有多個選項的情況下，使用 switch-case 比起 if-else 具有更高的可讀性。 在 Python 使用 match-case 或是 if-else3.10 以前，使用 if-else 來模擬 switch-case在 Python 3.10 以前的版本沒有 switch-case 語句可以用，只能用 if-else。 12345678910111213outfit_style = &quot;casual&quot;outfit = &quot;&quot;if outfit_style == &quot;formal&quot;: outfit = &quot;西裝筆挺&quot;elif outfit_style == &quot;casual&quot;: outfit = &quot;牛仔褲和 T 恤&quot;elif outfit_style == &quot;athletic&quot;: outfit = &quot;運動裝&quot;else: outfit = &quot;不知道穿什麼&quot;print(outfit) 3.10 之後，使用 match-case在 Python 3.10 及以後的版本中，引入了一個新的 match 語句，它提供了一種更強大且具有結構化的條件匹配方式。以下是對上面範例程式碼的詳細說明： 123456789101112131415# 假設你想要根據天氣選擇適當的衣服weather = &quot;晴朗&quot;# 使用 match 語句來選擇衣服outfit = match weather: case &quot;雨天&quot;: &quot;雨衣和雨靴&quot; case &quot;晴朗&quot;: &quot;短袖和短褲&quot; case &quot;寒冷&quot;: &quot;外套和長褲&quot; case _: &quot;不知道穿什麼&quot;print(outfit) 在這個範例中，我們根據 weather 變數的值選擇適當的衣服。使用 match 語句，每個 case 都代表了一種天氣情況，並根據情況返回適當的衣服建議。不需要使用 break，因為 match 語句會自動處理分支的結束。 這個範例展示了 match 語句如何使程式碼更加結構化和易讀，並且減少了錯誤的發生。 在 JavaScript 中使用 switch 與 case在 JavaScript 中則是早在 ECmathcript 第一版就加入了 switch case 的語法。switch-case 的語句也是比較典型的控制流程關鍵字。例如：Java 和 C 都是使用 switch-case 關鍵字。 12345678910111213141516let outfit_style = &quot;casual&quot;;let outfit;switch (outfit_style) { case &quot;formal&quot;: outfit = &quot;西裝筆挺&quot;; break; case &quot;casual&quot;: outfit = &quot;牛仔褲和 T 恤&quot;; break; case &quot;athletic&quot;: outfit = &quot;運動裝&quot;; break; default: outfit = &quot;不知道穿什麼&quot;;}console.log(outfit); 使用 switch 語句時，如果不加入 break 會發生什麼事情在 JavaScript 中，switch 語句中的 break 語句是可選的，但它對控制流程具有重要影響。如果省略了 break，則 switch 將繼續執行下一個 case 或 default 分支，直到遇到 break 或 switch 結束為止。 在你上一個範例的程式碼中，每個 case 後面都有 break，這是一種良好的實踐，因為它確保只有一個 case 被執行。 如果省略了這些 break，將發生 “穿透”（fall-through）效應，即使多個 case 條件都被匹配，所有符合條件的 case 以及後續的程式碼都將被執行。 例如，如果省略了 break： 12345678910111213141516let outfit_style = &quot;casual&quot;;let outfit;switch (outfit_style) { case &quot;formal&quot;: outfit = &quot;西裝筆挺&quot;; // 沒有 break，將穿透到下一個 case case &quot;casual&quot;: outfit = &quot;牛仔褲和 T 恤&quot;; // 再次沒有 break，將穿透到下一個 case case &quot;athletic&quot;: outfit = &quot;運動裝&quot;; // 再次沒有 break，將穿透到 default default: outfit = &quot;不知道穿什麼&quot;;}console.log(outfit); // 最終輸出為 &quot;不知道穿什麼&quot; 在上面的例子中，由於缺少 break 語句，控制流程穿透到了下一個 case，直到 default。預期的答案 casual 應該對應的是「牛仔褲和 T 恤」，卻因為穿透效應，變成「不知道穿什麼」。 因此，為了確保每個 case 只執行一次，通常應在每個 case 的末尾加上 break。這有助於避免預期外的行為和錯誤。 流程控制 (二) 迴圈For 迴圈：最萬用的迴圈Python 的 For 迴圈 目的 ：for 迴圈在 Python 中用於遍歷可迭代對象，這些對象可以是列表、元組、字串、字典等。它允許你逐個訪問這些對象的元素或元素的索引。 語法結構 ：For 迴圈的基本結構如下： 12for 迴圈變數 in 可迭代對象: # 在這裡執行你的程式碼，這段程式碼會在每次迭代中執行 迴圈變數：這是一個變數名稱，它在每次迭代中被賦值為可迭代對象中的當前元素。你可以自行命名這個變數。 可迭代對象：這是你要遍歷的對象，可以是列表、元組、字串等。 迴圈內的程式碼：這是在每次迭代中執行的程式碼，它必須使用縮排（縮進）表示，並且需要與 for 語句對齊。 範例 ：讓我們使用購物清單的例子來說明： 123shopping_list = [&quot;蘋果&quot;, &quot;香蕉&quot;, &quot;橙子&quot;, &quot;葡萄&quot;]for item in shopping_list: print(&quot;我要買&quot;, item) 在這個例子中，item 是迴圈變數，它依次被賦值為購物清單中的每個項目，然後印出相應的訊息。 遍歷範圍 ：For 迴圈也可以用於遍歷範圍（range），範圍是一個表示數字序列的可迭代對象。這對於執行一定次數的迭代非常有用。 12for i in range(5): print(&quot;迭代次數：&quot;, i) 這個例子會執行 5 次迭代，分別印出 0 到 4 的數字。 Python 中的 for 迴圈用於遍歷各種可迭代對象，它為每次迭代提供一個變數，並在迴圈內部執行相關的程式碼。這使得處理序列資料變得非常方便。 JavaScript 的 For 迴圈 在 JavaScript 中的 for 迴圈就像一場比賽，你知道比賽有多長，並且你會根據比賽的距離一圈又一圈地跑。 1234let raceDistance = 10; // 10 圈比賽for (let lap = 1; lap &lt;= raceDistance; lap++) { console.log(&quot;我跑了第&quot; + lap + &quot;圈&quot;);} 在 JavaScript 中的 for 迴圈是一個非常有用的工具，可以讓你重複執行指定次數的操作，就像一場比賽一樣。讓我們來更詳細地說明： 初始化（Initialization）：在 for 迴圈的開始，你會設定一個初始值，這個值通常代表迴圈控制變數。在你的範例中，控制變數是 lap，初始值是 1，它代表你的比賽一開始的狀態。 條件（Condition）：接下來，你會設定一個條件，只要這個條件為真，迴圈就會繼續運行。在你的程式碼中，條件是 lap &lt;= raceDistance，這意味著只要 lap 的值小於或等於 raceDistance（比賽的總圈數），迴圈就會繼續執行。 遞增 / 遞減語句（Increment / Decrement Statement）：在每一輪迴圈結束時，你會執行遞增（或遞減）語句，這通常用於改變控制變數的值，以便最終滿足條件不再為真。在你的範例中，你使用 lap++ 來將 lap 的值增加 1，表示你跑了一圈。 迴圈體（LoopBody）：在迴圈的大括號 {} 內，你放置了希望重複執行的程式碼。在這裡，你使用 console.log 來顯示你跑了第幾圈。 所以，在你的 JavaScript 程式碼中，當迴圈開始運行時，控制變數 lap 的值從 1 開始，然後它滿足條件 lap &lt;= raceDistance，因此迴圈繼續執行。在每一圈結束時，lap 的值都會增加 1，直到它不再滿足條件，那麼迴圈就結束了。這就像一場比賽，你知道你需要跑多少圈，然後一圈一圈地跑，直到完成比賽。 使用 For 迴圈遍歷陣列使用 JavaScript 中的 for 迴圈來遍歷陣列（array）非常常見。以下是一個簡單的範例，展示如何使用 for 迴圈來遍歷陣列中的元素： 1234567// 假設有一個陣列包含一些數字const numbers = [1, 2, 3, 4, 5];// 使用 for 迴圈遍歷陣列並輸出每個元素for (let i = 0; i &lt; numbers.length; i++) { console.log(numbers[i]);} 在這個範例中，我們首先定義了一個陣列 numbers，其中包含了一些數字。然後，我們使用 for 迴圈來遍歷這個陣列。for 迴圈的初始化部分（let i = 0）設定了一個計數器 i，然後設定了條件（i &lt; numbers.length），只要條件成立，迴圈就會繼續執行。在每次迴圈迭代中，我們使用 console.log 來輸出陣列中的元素，並通過 i 來訪問元素的索引。 這樣，for 迴圈會遍歷陣列中的每個元素，並將其輸出到控制台。 While 迴圈：當條件符合，持續運作Python 中的 while 迴圈 在 Python 中的 while 迴圈就像你等待公車一樣。你不知道公車什麼時候會到來，所以你一直檢查，只要公車到達，你就可以上車。 123456waiting_for_bus = Truewhile waiting_for_bus: print(&quot;等公車...&quot;) if bus_arrived: waiting_for_bus = Falseprint(&quot;上車了！&quot;) Python 中的 while 迴圈根據指定的條件表達式的真假來執行迴圈。 使用 while 關鍵字，並在 while 後指定條件表達式，只要條件為真，就會繼續執行迴圈。 迴圈體使用縮排表示，並在條件為假時退出。 JavaScript 中的 while 迴圈 在 JavaScript 中的 while 迴圈就像一個運動員進行訓練。他們一直在做重複的練習，直到達到一定的目標。 1234567let trainingTime = 0;let trainingGoal = 60; // 訓練 60 分鐘while (trainingTime &lt; trainingGoal) { console.log(&quot;練習中...&quot;); trainingTime += 10; // 每次增加 10 分鐘}console.log(&quot;訓練完成！&quot;); JavaScript 中的 while 迴圈也根據指定的條件表達式的真假來執行迴圈。 使用 while 關鍵字，並在 while 後指定條件表達式，只要條件為真，就會繼續執行迴圈。 迴圈體使用大括號 {} 表示，並在條件為假時退出。 Do While 迴圈：先做再說Python 沒有 do while 在 Python 中沒有嚴格的 do while 迴圈，但我們可以模擬它，比如吃冰淇淋。你首先吃冰淇淋，然後檢查你是否還有口渴，如果是，就繼續吃冰淇淋。 1234567ice_cream = 3while ice_cream &gt; 0: print(&quot;吃冰淇淋...&quot;) ice_cream -= 1 if thirsty: breakprint(&quot;吃完了！&quot;) Python 中沒有嚴格的 do while 迴圈，但可以使用 while True 來實現類似的功能，再加上 break 語句來控制退出條件。 使用 while 關鍵字建立一個無限循環，並在適當的時候使用 break 退出。 JavaScript 中的 do while 在 JavaScript 中的 do while 迴圈就像打電話給朋友，不管朋友是否接聽，你都要至少嘗試一次。 123456let attempts = 0;do { console.log(&quot;打電話給朋友...&quot;); attempts++;} while (attempts &lt; 3);console.log(&quot;不接聽了！&quot;); JavaScript 中的 do while 迴圈是一個至少執行一次的迴圈，然後根據指定的條件表達式決定是否繼續執行。 使用 do 關鍵字來開始迴圈，並在 while 後指定條件表達式。 迴圈體使用大括號 {} 表示，並在條件為假時退出。 這些比喻希望幫助你理解 Python 和 JavaScript 中的迴圈。無論你是在購物、比賽、等公車、訓練、吃冰淇淋還是打電話，迴圈是程式中一個強大且常見的控制結構，可以幫助你重複執行任務。 函式發送問候：函式在 Python 中使用函式在 Python 的世界裡，一個函式 (function) 可以用來發送溫暖的問候。它會告訴你它的型態是個函式。以下是範例： 12345def greet(name): return f&quot;Hello, {name}!&quot;print(greet(&quot;Alice&quot;)) # Hello, Alice!print(type(greet)) # &lt;class 'function'&gt; 我們首先定義了一個名為 greet 的函式，它接受一個名字作為參數。 在函式內部，我們使用 f-string 將問候該名字的字串建立起來。 然後，我們呼叫這個函式，將 “Alice” 作為參數傳遞給它，並輸出了函式的結果，也就是 “Hello, Alice!”。 最後，我們輸出了 greet 函式本身的型態，這證明它確實是一個函式。 在 JavaScript 中使用函式在 JavaScript 的國度中，一個函式 (function) 也能做同樣的事情。它也會自豪地告訴你它是一個函式。以下是範例： 123456function greet(name) { return `Hello, ${name}!`;}console.log(greet(&quot;Alice&quot;)); // Hello, Alice!console.log(typeof greet); // 'function' 我們首先定義了一個名為 greet 的函式，它同樣接受一個名字作為參數。 在函式內部，我們使用模板字串 (template string) 將問候該名字的字串建立起來。 然後，我們呼叫這個函式，將 “Alice” 作為參數傳遞給它，並輸出了函式的結果，也就是 “Hello, Alice!”。 最後，我們輸出了 greet 函式本身的型態，這證明它確實是一個函式。 這兩個範例展示了如何在 Python 和 JavaScript 中使用函式和函式來實現相同的目標，即發送溫暖的問候。儘管語法和語言不同，但概念相似。 變身魔法：Python 列表推導式 vs JS 陣列方法在 Python 中使用列表推導式在 Python 中，列表推導式就像是個魔法師，可以把一個普通的數字列表變成它們的平方。以下是範例： 1234numbers = [1, 2, 3, 4, 5]squared = [x ** 2 for x in numbers]print(squared) # [1, 4, 9, 16, 25]print(type(squared)) # &lt;class 'list'&gt; 我們首先定一個名為 numbers 的列表，其中包含數字 1 到 5。 然後，我們使用列表推導的方法建立了一個名為 squared 的新列表，該列表包含了 numbers 中每個數字的平方。 最後，我們輸出了 squared 列表的內容以及它的型態。 在 JavaScript 中使用 map 方法在 JavaScript 中，map 方法也能做到相同的事，只不過它用的咒語聽起來不太一樣。以下是範例： 1234let numbers = [1, 2, 3, 4, 5];let squared = numbers.map(x =&gt; x ** 2);console.log(squared); // [1, 4, 9, 16, 25]console.log(typeof squared); // 'object' 我們首先定一個名為 numbers 的陣列，其中包含數字 1 到 5。 然後，我們使用 map 方法，對 numbers 陣列中的每個元素應用一個函式，這個函式將每個元素取平方。 最後，我們輸出了 squared 陣列的內容以及它的型態。 這兩個範例展示了如何在 Python 和 JavaScript 中以不同的方式實現相同的目標，即將一個數字列表轉換為它們的平方值。在 Python 中使用列表推導，而在 JavaScript 中使用 map 方法。 例外處理Python現在，讓我們轉向 Python 的例外處理。 你在一家餐廳點了一份特別的料理，但當廚師在烹飪過程中意外燒焦了食物。這就像 Python 中的例外情況。 12345678910try: # 可能引發例外的程式碼，就像料理過程 result = 10 / 0 # 這裡的除以零就像食物燒焦 print(result) # 這一行實際上不會執行，就像你無法享受燒焦的料理except ZeroDivisionError as e: # 例外處理區塊，就像處理燒焦的料理 print('發生錯誤：', str(e)) # 這就像告訴廚師食物燒焦了finally: # 最終執行的區塊，不管是否有錯誤都會執行，就像總是要結帳一樣 print('不管是否有錯誤，這裡都會執行，就像總是要結帳') 在這個情境中，你期望享受美味的料理（try 區塊），但由於烹飪失敗（錯誤），你需要通知廚師（except 區塊）食物燒焦了，然後總是需要結帳（finally 區塊）。 JavaScript (JS)想像你在一家餐廳點了一份蛋糕，但服務生在端上蛋糕的時候，意外地把蛋糕摔到地上。這就像 JavaScript 中的錯誤。 1234567891011try { // 可能引發例外的程式碼，就像端蛋糕 let result = 10 / 0; // 這裡的除以零就像摔蛋糕 console.log(result); // 這一行實際上不會執行，就像你無法享用摔碎的蛋糕} catch (error) { // 例外處理區塊，就像處理摔碎的蛋糕 console.error('發生錯誤：' + error.message); // 這就像告訴服務生蛋糕摔壞了} finally { // 最終執行的區塊，不管是否有錯誤都會執行，就像總是要結帳一樣 console.log('不管是否有錯誤，這裡都會執行，就像總是要結帳');} 在這個情境中，你嘗試享用蛋糕（try 區塊），但由於服務失誤（錯誤），你需要處理這個情況，告訴服務生（catch 區塊）蛋糕摔壞了，然後總是要完成結帳（finally 區塊）。 這兩個情境幫助我們理解 JavaScript 和 Python 中的例外處理，無論是在餐廳中處理料理或點心，還是在程式碼中處理錯誤，都需要適當的處理和最終的清理步驟。 綜合比較在上面的例子中，我們可以比較 Python 和 JavaScript（JS）在例外處理方面的不同之處： 語法不同 : Python: Python 使用 try...except 構造來處理例外情況，並使用 as 來指定錯誤的別名。這種語法相對簡潔。 JavaScript: JavaScript 使用 try...catch 構造來處理錯誤，並在 catch 區塊中使用 error 變數來訪問錯誤物件的訊息。 錯誤類型不同 : Python: 在 Python 中，每個錯誤都有特定的類型。在例子中，我們使用 ZeroDivisionError 來處理除以零的錯誤。 JavaScript: JavaScript 的錯誤通常是通用的，並不總是有明確的錯誤類型。在例子中，我們只使用了通用的錯誤物件，而沒有指定特定的錯誤類型。 訊息處理不同 : Python: 在 Python 中，我們使用 str(e) 來獲取錯誤物件 e 的訊息，並在 except 區塊中處理它。 JavaScript: 在 JavaScript 中，我們使用 error.message 來獲取錯誤物件 error 的訊息，同樣在 catch 區塊中處理它。 最終執行 : Python: Python 和 JavaScript 都支援 finally 區塊，用於確保無論是否有錯誤，某些程式碼都會執行。 JavaScript: 在這兩種語言中，finally 區塊的功能是相似的，都用於執行清理程式碼。 結論Python 和 JavaScript 在例外處理方面有一些語法上的不同，例如 try...except（Python）和 try...catch（JavaScript），以及錯誤類型的表示方式。然而，核心概念相似，都是用於處理程式運行時可能引發的錯誤，並提供一種方式來捕捉、處理和最終處理這些錯誤。 專有名詞對照表 專有名詞 Python JavaScript 資料型別 整數 (int) 整數 (Number) 浮點數 (float) 浮點數 (Number) 布林 (bool) 布林 (Boolean) 字串 (str) 字串 (String) 資料結構 列表 (list) 陣列 (Array) 字典 (dictionary) 物件 (Object) 元組 (tuple) 集合 (set) 集合 (Set) 控制流程 條件語句 (if) 條件語句 (if) 迴圈 (loop) 迴圈 (loop) while 迴圈 while 迴圈 for 迴圈 for 迴圈 switch 語句 switch 語句 迴圈控制 (break, continue) 迴圈控制 (break, continue) 函式相關 參數 (parameter) 參數 (parameter) 返回值 (return value) 返回值 (return value) 自訂函數 (user-defined function) 自訂函數 (user-defined function) 方法 (method) 方法 (method) 例外處理 例外處理 (try, except, finally) 例外處理 (try, catch, finally) 斷言 (assert) 斷言 (assert) 例外拋出 (raise) 例外拋出 (throw) 其他名詞 註釋 (comment) 註釋 (comment) 變數 (variable) 變數 (variable) 常數 (constant) 常數 (constant) 運算符 (operator) 運算符 (operator) 資料類型轉換 (type conversion) 特殊值 NaN, Infinity","link":"/m3/python-x-js.html"},{"title":"JS Web API 教學","text":"什麼是 JS Web APIJavaScript Web API（Application Programming Interface）是一組在網頁瀏覽器中可用的功能和接口，它們擴展了 JavaScript 的能力，使開發人員能夠與瀏覽器和網頁內容進行互動。 JavaScript Web API 包括以下功能和能力： 操作 DOM（Document Object Model）：用於改變網頁上的元素，例如選擇元素、修改內容和樣式，以及加入或刪除元素。 事件處理：允許處理事件，如點擊、輸入、滑鼠移動等，以實現交互性。 發送 HTTP 請求：用於從網絡上獲取數據，包括網頁 API、外部數據 API 等。 圖像、音頻和視頻處理：允許加載、顯示和操作媒體內容。 地理位置訊息：提供訪問使用者設備的地理位置數據，用於定位應用。 本地存儲數據：用於在瀏覽器中保存數據，例如 Cookies、Web Storage 和 IndexedDB 等。 這些 API 的存在使得開發人員能夠建立動態、交互性和功能豐富的網頁應用程式，這些應用程式可以回應使用者的操作，從而提供更好的使用者體驗。總之，JavaScript Web API 是網頁開發的關鍵元素，它們使得建立現代網頁應用變得可能並且更容易實現。 DOM API當我們談論 DOM（Document Object Model, 文件物件模型）API 時，實際上是在談論你如何以生動的方式與網頁上的元素互動。DOM 是你和網頁之間的橋樑，讓你可以透過程式碼來操作和改變網頁的外觀和行為。現在，讓我們深入了解 DOM 的不同方面，並附上簡單的範例以幫助你理解 選擇元素和訪問其屬性這就像在一個巨大的零食袋中挑選你最愛的糖果一樣。你可以使用 JavaScript 來選擇網頁上的元素，然後獲取它們的屬性或內容。例如，你可以通過元素的 ID 來選擇它，並獲取其文字內容。 首先，建立一個 HTML 檔案（例如：index.html）如下： 1234567891011&lt;!DOCTYPE html&gt;&lt;html leng=&quot;zh-TW&quot;&gt;&lt;head&gt; &lt;title&gt; 選擇元素和獲取文字內容 &lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt; 選擇元素和獲取文字內容 &lt;/h1&gt; &lt;p id=&quot;myElementId&quot;&gt; 曾經在一個遙遠的網頁上，有一段文字...&lt;/p&gt; &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 接著，建立一個 JavaScript 檔案（例如：script.js）如下： 12345678// 首先，我們需要選擇指定ID的HTML元素var myElement = document.getElementById('myElementId');// 接著，我們使用一段程式碼來獲取它的文字內容var textContent = myElement.textContent;// 最後，我們將獲取的文字內容輸出到控制台，以揭示文字的內容console.log(&quot;這段文字告訴了我們：&quot;, textContent); 這段程式是一個簡單的 JavaScript 程式碼，它的作用是選擇 HTML 文件中具有特定 ID 的段落元素，然後獲取該段落元素的文字內容，最後在瀏覽器的控制台中顯示這些文字內容。 它演示了如何使用 JavaScript 來操作 HTML 文件中的元素和數據 ** 選擇元素 **：透過 document.getElementById('myElementId')，這段程式使用 DOM 方法 getElementById 來選擇具有特定 ID 的 HTML 元素。這展示了 DOM 如何通過元素的 ID 來選擇特定的元素。 ** 檢索元素的文字內容 **：使用 myElement.textContent，這段程式獲取了選定元素的文字內容。這顯示了如何使用 DOM 的屬性來獲取元素的內容。 ** 操作 HTML 文件 **：最後，這段程式使用 console.log 方法將獲取到的文字內容輸出到瀏覽器的控制台中。儘管這不是直接改變 HTML 文件的演示，但它展示了如何使用 JavaScript 來處理和操作 HTML 文件中的數據。 這個簡單的範例展示了 DOM 的一部分，即如何通過 JavaScript 選擇和操作 HTML 元素，並檢索它們的內容。這是 DOM 在實際網頁開發中常見的應用之一，用於與網頁上的元素進行互動和操作。 修改元素的內容和樣式想像一下你有一個魔法筆，可以改變糖果的顏色和味道。你可以使用 JavaScript 來更改元素的文字內容或樣式，讓網頁變得更吸引人。 12345// 修改元素的文字內容myElement.textContent = '嗨，我是新的文字內容！';// 修改元素的樣式myElement.style.color = 'red'; 建立、加入和刪除元素像是在製作自己的糖果，你可以使用 JavaScript 動態地建立新的元素，然後將它們加入到網頁中，或者刪除不需要的元素。 123456789// 建立一個新的 &lt;div&gt; 元素var newDiv = document.createElement('div');// 加入新元素到網頁document.body.appendChild(newDiv);// 刪除一個元素var elementToRemove = document.getElementById('elementToRemove');elementToRemove.remove(); 事件處理程式和事件監聽器想像一下，你在派對上擔任 DJ，你需要監聽歌曲請求並播放音樂。在網頁上，你可以使用事件處理程式和事件監聽器來響應使用者的操作，例如點擊按鈕或提交表單。 1234// 加入點擊事件監聽器myElement.addEventListener('click', function() { alert('你點擊了我！');}); 瀏覽器事件模型這就像是一場糖果瀑布，事件從頂部開始流下來，直到達到最底層的元素。瀏覽器事件模型描述了事件如何在 DOM 樹中傳播，並允許你捕獲和處理事件。 遍歷 DOM 樹想像一下你在糖果商店中探險，尋找最美味的糖果。你可以使用 JavaScript 來遍歷整個 DOM 樹，找到你想要的元素，然後對它們進行操作。 12345// 遍歷所有段落元素並修改它們的樣式var paragraphs = document.querySelectorAll('p');paragraphs.forEach(function(paragraph) { paragraph.style.fontWeight = 'bold';}); 希望這些生動的比喻和範例幫助你更好地理解 DOM（文件物件模型）API，並開始寫程式碼來控制網頁上的元素！如果你有更多問題，請隨時問我。","link":"/m3/js-web-api.html"},{"title":"Chapter 10: Email Support","text":"Posted by on Miguel Grinberg 這是 Flask Mega-Tutorial 系列的第十部分，在本章中，我將告訴你如何讓你的應用程式向使用者發送電子郵件，以及如何在電子郵件支持的基礎上構建一個密碼恢復功能。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 現在，應用程式在資料庫方面做得相當好，所以在這一章中，我想離開這個主題，加入另一個大多數網路應用程式需要的重要部分，那就是發送電子郵件。 為什麼應用程式需要向使用者發送電子郵件？原因有很多，但一個常見的原因是解決與身份驗證相關的問題。在本章中，我將為那些忘記密碼的使用者加入一個密碼重置功能。當使用者請求重置密碼時，應用程式將發送一封包含特製連結的電子郵件。然後，使用者需要點擊該連結以訪問一個設置新密碼的表單。 本章的 GitHub 連結為：Browse Zip Diff Flask-Mail 簡介就實際發送電子郵件而言，Flask 有一個受歡迎的擴充功能稱為 Flask-Mail。像往常一樣，這個擴充功能可以通過 pip 安裝： 1(venv) $ pip install flask-mail 密碼重置連結將包含一個安全令牌。為了生成這些令牌，我將使用 JSON Web Tokens，它也有一個受歡迎的 Python 套件： 1(venv) $ pip install pyjwt Flask-Mail 擴充功能是通過 app.config 物件進行配置的。還記得在第 7 章中，我加入了電子郵件配置，用於在生產中發生錯誤時給自己發送電子郵件嗎？我當時沒有告訴你，但我的配置變數選擇是根據 Flask-Mail 的要求模型化的，所以實際上並不需要任何額外的工作，應用程式中已經有了配置變數。 像大多數 Flask 擴充功能一樣，你需要在建立 Flask 應用程式後立即建立一個實例。在這種情況下，這是一個 Mail 類的物件： app/init.py: Flask-Mail 實例。 123456## ...from flask_mail import Mailapp = Flask(__name__)## ...mail = Mail(app) 如果你打算測試發送電子郵件，你有我在第 7 章中提到的相同選項。如果你想使用模擬電子郵件伺服器，那麼你可以在第二個終端中啟動相同的 SMTP 調試伺服器，使用以下命令： 1(venv) $ aiosmtpd -n -c aiosmtpd.handlers.Debugging -l localhost:8025 要配置應用程式使用這個伺服器，你需要設置兩個環境變數： 12(venv) $ export MAIL_SERVER=localhost(venv) $ export MAIL_PORT=8025 如果你更喜歡讓電子郵件真正發送，你需要使用一個真正的電子郵件伺服器。如果你有一個，那麼你只需要為它設置 MAIL_SERVER、MAIL_PORT、MAIL_USE_TLS、MAIL_USERNAME 和 MAIL_PASSWORD 環境變數。如果你想要一個快速的解決方案，你可以使用 Gmail 帳戶來發送電子郵件，使用以下設置： 12345(venv) $ export MAIL_SERVER=smtp.googlemail.com(venv) $ export MAIL_PORT=587(venv) $ export MAIL_USE_TLS=1(venv) $ export MAIL_USERNAME=&lt;your-gmail-username&gt;(venv) $ export MAIL_PASSWORD=&lt;your-gmail-password&gt; 如果你正在使用 Microsoft Windows，你需要在上述每個 export 語句中將 export 替換為 set。 不幸的是，你的 Gmail 帳戶中的安全功能可能會阻止應用程式通過它發送電子郵件。一些帳戶允許當你明確允許 “較不安全的應用程式” 訪問你的 Gmail 帳戶時這樣做，但這並不總是可用的。你可以在這裡閱讀有關此事的訊息。 如果你想使用一個真正的電子郵件伺服器，但不想為 Gmail 配置自己添麻煩，SendGrid 是一個不錯的選擇，它允許你使用免費帳戶每天發送 100 封電子郵件。 Flask-Mail 使用方式為了學習 Flask-Mail 的工作方式，我將向你展示如何從 Python shell 會話中發送一封電子郵件。啟動帶有 flask shell 的 Python，然後運行以下命令： 1234567&gt;&gt;&gt; from flask_mail import Message&gt;&gt;&gt; from app import mail&gt;&gt;&gt; msg = Message('test subject', sender=app.config['ADMINS'][0],... recipients=['your-email@example.com'])&gt;&gt;&gt; msg.body = 'text body'&gt;&gt;&gt; msg.html = '&lt;h1&gt;HTML body&lt;/h1&gt;'&gt;&gt;&gt; mail.send(msg) 上面的程式碼片段將向你放在 recipients 參數中的電子郵件地址列表發送電子郵件。我將發件人設為第一個配置的管理員（我在第 7 章中加入了 ADMINS 配置變數）。電子郵件將有純文本和 HTML 版本，因此根據你的電子郵件客戶端的配置，你可能會看到其中一個或另一個。 現在讓我們將電子郵件整合到應用程式中。 簡單的電子郵件框架我將從編寫一個發送電子郵件的輔助函數開始，這基本上是上一節中 shell 練習的泛化版本。我將這個函數放在一個名為 app/email.py 的新模組中： app/email.py: 電子郵件發送包裝函數。 12345678from flask_mail import Messagefrom app import maildef send_email(subject, sender, recipients, text_body, html_body): msg = Message(subject, sender=sender, recipients=recipients) msg.body = text_body msg.html = html_body mail.send(msg) Flask-Mail 支援我這裡沒有使用的一些功能，例如副本和密件副本列表。如果你對這些選項感興趣，務必查看 Flask-Mail 文本。 請求重設密碼如我上面所提到的，我希望使用者有選項要求重設他們的密碼。為此目的，我將在登入頁面加入一個連結： app/templates/login.html：登入表單中的密碼重設連結。 1234&lt;p&gt; 忘記你的密碼了嗎？ &lt;a href=&quot;{{ url_for('reset_password_request') }}&quot;&gt; 點擊這裡重設 &lt;/a&gt;&lt;/p&gt; 當使用者點擊連結時，一個新的網頁表單將出現，要求使用者的電子郵件地址，作為啟動密碼重設流程的方式。這是表單類別： app/forms.py：重設密碼請求表單。 123class ResetPasswordRequestForm(FlaskForm): email = StringField('Email', validators=[DataRequired(), Email()]) submit = SubmitField('請求重設密碼') 這是相應的 HTML 範本： app/templates/reset_password_request.html：重設密碼請求範本。 12345678910111213141516{% extends &quot;base.html&quot; %}{% block content %} &lt;h1&gt; 重設密碼 &lt;/h1&gt; &lt;form action=&quot;&quot;method=&quot;post&quot;&gt; {{form.hidden_tag() }} &lt;p&gt; {{form.email.label}}&lt;br&gt; {{form.email(size=64) }}&lt;br&gt; {% for error in form.email.errors %} &lt;span style=&quot;color: red;&quot;&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt;{{ form.submit() }}&lt;/p&gt; &lt;/form&gt;{% endblock %} 我還需要一個視圖函式來處理這個表單： app/routes.py：重設密碼請求視圖函式。 1234567891011121314151617from app.forms import ResetPasswordRequestFormfrom app.email import send_password_reset_email@app.route('/reset_password_request', methods=['GET', 'POST'])def reset_password_request(): if current_user.is_authenticated: return redirect(url_for('index')) form = ResetPasswordRequestForm() if form.validate_on_submit(): user = db.session.scalar( sa.select(User).where(User.email == form.email.data)) if user: send_password_reset_email(user) flash('請檢查你的電子郵件以獲取重設密碼的指示') return redirect(url_for('login')) return render_template('reset_password_request.html', title='重設密碼', form=form) 這個視圖函式與處理表單的其他函式非常相似。我首先確保使用者未登入。如果使用者已經登入，則使用密碼重設功能沒有意義，所以我重定向到索引頁面。 當表單提交且有效時，我按表單中使用者提供的電子郵件查找使用者。如果我找到了使用者，我就發送一封重設密碼的電子郵件。send_password_reset_email() 輔助函式執行此任務。接下來我會向你展示這個函式。 在電子郵件發送後，我會顯示一個消息，指引使用者查看電子郵件以獲取進一步指示，然後重新導向回登入頁面。你可能會注意到，即使使用者提供的電子郵件未知，也會顯示閃現的消息。這是為了客戶無法使用此表單來確定某 個使用者是否是會員。 密碼重設令牌 Password Reset Tokens在我實現 send_password_reset_email() 函式之前，我需要一種生成密碼請求連結的方式。這將是透過電子郵件發送給使用者的連結。當點擊該連結時，將向使用者展示一個可以設置新密碼的頁面。這個計劃的棘手之處是確保只有有效的重設連結可以用來重設帳戶的密碼。 這些連結將附帶一個令牌，並且在允許更改密碼之前會驗證此令牌，作為請求電子郵件的使用者能夠訪問帳戶上的電子郵件地址的證明。這種類型流程的一個非常流行的令牌標準是 JSON Web Token，或 JWT。JWT 的好處是它們是自包含的。你可以在電子郵件中向使用者發送一個令牌，當使用者點擊將令牌反饋給應用程式的連結時，可以自行驗證它。 JWT 是如何工作的？沒有什麼比快速的 Python shell 會話更能理解它們了： 123456&gt;&gt;&gt; import jwt&gt;&gt;&gt; token = jwt.encode({'a': 'b'}, 'my-secret', algorithm='HS256')&gt;&gt;&gt; token'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhIjoiYiJ9.dvOo58OBDHiuSHD4uW88nfJik_sfUHq1mDi4G0'&gt;&gt;&gt; jwt.decode(token, 'my-secret', algorithms=['HS256']){'a': 'b'} {'a': 'b'}`` 字典是要寫入令牌的一個範例負載。為了使令牌安全，需要提供一個秘密金鑰，用於建立加密簽名。在這個範例中，我使用了字串 ‘my-secret’`，但對於應用程式，我將使用 Flask 配置中的 SECRET_KEY。algorithm 參數指定如何生成令牌簽名。HS256 算法是最廣泛使用的。 正如你所見，結果令牌是一長串字符。但不要以為這是一個加密令牌。令牌的內容，包括負載，可以輕鬆地被任何人解碼（不相信我嗎？複製上面的令牌，然後在 JWT 調試器中輸入以查看其內容）。令牌安全的是負載已經簽名。如果有人試圖偽造或篡改令牌中的負載，那麼簽名將被無效，並且要生成新的簽名需要秘密金鑰。當一個令牌被驗證時，負載的內容被解碼並返回給呼叫者。如果令牌的簽名被驗證，那麼負載可以被信任為真實的。 我打算用於密碼重設令牌的有效負載將會是這樣的格式：{'reset_password': user_id, 'exp': token_expiration}。這裡的 exp 欄位是 JWT 的標準，如果出現它，表示令牌的到期時間。如果一個令牌有有效的簽名，但已經過了它的到期時間戳記，那麼它也會被視為無效。對於密碼重設功能，我將給這些令牌 10 分鐘的壽命。 當使用者點擊電子郵件中的連結時，令牌將作為 URL 的一部分被發送回應用程式，處理這個 URL 的視圖函式首先要做的就是驗證它。如果簽名有效，則可以通過有效負載中儲存的 ID 識別使用者。一旦知道了使用者的身份，應用程式就可以要求設定一個新密碼並將其設定在使用者帳號上。 令牌的生成與驗證由於這些令牌屬於使用者，我將會把令牌生成和驗證函式寫成 User 模型中的方法： 12345678910111213141516171819202122## app/models.py: 重設密碼令牌方法from time import timeimport jwtfrom app import appclass User(UserMixin, db.Model): ## ... def get_reset_password_token(self, expires_in=600): return jwt.encode( {'reset_password': self.id, 'exp': time() + expires_in}, app.config['SECRET_KEY'], algorithm='HS256') @staticmethod def verify_reset_password_token(token): try: id = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])['reset_password'] except: return return db.session.get(User, id) get_reset_password_token() 函式返回一個 JWT 令牌，這個令牌是直接由 jwt.encode() 函式生成的字符串。 verify_reset_password_token() 是一個靜態方法，這意味著它可以直接從類中調用。靜態方法類似於類方法，唯一的區別是靜態方法不接收類作為第一個參數。這個方法接收一個令牌，嘗試通過調用 PyJWT 的 jwt.decode() 函式來解碼它。如果令牌無法驗證或已過期，將引發異常，在這種情況下我會捕捉它以防止錯誤，然後向呼叫者返回 None。如果令牌有效，則令牌有效負載中 reset_password 鍵的值是使用者的 ID，所以我可以加載使用者並返回它。 發送密碼重設電子郵件send_password_reset_email() 函式依賴於我之前寫的 send_email() 函式來生成密碼重設電子郵件。 123456789101112131415161718## app/email.py: 發送密碼重設電子郵件函式from flask import render_templatefrom app import app## ...def send_password_reset_email(user): token = user.get_reset_password_token() send_email('[Microblog] 重設您的密碼', sender=app.config['ADMINS'][0], recipients=[user.email], text_body=render_template('email/reset_password.txt', user=user, token=token), html_body=render_template('email/reset_password.html', user=user, token=token)) 這個函式有趣的部分是，電子郵件的文本和 HTML 內容是使用熟悉的 render_template() 函式從範本生成的。範本接收使用者和令牌作為參數，以便生成個性化的電子郵件訊息。 為了區分電子郵件範本和常規 HTML 範本，我們在 templates 中建立一個 email 子目錄： 1(venv) $ mkdir app/templates/email 以下是重設密碼電子郵件的文本範本： 12345678910111213## app/templates/email/reset_password.txt: 密碼重設電子郵件的文本親愛的 {{user.username}}，點擊以下連結以重設您的密碼：{{url_for('reset_password', token=token, _external=True) }}如果您沒有要求重設密碼，請忽略此訊息。誠摯地，Microblog 團隊 以下是相同電子郵件的更好的 HTML 版本： 12345678910111213141516171819## app/templates/email/reset_password.html: 密碼重設電子郵件的 HTML&lt;!doctype html&gt;&lt;html&gt; &lt;body&gt; &lt;p&gt; 親愛的 {{ user.username }}，&lt;/p&gt; &lt;p&gt; 要重設您的密碼， &lt;a href=&quot;{{ url_for('reset_password', token=token, _external=True) }}&quot;&gt; 點擊這裡 &lt;/a&gt;。 &lt;/p&gt; &lt;p&gt; 或者，您可以將以下連結貼到您瀏覽器的地址欄：&lt;/p&gt; &lt;p&gt;{{ url_for('reset_password', token=token, _external=True) }}&lt;/p&gt; &lt;p&gt; 如果您沒有要求重設密碼，請忽略此訊息。&lt;/p&gt; &lt;p&gt; 誠摯地，&lt;/p&gt; &lt;p&gt;Microblog 團隊 &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 在這兩個電子郵件範本中引用的 reset_password 路由在 url_for() 調用中還不存在，這將在下一節中加入。我在兩個範本中的 url_for() 調用中包含的_external=True 參數也是新的。url_for() 生成的 URL 默認是相對 URL，只包括 URL 的路徑部分。這對於在網頁中生成的連結通常是足夠的，因為網頁瀏覽器會通過從地址欄中的 URL 獲取缺失的部分來完成 URL。然而，通過電子郵件發送 URL 時，這種上下文並不存在，所以需要使用完整的 URL。當作為參數傳遞_external=True 時，會生成完整的 URL，所以前面的例子會返回 http://localhost:5000/user/susan，或者當應用程式部署在域名上時的適當 URL。 重設使用者密碼當使用者點擊電子郵件連結時，將觸發與此功能相關的第二個路由。以下是密碼請求視圖函式： app/routes.py: 密碼重設視圖函式。 12345678910111213141516from app.forms import ResetPasswordForm@app.route('/reset_password/&lt;token&gt;', methods=['GET', 'POST'])def reset_password(token): if current_user.is_authenticated: return redirect(url_for('index')) user = User.verify_reset_password_token(token) if not user: return redirect(url_for('index')) form = ResetPasswordForm() if form.validate_on_submit(): user.set_password(form.password.data) db.session.commit() flash('Your password has been reset.') return redirect(url_for('login')) return render_template('reset_password.html', form=form) 在這個視圖函式中，我首先確保使用者未登入，然後通過調用 User 類中的 token 驗證方法來確定使用者身份。這個方法如果 token 有效則返回使用者，如果無效則返回 None。如果 token 無效，我會重定向到首頁。 如果 token 有效，則我向使用者展示第二個表單，要求輸入新密碼。這個表單的處理方式與之前的表單類似，如果表單提交有效，我會調用 User 的 set_password() 方法來更改密碼，然後重定向到登入頁面，使用者現在可以登入了。 這是 ResetPasswordForm 類： app/forms.py: 密碼重設表單。 12345class ResetPasswordForm(FlaskForm): password = PasswordField('Password', validators=[DataRequired()]) password2 = PasswordField( 'Repeat Password', validators=[DataRequired(), EqualTo('password')]) submit = SubmitField('Request Password Reset') 這是相應的 HTML 模板： app/templates/reset_password.html: 密碼重設表單模板。 1234567891011121314151617181920212223{% extends &quot;base.html&quot; %}{% block content %} &lt;h1&gt;Reset Your Password&lt;/h1&gt; &lt;form action=&quot;&quot;method=&quot;post&quot;&gt; {{form.hidden_tag() }} &lt;p&gt; {{form.password.label}}&lt;br&gt; {{form.password(size=32) }}&lt;br&gt; {% for error in form.password.errors %} &lt;span style=&quot;color: red;&quot;&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt; {{form.password2.label}}&lt;br&gt; {{form.password2(size=32) }}&lt;br&gt; {% for error in form.password2.errors %} &lt;span style=&quot;color: red;&quot;&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt;{{ form.submit() }}&lt;/p&gt; &lt;/form&gt;{% endblock %} 密碼重設功能現已完成，請確保嘗試它。 非同步電子郵件如果你使用的是調試電子郵件伺服器，你可能沒有注意到這一點，但實際發送電子郵件會大大減慢應用程式。發送電子郵件時需要進行的所有交互使任務變慢，通常需要幾秒鐘才能發出一封電子郵件，如果收件人的電子郵件伺服器較慢，或者有多個收件人，可能需要更長時間。 我真正想要的是 send_email() 函式變為非同步。這是什麼意思？這意味著當調用此函式時，發送電子郵件的任務被安排在後台進行，釋放 send_email() 函式立即返回，以便應用程式可以在發送電子郵件的同時繼續運行。 Python 支持運行非同步任務，實際上有不止一種方式。threading 和 multiprocessing 模組都可以做到這一點。為發送的電子郵件啟動一個背景執行緒比啟動一個新進程資源消耗要少得多，所以我選擇了這種方法： app/email.py: 非同步發送電子郵件。 12345678910111213from threading import Thread## ...def send_async_email(app, msg): with app.app_context(): mail.send(msg)def send_email(subject, sender, recipients, text_body, html_body): msg = Message(subject, sender=sender, recipients=recipients) msg.body = text_body msg.html = html_body Thread(target=send_async_email, args=(app, msg)).start() send_async_email 函式現在在一個背景執行緒中運行，通過 send_email() 的最後一行中的 Thread 類調用。隨著這個變化，發送電子郵件將在執行緒中運行，當進程完成時，執行緒將結束並自行清理。如果你配置了一個真正的電子郵件伺服器，當你按下密碼重設請求表單上的提交按鈕時，你肯定會注意到速度的提升。 你可能期望只有 msg 參數被發送到執行緒，但正如你在程式碼中看到的，我還發送了應用程式實例。在使用執行緒時，需要牢記 Flask 的一個重要設計方面。Flask 使用上下文來避免跨函式傳遞參數。我不打算在這裡詳細介紹，但你要知道有兩種類型的上下文，應用程式上下文和請求上下文。在大多數情況下，這些上下文由 Flask 自動管理，但當應用程式啟動自定義執行緒時，可能需要手動建立這些執行緒的上下文。 許多擴展需要設置應用程式上下文才能工作，因為這使它們能夠在不將其作為參數傳遞的情況下找到 Flask 應用程式實例。許多擴展需要知道應用程式實例的原因是因為它們的配置存儲在 app.config 對象中。這正是 Flask-Mail 的情況。mail.send() 方法需要訪問電子郵件伺服器的配置值，這只能通過知道應用程式是什麼來做到。通過 with app.app_context() 調用建立的應用程式上下文使當前應用程式變數從 Flask 中可訪問。","link":"/python/flask-mega-tutorial/chapter_10_email_support.html"},{"title":"Chapter 11: Facelift","text":"Posted by on Miguel Grinberg 這是 Flask Mega-Tutorial 系列的第十一期，在這一期中，我將告訴你如何用基於 Bootstrap 使用者介面框架的新一套模板來替換基本的 HTML 模板。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 你已經玩了一段時間我的 Microblog 應用程式，所以我相信你已經注意到，我並沒有花太多時間讓它看起來很好，或者更確切地說，我根本沒有在這方面花時間。我拼湊起來的模板非常基本，完全沒有自訂風格。對我來說，專注於應用程式的實際邏輯，而不必分心於撰寫好看的 HTML 和 CSS，是有用的。 但我已經專注於這個應用程式的後端部分一段時間了。所以在這一章，我將暫時放下這些，花一些時間向你展示可以做些什麼來讓應用程式看起來更加光鮮亮麗和專業。 這一章會有點不同於之前的章節，因為我不會像平常那樣詳細地講解 Python 這一方面，畢竟，這才是這個教學的主題。建立出色的網頁是一個廣泛的主題，與 Python 網頁開發大部分無關，但我會討論一些基本的指導方針和想法，如何著手這項任務，你也將有重新設計外觀的應用程式來研究和學習。 這一章的 GitHub 連結為：Browse Zip Diff CSS 框架 (CSS Frameworks)雖然我們可以爭論寫程式是困難的，但我們的困難與網頁設計師相比根本算不了什麼，他們必須建立在一系列網頁瀏覽器上看起來既漂亮又一致的網頁。近年來已經有所改善，但在某些瀏覽器中仍然存在一些不明顯的錯誤或怪異，使得設計到處都看起來不錯的網頁非常困難。如果你還需要針對資源和屏幕有限的平板電腦和智能手機瀏覽器，這就更加困難了。 如果你和我一樣，是一個只想建立看起來不錯的網頁的開發者，但沒有時間或興趣學習通過撰寫原始 HTML 和 CSS 有效達成這一目的的低階機制，那麼唯一實際的解決方案就是使用 CSS 框架來簡化任務。走這條路，你將失去一些創造性自由，但另一方面，你的網頁在所有瀏覽器中看起來都會很好，而且不需要花太多力氣。CSS 框架提供了一系列高階 CSS 類別，用於常見類型的使用者介面元素的預製樣式。這些框架大多還提供 JavaScript 附加元件，用於那些無法僅用 HTML 和 CSS 完成的事情。 介紹 Bootstrap最受歡迎的 CSS 框架之一是 Bootstrap。如果你想看到可以用這個框架設計的頁面類型，文件中有一些範例。 使用 Bootstrap 來設計你的網頁時，你可以獲得的一些好處包括： 在所有主流網頁瀏覽器中看起來相似 處理桌面、平板電腦和手機屏幕尺寸 可定制的佈局 漂亮的導航欄、表單、按鈕、警報、彈出窗口等 使用 Bootstrap 最直接的方式是在你的基本模板中直接導入 bootstrap.min.css 檔案。你可以下載這個檔案的副本並將其加入到你的專案中，或者直接從 CDN 導入。然後你可以開始根據文件使用它提供的通用用途 CSS 類別，這個文件寫得很好。你可能還想導入框架的 JavaScript 程式碼，這樣你也可以使用最先進的功能。 像大多數開源專案一樣，Bootstrap 也在不斷進化。Flask Mega-Tutorial 的原始版本是為 Bootstrap 3 構建的。你目前閱讀的修訂版是為 Bootstrap 5.3 構建的。集成 Bootstrap 的當前方法相當通用，可以適應 Bootstrap 的新版本。 使用 Bootstrap將 Bootstrap 與 Microblog 整合的第一步是將其 CSS 和 JavaScript 檔案加入到基本模板中。Bootstrap 的快速入門頁面提供了一個簡短卻完整的 HTML 頁面作為範例，我在下面為你方便起見複製了它： 123456789101112131415161718192021&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;Bootstrap 示範 &lt;/title&gt; &lt;link href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; integrity=&quot;sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; 哈囉，世界！&lt;/h1&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js&quot; integrity=&quot;sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 我可以採取的方法是以上述為我的新基本模板，分別用原始基本模板的 &lt;title&gt; 和 &lt;h1&gt; 標籤來替換。 下一步是用 Bootstrap 更漂亮的導航欄取代基本導航欄。Bootstrap 的 Navbar 文件頁面在頂部附近展示了一個很好的範例。以此為指引，我建立了一個包含 Microblog 的首頁、探索、個人資料、登入和登出連結的導航欄。為了更好的效果，我將個人資料和登入登出連結配置在最右側。 使用 Bootstrap 時，有一些基本的佈局原始碼需要知道。最重要的之一是 container，它定義了頁面的內容區域。主要有兩種 container，分別是 container 和 container-fluid。前者設置頁面使用五種預定義頁面寬度之一，並將內容置於瀏覽器視窗中央。而 fluid container 則讓你可以使用頁面的整個寬度。對於這個應用程式，我決定使用預設的 container，因為它可以防止頁面變得過寬，無論螢幕大小如何。所以，頁面的內容部分將被包裹在這樣的 container 中，如下所示： 123&lt;div class=&quot;container&quot;&gt; ... 頁面內容在這裡 ...&lt;/div&gt; base.html 模板中需要調整的最後一部分 HTML 標記是顯示閃現訊息的部分。Bootstrap 的 Alert 元件很適合這個需求。 你可以從這章節的 Github 倉庫中獲取完全重新設計的 base.html 模板。下面你可以看到一個簡化的結構，如果你想了解它的外觀： app/templates/base.html: 重新設計的基本模板。 1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; {% if title %} &lt;title&gt;{{ title }} - Microblog&lt;/title&gt; {% else %} &lt;title&gt; 歡迎來到 Microblog&lt;/title&gt; {% endif %} &lt;link ... bootstrap CSS ...&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; ... 導航欄（完整程式碼請見 GitHub）... &lt;/nav&gt; &lt;div class=&quot;container mt-3&quot;&gt; {% with messages = get_flashed_messages() %} {% if messages %} {% for message in messages %} &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;{{ message }}&lt;/div&gt; {% endfor %} {% endif %} {% endwith %} {% block content %}{% endblock %} &lt;/div&gt; &lt;script ... bootstrap JavaScript ...&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 有了重新設計的基本模板，應用程式的外觀已經有了顯著的改善，而且不需要更改一行 Python 程式碼。如果你想親自查看，可以從這章節開始顯示的連結中下載 base.html 的副本。 呈現 Bootstrap 表單Bootstrap 在呈現表單欄位方面做得非常出色，這些欄位看起來比瀏覽器提供的預設欄位更好看、更清潔。Bootstrap 的文件中也有一節關於表單的內容。在這一節的開頭有一個登入表單的範例，顯示了基本的 HTML 結構。 每個欄位所需的 HTML 程式碼有點長。下面你可以看到文件中範例 表單中的一個文字欄位： 1234&lt;div class=&quot;mb-3&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot; class=&quot;form-label&quot;&gt; 密碼 &lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;exampleInputPassword1&quot;&gt;&lt;/div&gt; 但對於 Microblog 的需求來說這太簡單了，它包括欄位驗證並可能需要向使用者顯示驗證錯誤。文件頁面中有一節關於伺服器端驗證，展示了如何設計帶有錯誤訊息的欄位。這裡是一個範例： 1234567&lt;div class=&quot;col-md-3&quot;&gt; &lt;label for=&quot;validationServer05&quot; class=&quot;form-label&quot;&gt; 郵遞區號 &lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control is-invalid&quot; id=&quot;validationServer05&quot; aria-describedby=&quot;validationServer05Feedback&quot; required&gt; &lt;div id=&quot;validationServer05Feedback&quot; class=&quot;invalid-feedback&quot;&gt; 請提供有效的郵遞區號。 &lt;/div&gt;&lt;/div&gt; 不幸的是，每個表單欄位都要輸入這麼多模板程式碼是不可行的。這會花費太多時間，且容易出錯。一種解決方案是利用 Jinja 宏，它允許你定義可重複使用的 HTML 片段，然後像函式一樣從你的模板中調用它們。 例如，一個類似上述所示的文字欄位的 Jinja 宏會是： 123456789{% macro form_field(field) %} &lt;div class=&quot;mb-3&quot;&gt; {{field.label(class='form-label') }} {{field(class='form-control' + ('is-invalid' if field.errors else '')) }} {%- for error in field.errors %} &lt;div class=&quot;invalid-feedback&quot;&gt;{{ error }}&lt;/div&gt; {%- endfor %} &lt;/div&gt;{% endmacro %} 注意如何使用條件式選擇性地加入錯誤樣式，如果欄位包含一個或多個錯誤訊息。 在 templates 目錄中有一個名為 bootstrap_wtf.html 的檔案，當需要呈現一個欄位時，可以調用這個宏。例如： 123{% import &quot;bootstrap_wtf.html&quot; as wtf %}...{{wtf.form_field(form.username) }} 欄位呈現宏可以擴展以支援複選框、選擇下拉菜單、提交按鈕和其他欄位類型的呈現。它還可以接受第二個參數，帶有一個布林值，指示是否應該自動將焦點放在頁面上的該欄位，這應該在表單的第一個欄位上完成。為了更方便，還可以建立另一個宏來呈現整個表單，只需遍歷表單欄位並為每一個調用 form_field() 宏。 完整的 bootstrap_wtf.html 檔案可在本章節開頭連結的 GitHub 倉庫中找到。它包括了上述 form_field() 宏的更完整版本，以及一個名為 quick_form() 的第二個宏，它接受一個表單對象並使用第一個宏呈現其所有欄位。 在實際應用程式表單上實現這一點看起來如何？下面你可以看到作為範例的重新設計的 register.html 模板： app/templates/register.html: 使用者註冊範本。 1234567{% extends &quot;base.html&quot; %}{% import 'bootstrap_wtf.html' as wtf %}{% block content %} &lt;h1&gt; 註冊 &lt;/h1&gt; {{wtf.quick_form(form) }}{% endblock %} 不是很棒嗎？頂部附近的導入語句在模板方面類似於 Python 的導入。它增加了一個 wtf.quick_form() 宏，在單行程式碼中渲染完整的表單，包括驗證錯誤，並且全部適當地遵循 Bootstrap 框架的風格。 我這次不打算展示我為應用程式中其他表單所做的所有更改，但這些更改都在你可以從 GitHub 下載或檢查的範本中進行了。 部落格帖子的渲染渲染單個部落格帖子的呈現邏輯被抽象成一個名為 _post.html 的子範本。我需要對這個範本做的就是進行一些小調整，使其在 Bootstrap 下看起來不錯。 app/templates/_post.html: 重新設計的帖子子範本。 1234567891011121314151617&lt;table class=&quot;table table-hover&quot;&gt; &lt;tr&gt; &lt;td width=&quot;70px&quot;&gt; &lt;a href=&quot;{{ url_for('user', username=post.author.username) }}&quot;&gt; &lt;img src=&quot;{{ post.author.avatar(70) }}&quot; /&gt; &lt;/a&gt; &lt;/td&gt; &lt;td&gt; &lt;a href=&quot;{{ url_for('user', username=post.author.username) }}&quot;&gt; {{post.author.username}} &lt;/a&gt; 說： &lt;br&gt; {{post.body}} &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 渲染分頁連結分頁連結是 Bootstrap 提供支援的另一個領域。對此，我再次參考了 Bootstrap 文件並適應了其中的一個範例。這是它們在 index.html 頁面中的樣子： app/templates/index.html: 重新設計的分頁連結。 123456789101112131415...&lt;nav aria-label=&quot;帖子導航&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li class=&quot;page-item{% if not prev_url %} disabled{% endif %}&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;{{ prev_url}}&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;larr;&lt;/span&gt; 較新的帖子 &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;page-item{% if not next_url %} disabled{% endif %}&quot;&gt; &lt;a class=&quot;page-link&quot; href=&quot;{{ next_url}}&quot;&gt; 較舊的帖子 &lt;span aria-hidden=&quot;true&quot;&gt;&amp;rarr;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 請注意，在這個實現中，當該方向沒有更多內容時，我不是隱藏下一個或上一個連結，而是應用一個禁用狀態，這將使連結看起來變灰。 我這裡不會展示，但需要對 user.html 進行類似的更改。這一章節的下載套件包含了這些更改。 Before And After要用這些更改更新你的應用程式，請下載本章節的壓縮檔，並相應地更新你的範本。 下面你可以看到一些變更前後的圖片，看看變化。請記住，這個變化是在沒有更改任何一行應用程式邏輯的情況下實現的！","link":"/python/flask-mega-tutorial/chapter_11_facelift.html"},{"title":"Chapter 12: Dates and Times","text":"Posted by on Miguel Grinberg 這是 Flask Mega-Tutorial 系列的第十二部分，在這一章，我將告訴你如何處理日期和時間，以便適應所有使用者，不論他們居住在哪裡。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 我長時間忽略了我的 Microblog 應用程式的一個方面，那就是日期和時間的顯示。直到現在，我只是讓 Python 渲染 User 模型中的 datetime 物件，甚至沒有顯示 Post 模型中的時間。在這一章，你將學習如何處理這些時間戳記。 本章的 GitHub 連結是：Browse Zip Diff 時區地獄在伺服器上使用 Python 來渲染展示給網頁瀏覽器上使用者的日期和時間，實際上並不是一個好主意，因為伺服器認為的當地時間對於居住在不同時區的使用者來說並沒有意義。 很明顯，伺服器必須管理與其自身位置和使用者位置無關的一致時間。如果這個應用程式發展到需要在世界各地不同地區部署多個生產伺服器，我不希望每個伺服器都以不同時區將時間戳記寫入資料庫，因為這會使得處理這些時間變得不可能。由於 UTC 是最常用的統一時區，且在 datetime 類別中受到支援，這就是我將要使用的。 在第四章中，你已經看到了如何為博客文章生成 UTC 時間戳記。作為提醒，這裡有一個簡短的例子，展示了這是如何完成的： 123&gt;&gt;&gt; from datetime import datetime, timezone&gt;&gt;&gt; str(datetime.now(timezone.utc))'2023-11-19 19:05:51.288261+00:00' 但這種方法有一個重要的問題。對於處於不同位置的使用者來說，如果他們看到的是 UTC 時區的時間，將很難確定文章是何時發表的。他們需要事先知道這些時間是 UTC，這樣他們才能在心理上將時間調整到自己的時區。想像一下，假設在美國西海岸 PDT 時區的一位使用者在下午 3:00 發表了某些內容，並立即看到該帖子顯示為晚上 10:00 的 UTC 時間，或更確切地說是 22:00。這將非常令人困惑。 雖然將時間戳記標準化為 UTC 從伺服器的角度來看很有意義，但這為使用者創造了一個可用性問題。本章的目標是提出一個解決方案，保持伺服器管理的所有時間戳記都在 UTC 時區，而不會疏遠使用者。 時區轉換解決這個問題的顯而易見的方法是將所有存儲的 UTC 時間轉換為每個使用者的當地時間，當它們 被渲染時。這允許伺服器繼續使用 UTC 以保持一致性，同時針對每個使用者的即時轉換解決了可用性問題。這個解決方案的棘手之處在於要知道每個使用者的位置。 許多網站都有一個配置頁面，讓使用者可以指定他們的時區。這將要求我加入一個新頁面，並在其中提供一個下拉菜單，列出時區。可以在使用者首次訪問網站時作為他們註冊的一部分，要求他們輸入自己的時區。 雖然這是一個解決問題的不錯方案，但要求使用者輸入他們在作業系統中已經配置的訊息有點奇怪。似乎如果我可以直接從他們的電腦中獲取時區設置會更有效率。 事實證明，網頁瀏覽器知道使用者的時區，並通過標準的日期和時間 JavaScript API 公開它。實際上有兩種方法可以利用 JavaScript 提供的時區訊息： “傳統” 方法是讓網頁瀏覽器在使用者首次登錄應用程式時以某種方式將時區訊息發送給伺服器。這可以通過 Ajax 調用來完成，或者更簡單地通過 meta 刷新標籤來完成。一旦伺服器知道了時區，它可以將其保留在使用者的會話中，或寫入到資料庫中的使用者表中，然後從那時起在渲染範本時調整所有時間戳記。“新派” 方法則是在伺服器上不做任何改變，讓 UTC 轉換為當地時區的工作在瀏覽器中使用 JavaScript 完成。這兩種選擇都是有效的，但第二種有一個很大的優勢。僅僅知道使用者的時區並不足以以使用者期望的格式呈現日期和時間。瀏覽器還可以訪問系統區域設置，該設置指定了 AM/PM 與 24 小時制、DD/MM/YYYY 與 MM/DD/YYYY 日期格式等許多文化或地區風格。 如果這還不夠，對於新派方法還有一個更大的優勢。有一個開源庫可以完成所有這些工作！ 介紹 Moment.js 和 Flask-MomentMoment.js 是一個小型的開源 JavaScript 函式庫，它將日期和時間的呈現提升到另一個層次，因為它提供了所有想得到的格式化選項，甚至更多。不久前，我建立了 Flask-Moment，這是一個小型的 Flask 擴充套件，使得將 moment.js 整合到你的應用程式變得非常簡單。 那我們就從安裝 Flask-Moment 開始： 1(venv) $ pip install flask-moment 這個擴充套件以常見的方式加入到 Flask 應用程式中： app/__init__.py: Flask-Moment 實例。 1234567## ...from flask_moment import Momentapp = Flask(__name__)## ...moment = Moment(app)## ... 與其他擴充套件不同，Flask-Moment 與 moment.js 一起工作，因此所有應用程式的範本都必須包含這個函式庫。為了確保這個函式庫始終可用，我打算在基本範本中加入它。這可以通過兩種方式完成。最直接的方式是明確加入一個 &lt;script&gt; 標籤來導入函式庫，但 Flask-Moment 使之更簡單，通過暴露一個 moment.include_moment() 函式來生成 &lt;script&gt; 標籤： app/templates/base.html: 在基本範本中包含 moment.js。 12345... {{moment.include_moment() }} &lt;/body&gt;&lt;/html&gt; 在大多數情況下，應用程式使用的 JavaScript 函式庫都包含在 &lt;body&gt; 內容的末尾，那裡有 Bootstrap 的 JavaScript 程式碼。 使用 Moment.jsMoment.js 為瀏覽器提供了一個 moment 類。渲染時間戳的第一步是建立這個類的對象，傳入所需的時間戳，格式為 ISO 8601。這裡是在瀏覽器的 JavaScript 控制台中運行的一個範例： 1t = moment('2021-06-28T21:45:23+00:00') 如果你不熟悉 ISO 8601 標準的日期和時間格式，該格式如下： 1{yyyy}-{mm}-{dd}T{hh}:{mm}:{ss}{tz} 我已經決定只使用 UTC 時區，因此最後一部分始終是 +00:00，或在某些情況下是等效的 Z，代表 ISO 8601 標準中的 UTC。 moment 對象提供了多種不同的渲染選項。以下是一些最常見的選項： 123456789101112moment('2021-06-28T21:45:23+00:00').format('L')'06/28/2021'moment('2021-06-28T21:45:23+00:00').format('LL')'June 28, 2021'moment('2021-06-28T21:45:23+00:00').format('LLL')'June 28, 2021 10:45 PM'moment('2021-06-28T21:45:23+00:00').format('LLLL')'Monday, June 28, 2021 10:45 PM'moment('2021-06-28T21:45:23+00:00').format('dddd')'Monday'moment('2021-06-28T21:45:23+00:00').fromNow()'2 years ago' 本範例建立了一個初始化為 2021 年 6 月 28 日下午 9:45 UTC 的 moment 物件。你可以看到我上面嘗試的所有選項都顯示為 UTC+1，這是我電腦上配置的時區。你可以在瀏覽器的主控台輸入上述指令，確保你開啟主控台的頁面已包含 moment.js。只要你已經做了上述更改以包含 moment.js，就可以在 microblog 上進行，或也可以在 https://momentjs.com/ 上操作。 注意不同方法如何建立不同的表示形式。使用 format() 時，你可以用格式字串控制輸出的格式。fromNow() 方法很有趣，因為它是根據目前時間渲染時間戳，所以你會得到像是「一分鐘前」或「兩小時後」等輸出。 如果你是直接在 JavaScript 中工作，上述調用會返回一個包含渲染時間戳的字串。然後由你將此文本插入頁面的適當位置，這不幸地需要與 DOM 進行互動。Flask-Moment 擴充功能透過在你的模板中啟用類似於 JavaScript 中的 moment 物件，大大簡化了 moment.js 的使用。 我們來看看個人資料頁面上的時間戳。目前的 user.html 模板讓 Python 生成時間的字串表示。我現在可以用 Flask-Moment 來渲染這個時間戳，如下所示： app/templates/user.html：使用 moment.js 渲染時間戳。 123{% if user.last_seen %}&lt;p&gt; 最後上線時間：{{ moment(user.last_seen).format('LLL') }}&lt;/p&gt;{% endif %} 所以正如你所見，Flask-Moment 使用的語法類似於 JavaScript 函式庫的語法，不同之處在於，傳遞給 moment() 的參數現在是一個 Python datetime 物件，而不是 ISO 8601 字串。從模板發出的 moment() 調用會自動生成所需的 JavaScript 程式碼，將渲染的時間戳插入 DOM 的適當位置。 我可以利用 Flask-Moment 的第二個地方是在 _post.html 子模板中，該模板從 index 和 user 頁面調用。在目前版本的模板中，每個帖子前面都有一行「使用者名稱說：」。現在我可以加上用 fromNow() 渲染的時間戳： app/templates/_post.html：在帖子子模板中渲染時間戳。 123456&lt;a href=&quot;{{ url_for('user', username=post.author.username) }}&quot;&gt; {{post.author.username}}&lt;/a&gt;說 {{moment(post.timestamp).fromNow() }}：&lt;br&gt;{{post.body}} 下面你可以看到使用 Flask-Moment 和 moment.js 渲染的這兩個時間戳的樣子：","link":"/python/flask-mega-tutorial/chapter_12_dates_and_times.html"},{"title":"Chapter 14: Ajax","text":"Posted by on Miguel Grinberg 這是 Flask 大型教程系列的第十四部分，在這部分中，我將使用 Microsoft 的翻譯服務和一點點 JavaScript 來增加即時語言翻譯功能。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 在這篇文章中，我將脫離伺服器端開發的 “安全區”，去處理一個同樣重要的伺服器和客戶端組件的功能。你有沒有看到一些網站旁邊使用者生成的內容旁邊顯示的“翻譯” 連結？這些連結觸發對使用者母語以外的內容進行即時自動翻譯。翻譯後的內容通常插入在原始版本下方。Google 在外語搜索結果中展示這個功能。Facebook 用於帖子，Twitter 用於推文。今天我將向你展示如何將同樣的功能加入到 Microblog！ 這一章的 GitHub 連結是：Browse Zip Diff 伺服器端對比客戶端在我迄今為止所遵循的傳統伺服器端模型中，有一個客戶端（由使用者指揮的網頁瀏覽器）向應用伺服器發出 HTTP 請求。一個請求可以僅僅是請求一個 HTML 頁面，就像當你點擊 “個人資料” 連結時，或者它可以觸發一個動作，就像當你在編輯你的個人資料訊息後點擊提交按鈕時。在這兩種類型的請求中，伺服器通過將新網頁發送給客戶端來完成請求，要么直接發送，要么通過發出重定向。然後客戶端用新頁面替換當前頁面。只要使用者停留在應用的網站上，這個循環就會重複。在這個模型中，伺服器做所有工作，而客戶端僅僅顯示網頁並接受使用者輸入。 還有一種模型，客戶端扮演一個更積極的角色。在這種模型中，客戶端向伺服器發出請求，伺服器回應一個網頁，但與之前的情況不同的是，不是所有頁面數據都是 HTML，頁面上還有用通常用 JavaScript 寫的程式碼。一旦客戶端接收到頁面，它顯示 HTML 部分，並執行程式碼，這通常不會立即運行，而是設置事件處理器，在瀏覽器中作為對使用者觸發的動作的回應運行。從那時起，你就有了一個活躍的客戶端，它可以在幾乎不和伺服器聯繫或完全不聯繫的情況 下自行工作。在嚴格的客戶端應用中，整個應用程式隨著初始頁面請求下載到客戶端，然後應用程式完全在客戶端運行，只與伺服器聯繫以檢索或存儲數據，並對那個首個且唯一的網頁的外觀進行動態更改。這類應用被稱為單頁應用或 SPA。 大多數應用都是兩種模型的混合體，結合了兩者的技術。我的 Microblog 應用主要是伺服器端應用，但今天我將為它加入一點客戶端動作。為了實現使用者帖子的即時翻譯，客戶端瀏覽器將向伺服器發送異步請求，伺服器將回應而不會引起頁面刷新。然後客戶端將翻譯動態插入當前頁面。這種技術被稱為 Ajax，是 Asynchronous JavaScript 和 XML（即使這些天 XML 常常被 JSON 替代）的縮寫。 即時翻譯工作流程這個應用程式因為 Flask-Babel 的支持，對外語有很好的支持，這使得支持我能找到翻譯的任何語言成為可能。但當然，還缺少一個元素。使用者將以他們自己的語言寫博客帖子，所以很可能使用者會遇到其他使用者用不知道的語言寫的帖子。自動翻譯的質量並不總是很好，但在大多數情況下，如果你只是想大致了解另一種語言的文字意思，它就足夠好了。 這是一個理想的功能，作為 Ajax 服務來實現。考慮到索引或探索頁面可能顯示幾個帖子，其中一些可能是外語。如果我使用傳統的伺服器端技術實現翻譯，對翻譯的請求將導致原始頁面被新頁面取代。事實是，對許多顯示的博客帖子中的一個請求翻譯不是一個足夠大的動作，需要完整的頁面更新，這個功能如果翻譯文本動態地插入原文下方，同時讓頁面的其餘部分保持不變，會運作得更好。 要實作即時自動翻譯需要幾個步驟。首先，我需要一種方法來識別要翻譯的文字的來源語言。我還需要知道每位使用者的首選語言，因為我只想對用其他語言寫的帖子顯示「翻譯」連結。當提供翻譯連結且使用者點擊時，我將需要向伺服器發送 Ajax 請求，伺服器會聯絡第三方翻譯 API。一旦伺服器返回帶有翻譯文字的回應，客戶端的 JavaScript 程式碼會動態地將這段文字插入頁面中。你肯定會注意到，這裡有一些非小題大作的問題。我將逐一來看這些問題。 語言識別第一個問題是識別帖子是用什麼語言寫的。這不是一門精確的科學，因為不總是能夠毫無疑問地確定文本的語言，但對於大多數情況來說，自動檢測效果相當不錯。在 Python 中，有一個不錯的語言檢測函式庫叫做 langdetect。 1(venv) $ pip install langdetect 計畫是將每篇部落格帖子餵給這個套件，嘗試確定語言。由於進行這項分析有點耗時，我不想每次將帖子呈現到頁面上時都重複這項工作。我將要做的是在提交帖子時設定檢測到的語言。然後，檢測到的語言將被儲存在帖子表中。 首先要做的是向 Post 模型加入一個語言欄位： 12345app/models.py: 向 Post 模型加入檢測到的語言。class Post(db.Model): ## ... language: so.Mapped[Optional[str]] = so.mapped_column(sa.String(5)) 如你所記，每當對資料庫模型進行更改時，需要發出資料庫遷移： 12345(venv) $ flask db migrate -m &quot;add language to posts&quot;INFO [alembic.runtime.migration] Context impl SQLiteImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.autogenerate.compare] Detected added column 'post.language' Generating migrations/versions/2b017edaa91f_add_language_to_posts.py ... done 然後需要將遷移應用於資料庫： 1234(venv) $ flask db upgradeINFO [alembic.runtime.migration] Context impl SQLiteImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.runtime.migration] Upgrade ae346256b650 -&gt; 2b017edaa91f, add language to posts 現在我可以在提交帖子時檢測並儲存語言： 12345678910111213141516171819app/routes.py: 為新帖子保存語言。from langdetect import detect, LangDetectException@app.route('/', methods=['GET', 'POST'])@app.route('/index', methods=['GET', 'POST'])@login_requireddef index(): form = PostForm() if form.validate_on_submit(): try: language = detect(form.post.data) except LangDetectException: language = '' post = Post(body=form.post.data, author=current_user, language=language) ## ... 有了這個改變，每次提交帖子時，我都會透過 detect() 函式來嘗試確定語言。如果無法識別語言，langdetect 套件會引發一種 LangDetectException 例外。在這種情況下，我會安全起見，將一個空字串保存到資料庫中。我將採用這樣的慣例：任何將語言設為空字串的帖子都被假定為未知語言。 顯示「翻譯」連結第二步涉及在當前使用者激活的語言不是帖子語言的情況下，加入一個「翻譯」連結到帖子旁邊。 123456app/templates/_post.html: 為帖子加入翻譯連結。 {% if post.language and post.language != g.locale %} &lt;br&gt;&lt;br&gt; &lt;a href=&quot;#&quot;&gt;{{ _('Translate') }}&lt;/a&gt; {% endif %} 我是在 _post.html 子模板中做這件事，這樣這個功能就會出現在任何顯示部落格帖子的頁面上。翻譯連結僅出現在檢測到語言且此語言與 Flask-Babel 的 locale_selector 函式裝飾的函式選擇的語言不匹配的帖子上。回想一下第 13 章，選定的語言環境被儲存在 before_request 處理程式中的 g.locale。連結的文字需要以一種可以由 Flask-Babel 翻譯的方式加入，所以我在定義它時使用了 _() 函式。 注意，這個連結還沒有關聯任何動作。首先，我想弄清楚如何進行實際的翻譯。 使用第三方翻譯服務兩大主要翻譯服務是 Google Cloud Translation API 和 Microsoft Translator Text API。兩者都是付費服務，並且都有針對低量翻譯的免費入門級選項。在這一章中，我將實現 Microsoft 解決方案，但我會以一種易於替換翻譯服務（如果你希望如此）的方式進行。 在你使用 Microsoft Translator API 之前，你需要在 Azure，即 Microsoft 的雲服務，註冊一個帳戶。你可以在他們的免費層上註冊。在註冊過程中，你將被要求提供信用卡號碼，但只要你留在那個服務層級，你的卡不會被收費。 一旦你擁有了 Azure 帳戶，前往 Azure 門戶並點擊「建立資源」按鈕，於搜索框輸入「translator」並按 Enter 鍵。從搜索結果中找到 Translator 資源，然後點擊「建立」按鈕。你現在將看到一個表單，你可以在其中定義將加入到你帳戶的新翻譯資源。按以下方式完成表單： 訂閱：選擇「按需付費」 資源群組：點擊「建立新的」，並輸入名稱「microblog-translator」 區域：選擇離你最近的區域 名稱：輸入「microblog」 定價層：選擇「免費 F0（每月最多 2M 字符翻譯）」 點擊「審查 + 建立」按鈕繼續到下一頁，在那裡你將看到你所選擇的選項摘要。點擊「建立」按鈕確認建立翻譯資源。如果你等待幾秒鐘，你將在頂部欄中收到一個通知，說明翻譯資源已部署。點擊「前往資源」按鈕，然後在左側欄中點擊「金鑰和端點」選項。你現在將看到兩個金鑰，標籤分別為「金鑰 1」和「金鑰 2」。複製其中一個金鑰到剪貼板，然後將其輸入到你終端機中的環境變數中（如果你正在使用 Microsoft Windows，請將 export 替換為 set）： 1(venv) $ export MS_TRANSLATOR_KEY=&lt; 粘貼你的金鑰 &gt; 這個金鑰用於向翻譯服務進行身份驗證，因此需要將其加入到應用程式配置中： config.py：將 Microsoft Translator API 金鑰加入到配置中。 123class Config(object): ## ... MS_TRANSLATOR_KEY = os.environ.get('MS_TRANSLATOR_KEY') 如同所有配置值，我更喜歡將它們安裝在環境變數中，並從那裡導入到 Flask 配置中。對於使能訪問第三方服務的敏感訊息，如金鑰或 密碼，這特別重要。你絕對不想在程式碼中明確寫出這些。 Microsoft Translator API 是一個接受 HTTP 請求的網絡服務。Python 中有幾個 HTTP 客戶端，但最受歡迎且易於使用的是 requests 套件。讓我們將其安裝到虛擬環境中： 1(venv) $ pip install requests 以下你可以看到我編寫的使用 Microsoft Translator API 翻譯文本的函式。我將其放在一個新的 app/translate.py 模組中： app/translate.py：文本翻譯函式。 12345678910111213141516171819import requestsfrom flask_babel import _from app import appdef translate(text, source_language, dest_language): if 'MS_TRANSLATOR_KEY' not in app.config or \\ not app.config['MS_TRANSLATOR_KEY']: return _('錯誤：翻譯服務未配置。') auth = { 'Ocp-Apim-Subscription-Key': app.config['MS_TRANSLATOR_KEY'], 'Ocp-Apim-Subscription-Region': 'westus', } r = requests.post( 'https://api.cognitive.microsofttranslator.com' '/translate?api-version=3.0&amp;from={}&amp;to={}'.format( source_language, dest_language), headers=auth, json=[{'Text': text}]) if r.status_code != 200: return _('錯誤：翻譯服務失敗。') return r.json()[0]['translations'][0]['text'] 此函式接受要翻譯的文本和源語言程式碼與目標語言程式碼作為參數，並返回一個帶有翻譯文本的字串。它首先檢查配置中是否有翻譯服務的金鑰，如果未定義金鑰則返回錯誤。錯誤也是一個字串，所以從外部看，這將看起來像翻譯過的文本。這確保了在出錯的情況下，使用者將看到一個有意義的錯誤訊息。 requests 套件的 post() 方法向作為第一個參數給定的 URL 發送一個帶有 POST 方法的 HTTP 請求。我使用的基本 URL 出現在翻譯資源的「金鑰和端點」頁面中，即 https://api.cognitive.microsofttranslator.com/。翻譯端點的路徑為 /translate，如文件中所述。 源語言和目標語言需要作為 URL 中的查詢字串參數給出，分別命名為 from 和 to。API 還要求在查詢字串中給出 api-version=3.0 參數。要翻譯的文本需要以 JSON 格式在請求的主體中給出，格式為 {“Text”: “要翻譯的文本在這裡”}。 要與服務進行認證，我需要傳遞我加入到配置中的密鑰。這個密鑰需要在自定義的 HTTP 標頭中提供，名為 Ocp-Apim-Subscription-Key。同樣需要提供部署翻譯資源的區域，在名為 Ocp-Apim-Subscription-Region 的標頭中提供。你需要提供的區域名稱顯示在「金鑰和端點」頁面下方，就在兩個金鑰下面。在我的案例中，是 westus，代表我選擇的西美地區，但如果你選擇了不同的區域，則會有所不同。我已經用這兩個標頭建立了 auth 字典，然後將其傳遞給 requests 的 headers 參數。 獲取響應物件requests.post() 方法返回一個響應物件，其中包含服務提供的所有細節。我首先需要檢查狀態碼是否為 200，這是成功請求的程式碼。如果我得到任何其他程式碼，我知道出現了錯誤，所以在那種情況下我會返回一個錯誤字串。如果狀態碼是 200，則響應的主體中有一個 JSON 編碼的字串與翻譯，所以我需要做的就是使用響應物件的 json() 方法來解碼 JSON，轉換成我可以使用的 Python 字串。JSON 響應是一個翻譯列表，但由於我們翻譯的是單一文字，我可以獲取第一個元素並在翻譯結構內找到實際的翻譯文字。 使用 translate() 函式你可以在下面看到一個 Python 控制台會話，我在其中使用了新的 translate() 函式： 123456789&gt;&gt;&gt; from app.translate import translate&gt;&gt;&gt; translate('Hi, how are you today?', 'en', 'es') ## 英文轉西班牙文'Hola, ¿cómo estás hoy?'&gt;&gt;&gt; translate('Hi, how are you today?', 'en', 'de') ## 英文轉德文'Are Hallo, how you heute?'&gt;&gt;&gt; translate('Hi, how are you today?', 'en', 'it') ## 英文轉義大利文'Ciao, come stai oggi?'&gt;&gt;&gt; translate('Hi, how are you today?', 'en', 'fr') ## 英文轉法文&quot;Salut, comment allez-vous aujourd'hui ?&quot; 非常酷，對吧？現在是時候將這個功能整合到應用程式中了。 從 Server 開始實作 Ajax我將從實現伺服器端部分開始。當使用者點擊帖子下方出現的「翻譯」連結時，將向伺服器發出異步 HTTP 請求。我將在下一節中向你展示如何做到這一點，所以現在我將專注於實現伺服器對這個請求的處理。 一個異步（或 Ajax）請求與我在應用程式中建立的路由和視圖函式類似，唯一的區別是它不返回 HTML 或重定向，而只返回數據，格式為 XML 或更常見的 JSON。下面你可以看到翻譯視圖函式，它調用 Microsoft Translator API，然後以 JSON 格式返回翻譯後的文字： 12345678910## app/routes.py: 文字翻譯視圖函式from app.translate import translate@app.route('/translate', methods=['POST'])@login_requireddef translate_text(): data = request.get_json() return {'text': translate(data['text'], data['source_language'], data['dest_language'])} 正如你所看到的，這非常簡短。我將這個路由實現為 POST 請求，這是客戶端需要向伺服器提交數據時的首選格式。 request.get_json() 方法返回一個字典，其中包含客戶端以 JSON 格式提交的數據。我在這個函式中所做的是調用上一節的 translate() 函式，直接從提交的請求中的 JSON 數據傳遞三個參數。結果被整合到一個名為 text 的單一鍵的字典中，作為響應返回。Flask 會自動將視圖函式返回的字典轉換為 JSON 格式。 例如，如果客戶端想將字串 Hello, World! 翻譯成西班牙文，這個請求的響應將具有以下有效負載： 1{&quot;text&quot;: &quot;Hola, Mundo!&quot;} 從 Client 實作 Ajax所以現在伺服器能夠通過 /translate URL 提供翻譯，我需要在使用者點擊我上面加入的「翻譯」連結時調用這個 URL，傳遞要翻譯的文字和源語言和目標語言。如果你不熟悉在瀏覽器中使用 JavaScript，這將是一個很好的學習經驗。 在瀏覽器中使用 JavaScript 時，當前顯示的頁面在內部以文件物件模型或 DOM 表示。這是一個層次結構，參考頁面中存在的所有元素。在這個上下文中運行的 JavaScript 程式碼可以對 DOM 進行更改以觸發頁面中的更改。 讓我們首先討論一下我的 JavaScript 程式碼在瀏覽器中運行時如何獲取我需要發送到伺服器上運行的 translate() 函式的三個參數。要獲取文字，我需要找到包含博客帖子正文的 DOM 節點並讀取其內容。為了便於識別包含博客帖子的 DOM 節點，我將為它們附加一個唯一的 ID。如果你查看 _post.html 模板，渲染帖子正文的行僅為 。我要做的是將這個內容包裹在一個 元素中。這不會在視覺上有任何改變，但它提供了一個我可以插入識別符的地方： app/templates/_post.html：為每篇部落格文章增加一個 ID。 1&lt;span id=&quot;post{{ post.id}}&quot;&gt;{{ post.body }}&lt;/span&gt; 這會為每篇部落格文章指派一個獨特的識別符，格式為 post1、post2 等等，其中數字對應每篇文章在資料庫中的識別符。現在每篇部落格文章都有了獨特的識別符，我可以使用瀏覽器中可用的 document.getElementById() 函式來定位該文章的 &lt;span&gt; 元素並提取其中的文字。例如，如果我想獲得 ID 為 123 的文章的文字，我會這麼做： 1document.getElementById('post123').innerText 我也希望有一個地方，一旦從伺服器接收到翻譯後，我可以插入翻譯過的文字。因此，我要把「翻譯」連結替換成翻譯過的文字，所以我也需要有一個獨特的識別符來輕鬆定位它： app/templates/_post.html：為翻譯連結增加一個 ID。 123&lt;span id=&quot;translation{{ post.id}}&quot;&gt; &lt;a href=&quot;#&quot;&gt;{{ _('翻譯') }}&lt;/a&gt;&lt;/span&gt; 所以現在對於一個給定的文章 ID，我有一個 post 節點用於部落格文章，和一個相應的 translation 節點，我將需要在收到翻譯後替換翻譯連結為翻譯過的文字。 下一步是撰寫一個可以做所有翻譯工作的函式。這個函式將會接受輸入和輸出的 DOM 節點，以及來源和目標語言。然後它會向伺服器發送異步請求，需要三個參數，最後用伺服器返回的翻譯過的文字替換「翻譯」連結。這聽起來像很多工作，但實現其實相當簡短。為了方便，這個函式將被加入在底部的基本範本中，這樣它就可以在應用程式的所有頁面中使用。 app/templates/base.html：客戶端翻譯函式。 1234567891011121314151617181920...&lt;script&gt; async function translate(sourceElem, destElem, sourceLang, destLang) { document.getElementById(destElem).innerHTML = '&lt;img src=&quot;{{ url_for('static', filename='loading.gif') }}&quot;&gt;'; const response = await fetch('/translate', { method: 'POST', headers: {'Content-Type': 'application/json; charset=utf-8'}, body: JSON.stringify({ text: document.getElementById(sourceElem).innerText, source_language: sourceLang, dest_language: destLang }) }) const data = await response.json(); document.getElementById(destElem).innerText = data.text; }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; translate() 函式的前兩個參數是文章和翻譯連結節點的獨特 ID，分別稱為 sourceElem 和 destElem。第三和第四個參數是來源和目標語言程式碼。這個函式使用 async 關鍵字定義，這樣它可以使用 await 關鍵字等待異步函式。 這個函式做的第一件事是化妝性的，但非常酷：它加入了一個旋轉器圖片來替換「翻譯」連結，讓使用者知道翻譯正在進行中。這是通過將 destElem 引用的元素的 innerHTML 屬性賦值來完成的，有效地用新的 HTML 替換了該元素的內容。對於旋轉器，我將使用我加入到 app/static/loading.gif 目錄中的一個小動畫 GIF，Flask 保留此目錄用於靜態檔案。為了產生引用此圖片的 URL，我使用 url_for() 函式，傳入特殊的路由名稱 static 並提供圖片的檔案名稱作為參數。你可以在本章的下載套件中找到 loading.gif 圖片。 現在我有了一個漂亮的旋轉器取代了翻譯連結，所以使用者知道要等待一會兒翻譯出現。下一步是向我在上一節中定義的 /translate URL 發送 POST 請求。為此，我將使用瀏覽器提供的 fetch() 函式。這個函式將數據提交給在第一個參數中給出的 URL 的伺服器。作為第二個參數傳遞的字典定義了請求的特徵，包括要使用的 HTTP 方法、任何標頭和帶有數據的請求主體。 請求主體是使用 JSON.stringify() 函式生成的字串，該函式接受帶有數據的字典並返回帶有該數據的 JSON 有效載荷。Content-Type 標頭被加入到請求中，告訴伺服器數據以 JSON 格式給出。 fetch() 函式是異步的，這意味著它返回一個承諾對象。為了簡化其處理，使用 await 關鍵字等待這個函式完成。返回值是一個響應對象。 伺服器在此請求中返回 JSON 數據，因此使用 response.json() 方法將其轉換為字典（在 JavaScript 中稱為「物件」）。這也是一個異步操作，因此再次使用 await 關鍵字。這種轉換的結果存儲在 data 中。 函式的最後一行將 destElem 節點的 innerText 屬性（現在有一個旋轉器圖片）設置為伺服器返回的文字，這要麼是輸入文字的翻譯版本，要麼是一個錯誤訊息。 翻譯連結處理器所以現在唯一剩下的就是在使用者點擊「翻譯」連結時，觸發 translate() 函式，並傳入正確的參數。這裡有幾種方法可以做到這一點，我要做的就是將呼叫函式的程式碼嵌入連結的 href 屬性中： 123456789app/templates/_post.html: 翻譯連結處理器。&lt;span id=&quot;translation{{ post.id}}&quot;&gt; &lt;a href=&quot;javascript:translate( 'post{{post.id}}', 'translation{{post.id}}', '{{post.language}}', '{{g.locale}}');&quot;&gt;{{ _('Translate') }}&lt;/a&gt;&lt;/span&gt; 連結的 href 元素可以接受任何 JavaScript 程式碼，如果它以 javascript: 為前綴，那就是一個方便的方式來呼叫翻譯函式。因為這個連結會在伺服器端渲染，當客戶端請求頁面時，我可以使用 {{}} 表達式來產生函式的四個參數。每篇貼文都會有自己的翻譯連結，並且有其獨特生成的參數。 翻譯功能完成現在即時翻譯功能完成了！如果你已經在你的環境中設置了有效的 Microsoft Translator API 金鑰，你現在應該能夠觸發翻譯。假設你的瀏覽器設置為偏好英語，你需要用另一種語言撰寫貼文來看到「翻譯」連結。以下你可以看到一個例子： 在本章中，我介紹了一些新的文本，這些文本需要被翻譯成應用程式支援的所有語言，因此需要更新翻譯目錄： 1(venv) $ flask translate update 對於你自己的專案，你接下來需要編輯每個語言儲存庫中的 messages.po 檔案，以包含這些新測試的翻譯，但我已經在這章節的下載包或 GitHub 儲存庫中建立了西班牙語翻譯。 要發布新的翻譯，它們需要被編譯： 1(venv) $ flask translate compile","link":"/python/flask-mega-tutorial/chapter_14_ajax.html"},{"title":"Chapter 13: I18n and L10n","text":"Posted by on Miguel Grinberg 這是 Flask Mega-Tutorial 系列的第十三篇文章，在這篇文章中，我將告訴你如何擴展 Microblog 以支援多種語言。作為這個努力的一部分，你還將學習如何為 flask 命令建立自己的命令列擴展。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 本章的主題是國際化和本地化，通常縮寫為 I18n 和 L10n。為了讓不會說英語的人也能友善地使用我的應用程式，我將實現一個翻譯流程。藉助於一個翻譯團隊的幫助，將允許我以多種語言向使用者提供應用程式。 本章的 GitHub 連結包括：瀏覽、壓縮檔、差異。Browse Zip Diff 介紹 Flask-Babel如你所猜，有一個 Flask 擴展使得處理翻譯變得非常容易。這個擴展叫做 Flask-Babel，可以通過 pip 安裝： 1(venv) $ pip install flask-babel 在這一章中，我將展示如何將應用程式翻譯成西班牙語，因為我恰好會說這門語言。我也可以與其他語言流利的翻譯者合作，同樣支援這些語言。為了追蹤支援的語言列表，我將加入一個配置變數： 1234## config.py: 支援的語言列表。class Config(object): ## ... LANGUAGES = ['en', 'es'] 我在這個應用程式中使用了兩個字母的語言程式碼，但如果你需要更具體，也可以加入國家程式碼。例如，你可以使用 en-US、en-GB 和 en-CA 分別支援美國英語、英國英語和加拿大英語作為不同的語言。 Babel 實例是使用一個 locale_selector 參數初始化的，這個參數必須設定為一個函式，該函式將在每個請求中被調用。這個函式可以查看使用者請求並為該請求選擇最佳語言翻譯。以下是 Flask-Babel 擴展的初始化： 123456789101112## app/__init__.py: 初始化 Flask-Babel。from flask import request## ...from flask_babel import Babeldef get_locale(): return request.accept_languages.best_match(app.config['LANGUAGES'])app = Flask(__name__)## ...babel = Babel(app, locale_selector=get_locale)## ... 在這裡，我使用了 Flask 的請求物件的一個屬性，稱為 accept_languages。這個物件提供了一個高級接口，用於處理客戶端隨請求發送的 Accept-Language 頭部。這個 頭部指定了客戶端的語言和地區偏好作為一個加權列表。這個頭部的內容可以在瀏覽器的偏好設定頁面中配置，預設值通常從電腦作業系統的語言設定中導入。大多數人甚至不知道這樣的設定存在，但這是有用的，因為使用者可以提供一個首選語言列表，每種語言都有一個權重。如果你好奇，這裡有一個複雜的 Accept-Languages 頭部範例： 1Accept-Language: da, en-gb;q=0.8, en;q=0.7 這表示丹麥語（da）是首選語言（預設權重 = 1.0），其次是英國英語（en-GB）權重為 0.8，最後是通用英語（en）權重為 0.7。 為了選擇最佳語言，你需要將客戶端請求的語言列表與應用程式支援的語言進行比較，並使用客戶端提供的權重來找到最佳語言。這個邏輯有點複雜，但都封裝在 request.accept_languages 的 best_match() 方法中，它以應用程式提供的語言列表作為參數，並返回最佳選擇。 在 Python 源碼中標記待翻譯文本好的，現在來說說壞消息。當讓應用程式支援多種語言時的正常工作流程是在源碼中標記所有需要翻譯的文本。在文本被標記後，Flask-Babel 將掃描所有檔案，並使用 gettext 工具將這些文本提取到一個單獨的翻譯檔案中。不幸的是，這是一項繁瑣的任務，需要完成以啟用翻譯。 我將在這裡展示幾個這種標記的範例，但你可以從上面顯示的本章的 GitHub 庫連結獲得完整的變更集。 為翻譯標記文本的方式是將它們包裹在一個函式呼叫中，習慣上稱為 _()，只是一個底線。最簡單的情況是源碼中出現的字面字符串。這裡是一個 flash() 語句的範例： 123from flask_babel import _## ...flash(_('Your post is now live!')) 這個想法是 _()`` 函式包裹了基礎語言中的文本（在這個案例中是英語）。這個函式將使用 get_locale() 函式選擇的語言來找到給定客戶端的正確翻譯。_()` 函式然後返回翻譯後的文本，在這個案例中將成為 flash() 的參數。 不幸的是，並非所有案例都這麼簡單。考慮應用程式中的另一個 flash() 呼叫： 1flash(f'User {username} not found.') 這篇文章中有一個動態組件，它被插入到靜態文本的中間。_() 函式的語法支援這類文本，但它是基於 Python 舊版的字串替代語法： 1flash(_('使用者 %(username)s 未找到。', username=username)) 還有一個更難處理的情況。一些字串常數是在網頁請求外部分配的，通常是在應用程式啟動時，所以在這些文本評估時，無法知道要使用什麼語言。這類的例子包括與表單欄位相關的標籤。處理這些文本的唯一解決方案是找到一種方法，延遲字串的評估，直到它們被使用，這將在實際的請求下進行。Flask-Babel 提供了一個 _() 的延遲評估版本，稱為 lazy_gettext()： 12345from flask_babel import lazy_gettext as _lclass LoginForm(FlaskForm): username = StringField(_l('使用者名稱'), validators=[DataRequired()]) ## ... 這裡我導入了這個替代翻譯函式，並將它重命名為 _l()，這樣它看起來與原始的 _() 相似。這個新函式將文本包裹在一個特殊物件中，觸發翻譯在稍後執行，當字串在請求內部使用時。 Flask-Login 擴充套件在每次將使用者重定向到登入頁面時都會閃爍一條訊息。這條訊息是英文的，來自擴充套件本身。為了確保這條訊息也被翻譯，我將覆蓋預設訊息，並提供我自己的，用 _l() 函式包裹以進行延遲處理： 123login = LoginManager(app)login.login_view = 'login'login.login_message = _l('請登入以訪問此頁面。') 在模板中標記待翻譯的文本在前一節中，你已經看到如何在 Python 源程式碼中標記可翻譯的文本，但這只是這個過程的一部分，因為模板檔案也有文本。_() 函式也可在模板中使用，因此過程相當類似。例如，請考慮來自 404.html 的 HTML 片段： 1&lt;h1&gt; 檔案未找到 &lt;/h1&gt; 啟用翻譯的版本變成： 1&lt;h1&gt;{{ _('檔案未找到') }}&lt;/h1&gt; 請注意，這裡除了使用 _() 包裹文本外，還需要加入 {{ ...}}，以強制評估 _()，而不是被視為模板中的字面量。 對於有動態組件的更複雜短語，也可以使用參數： 1&lt;h1&gt;{{ _('嗨，%(username)s！', username=current_user.username) }}&lt;/h1&gt; 在 _post.html 中有一個特別棘手的情況，讓我花了一段時間才弄明白： 123456789 {% set user_link %} &lt;a href=&quot;{{url_for('user', username=post.author.username) }}&quot;&gt; {{post.author.username}} &lt;/a&gt; {% endset %} {{_('%(username)s 說 %(when)s', username=user_link, when=moment(post.timestamp).fromNow()) }} 這裡的問題是我希望 username 是指向使用者個人檔案頁面的連結，而不僅僅是名稱，所以我必須使用 set 和 endset 模板指令建立一個名為 user_link 的中間變數，然後將其作為參數傳遞給翻譯函式。 如我上面提到的，你可以下載一個應用程式版本，其中所有 Python 源程式碼和模板中的可翻譯文本都已標記。 提取待翻譯文本一旦你有了應用程式，所有的 _() 和 _l() 都到位了，你可以使用 pybabel 命令將它們提取到一個 .pot 檔案中，這代表可攜物件模板。這是一個文本檔案，包括所有被標記為需要翻譯的文本。這個檔案的目的是作為為每種語言建立翻譯檔案的模板。 提取過程需要一個小的配置檔案，告訴 pybabel 哪些檔案應該掃描可翻譯的文本。以下是我為這個應用程式建立的 babel.cfg： babel.cfg: PyBabel 配置檔案。 12[python: app/**.py][jinja2: app/templates/**.html] 這些行分別定義了 Python 和 Jinja 模板檔案的檔名模式。Flask-Babel 將尋找匹配這些模式的任何檔案，並掃描它們以尋找被包裹以進行翻譯的文本。 要將所有文本提取到一個 .pot 檔案中，你可以使用以下命令： 1(venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot . pybabel extract 命令讀取在 -F 選項中給定的配置檔案，然後掃描與配置的源匹配的目錄中的所有程式碼和模板檔案，從命令中給定的目錄開始（在這個例子中是當前目錄或 .）。預設情況下，pybabel 將尋找 _() 作為文本標記，但我也使用了 lazy 版本，我導入為 _l()，所以我需要告訴工具也用 -k _l 尋找這些。-o 選項提供輸出檔案的名稱。 我應該指出，messages.pot 檔案不是需要納入項目的檔案。這是一個可以在需要時輕鬆重新生成的檔案，只需再次運行上面的命令。因此，無需將此檔案提交到源程式控制中。 生成語言目錄接下來的步驟是為除基礎語言（本案例中為英文）之外的每種語言建立翻譯。我說我要開始加入西班牙語（語言程式碼 es），所以這是執行該操作的指令： 12(venv) $ pybabel init -i messages.pot -d app/translations -l escreating catalog app/translations/es/LC_MESSAGES/messages.po based on messages.pot pybabel init 指令將 messages.pot 檔案作為輸入，並為在 -l 選項中指定的語言，在 -d 選項中給出的目錄寫入新的語言目錄。我將在 app/translations 目錄中安裝所有翻譯，因為 Flask-Babel 預設會在這裡尋找翻譯檔案。該指令將在該目錄內建立一個用於西班牙語資料檔的 es 子目錄。特別地，會有一個新檔案 app/translations/es/LC_MESSAGES/messages.po，需要在那裡進行翻譯。 如果你想支援其他語言，只需重複上述指令，為你想要的每種語言程式碼，以便每種語言都有其自己的帶有 messages.po 檔案的儲存庫。 每個語言儲存庫中建立的 messages.po 檔案使用的格式是語言翻譯的標準格式，即 gettext 工具所使用的格式。這裡有一些西班牙語 messages.po 開頭的幾行： 12345678910111213141516171819202122232425262728293031## PROJECT 的西班牙語翻譯。## 版權所有 (C) 2021 ORGANIZATION## 此檔案在與 PROJECT 項目相同的許可下分發。## FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, 2021.#msgid &quot;&quot;msgstr &quot;&quot;&quot;Project-Id-Version: PROJECT VERSION\\n&quot;&quot;Report-Msgid-Bugs-To: EMAIL@ADDRESS\\n&quot;&quot;POT-Creation-Date: 2021-06-29 23:23-0700\\n&quot;&quot;PO-Revision-Date: 2021-06-29 23:25-0700\\n&quot;&quot;Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\\n&quot;&quot;Language: es\\n&quot;&quot;Language-Team: es &lt;LL@li.org&gt;\\n&quot;&quot;Plural-Forms: nplurals=2; plural=(n != 1)\\n&quot;&quot;MIME-Version: 1.0\\n&quot;&quot;Content-Type: text/plain; charset=utf-8\\n&quot;&quot;Content-Transfer-Encoding: 8bit\\n&quot;&quot;Generated-By: Babel 2.5.1\\n&quot;#: app/email.py:21msgid &quot;[Microblog] Reset Your Password&quot;msgstr &quot;&quot;#: app/forms.py:12 app/forms.py:19 app/forms.py:50msgid &quot;Username&quot;msgstr &quot;&quot;#: app/forms.py:13 app/forms.py:21 app/forms.py:43msgid &quot;Password&quot;msgstr &quot;&quot; 如果跳過標頭，你會看到接下來是從 _() 和 _l() 呼叫中提取的字串列表。對於每個文本，你會得到你應用中文本位置的參考。然後 msgid 行包含基礎語言的文本，接下來的 msgstr 行包含一個空字串。這些空字串需要被編輯以包含目標語言中的文本版本。 有許多與 .po 檔案一起工作的翻譯應用。如果你覺得編輯文本檔案就足夠了，但如果你正在處理一個大型項目，則可能建議使用專業的翻譯編輯器。最受歡迎的翻譯應用是開源的 poedit，那麼 po.vim 插件提供了一些鍵映射，使這些檔案的工作更容易。 下面你可以看到我加入翻譯後的西班牙語 messages.po 的一部分： 1234567891011#: app/email.py:21msgid &quot;[Microblog] Reset Your Password&quot;msgstr &quot;[Microblog] Nueva Contraseña&quot;#: app/forms.py:12 app/forms.py:19 app/forms.py:50msgid &quot;Username&quot;msgstr &quot;Nombre de usuario&quot;#: app/forms.py:13 app/forms.py:21 app/forms.py:43msgid &quot;Password&quot;msgstr &quot;Contraseña&quot; 本章的下載包也包含了這個檔案，所有翻譯都已就位，所以你不必為這個應用擔心這部分。 messages.po 檔案是翻譯的一種源檔案。當你想開始使用這些翻譯文本時，需要將此檔案編譯成一種在應用運行時使用的高效格式。要編譯應用的所有翻譯，可以按以下方式使用 pybabel compile 指令： 123(venv) $ pybabel compile -d app/translationscompiling catalog app/translations/es/LC_MESSAGES/messages.po toapp/translations/es/LC_MESSAGES/messages.mo 這個操作在每個語言儲存庫中的 messages.po 旁邊加入了一個 messages.mo 檔案。.mo 檔案是 Flask-Babel 將用於加載應用翻譯的檔案。 在為西班牙語或你加入到專案中的任何其他語言建立了 messages.mo 檔案後，這些語言就準備好在應用中使用了。如果你想看看應用以西班牙語顯示的樣子，你可以編輯網頁瀏覽器中的語言配置，將西班牙語設為首選語言。對於 Chrome，這在設置頁面的進階部分： 如果你不想更改瀏覽器設置，另一種選擇是通過使 get_locale() 函式始終返回你想使用的語言來強制設置語言。對於西班牙語，你可以這樣做： 12345app/__init__.py: 選擇最佳語言。def get_locale(): ## return request.accept_languages.best_match(app.config['LANGUAGES']) return 'es' 以西班牙語配置瀏覽器運行應用，或 get_locale() 函式返回 es，將使所有文本在使用應用時以西班牙語顯示。 更新翻譯當使用翻譯時，一個常見情況是你可能想要開始使用一個尚未完成的翻譯檔案。這完全沒問題，你可以編譯一個不完整的 messages.po 檔案，任何可用的翻譯將被使用，而任何缺失的翻譯將使用基礎語言。然後你可以繼續進行翻譯，並再次編譯以更新 messages.mo 檔案，隨著你的進展。 另一個常見情況是，當你加入 _() 包裝器時，可能漏掉了一些文本。在這種情況下，你會發現那些你漏掉的文本將保持英文，因為 Flask-Babel 對它們一無所知。在這種情況下，當你發現沒有包裝器的文本時，你會想要加入 _() 或 _l() 包裝器，然後進行更新程式，這包括兩個步驟： 12(venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot .(venv) $ pybabel update -i messages.pot -d app/translations extract 命令與我之前發出的命令相同，但現在它將生成一個新版本的 messages.pot，其中包含所有之前的文本以及你最近使用 _() 或 _l() 包裝的任何新文本。update 命令將新的 messages.pot 檔案合併到與專案關聯的所有 messages.po 檔案中。這將是一個智能合併，其中任何現有文本將保持不變，而僅在 messages.pot 中加入或刪除的條目將受到影響。 更新了 messages.po 之後，你可以繼續翻譯任何新文本，然後再次編譯訊息，使其可供應用程式使用。 翻譯日期和時間現在我有了 Python 程式碼和範本中所有文本的完整西班牙文翻譯，但如果你以西班牙文運行應用程式並且觀察仔細，你會注意到還有一些東西出現在英文中。我指的是由 Flask-Moment 和 moment.js 生成的時間戳，顯然它們沒有被包括在翻譯努力中，因為這些包生成的文本都不是應用程式的原始程式碼或範本的一部分。 moment.js 函式庫確實支援本地化和國際化，所以我需要做的就是配置適當的語言。Flask-Babel 透過 get_locale() 函式為給定請求返回選擇的語言和地區，所以我打算做的是在 before_request 處理器中將地區加入到 g 物件中，這樣我就可以從基礎範本中訪問它： app/routes.py：在 flask.g 中儲存選擇的語言。 12345678910## ...from flask import gfrom flask_babel import get_locale## ...@app.before_requestdef before_request(): ## ... g.locale = str(get_locale()) Flask-Babel 的 get_locale() 函式返回一個地區物件，但我只想要有語言程式碼，可以通過將物件轉換為字串 獲得。現在我有了 g.locale，我可以從基礎範本中訪問它，以配置 moment.js 的正確語言： app/templates/base.html：為 moment.js 設定地區。 123456... {{moment.include_moment() }} {{moment.lang(g.locale) }} &lt;/body&gt;&lt;/html&gt; 現在所有的日期和時間應該以與文本相同的語言出現。以下你可以看到應用程式以西班牙文的樣子： 此時，除了使用者在部落格帖子或個人簡介中提供的文本之外，所有文本都應該可以翻譯成其他語言。 命令行增強你可能會同意我認為 pybabel 命令有點長且難以記住。我將利用這個機會向你展示如何建立與 flask 命令集成的自定義命令。到目前為止，你已經看到我使用 flask run、flask shell 和 Flask-Migrate 擴充功能提供的幾個 flask db 子命令。實際上，向 flask 加入特定於應用程式的命令也很容易。所以我現在要做的是建立一些簡單的命令，觸發特定於此應用程式的所有參數的 pybabel 命令。我要加入的命令是： flask translate init LANG 來加入新語言 flask translate update 來更新所有語言儲存庫 flask translate compile 來編譯所有語言儲存庫 babel export 步驟不會是一個命令，因為生成 messages.pot 檔案總是運行 init 或 update 命令的先決條件，因此這些命令的實現將生成翻譯範本檔案作為臨時檔案。 Flask 依賴於 Click 進行所有命令行操作。像 translate 這樣的命令，是幾個子命令的根，通過 app.cli.group() 裝飾器建立。我將這些命令放在一個名為 app/cli.py 的新模組中： app/cli.py：翻譯命令組。 123456from app import app@app.cli.group()def translate(): &quot;&quot;&quot;翻譯和本地化命令。&quot;&quot;&quot; pass 命令的名稱來自被裝飾的函式，幫助訊息來自文件字串。由於這是一個僅用於為子命令提供基礎的父命令，該函式本身不需要做任何事情。 update 和 compile 實現起來很簡單，因為它們不需要任何參數： app/cli.py：更新和編譯子命令。 123456789101112131415161718import os## ...@translate.command()def update(): &quot;&quot;&quot;更新所有語言。&quot;&quot;&quot; if os.system('pybabel extract -F babel.cfg -k _l -o messages.pot .'): raise RuntimeError('extract 命令失敗') if os.system('pybabel update -i messages.pot -d app/translations'): raise RuntimeError('update 命令失敗') os.remove('messages.pot')@translate.command()def compile(): &quot;&quot;&quot;編譯所有語言。&quot;&quot;&quot; if os.system('pybabel compile -d app/translations'): raise RuntimeError('compile 命令失敗') 注意函式裝飾器的來源請注意這些函式的裝飾器是來自 translate 父函式。這可能看起來令人困惑，因為 translate() 是一個函式，但這是 Click 構建命令群組的標準方式。與 translate() 函式一樣，這些函式的文件字串用作 –help 輸出中的幫助訊息。 你可以看到對於所有命令，我執行它們並確保返回值是零，這意味著命令沒有返回任何錯誤。如果命令出錯，那麼我將引發 RuntimeError，這將導致腳本停止。update() 函式將 extract 和 update 步驟結合在同一個命令中，如果一切成功，它會在更新完成後刪除 messages.pot 檔案，因為這個檔案在需要時可以輕鬆重新生成。 初始化命令init 命令以新語言程式碼為參數。實現如下： app/cli.py：Init 子命令。 123456789101112import click@translate.command()@click.argument('lang')def init(lang): &quot;&quot;&quot;初始化一種新語言。&quot;&quot;&quot; if os.system('pybabel extract -F babel.cfg -k _l -o messages.pot .'): raise RuntimeError('extract 命令失敗') if os.system( 'pybabel init -i messages.pot -d app/translations -l' + lang): raise RuntimeError('init 命令失敗') os.remove('messages.pot') 這個命令使用 @click.argument 裝飾器來定義語言程式碼。Click 將命令中提供的值作為參數傳遞給處理函式，然後我將該參數納入 init 命令中。 啟用這些命令的最後一步要讓這些命令工作的最後一步是導入它們，以便命令得到註冊。我決定在頂層目錄的 microblog.py 檔案中這樣做： microblog.py：註冊命令行命令。 1from app import cli 在這裡，我需要做的就是導入新的 cli.py 模組，無需進行任何操作，因為導入會使命令裝飾器運行並註冊每個命令。 此時，運行 flask –help 將列出 translate 命令作為一個選項。而 flask translate –help 將顯示我定義的三個子命令： 123456789101112(venv) $ flask translate --help用法：flask translate [選項] 命令 [參數]... 翻譯和本地化命令。選項： --help 顯示此訊息並退出。命令： compile 編譯所有語言。 init 初始化一種新語言。 update 更新所有語言。 所以現在，工作流程更簡單了，不需要記住長而複雜的命令。要加入新語言，你使用： 1(venv) $ flask translate init &lt; 語言程式碼 &gt; 在對 _() 和 _l() 語言標記進行更改後更新所有語言： 1(venv) $ flask translate update 在更新翻譯檔案後編譯所有 語言： 1(venv) $ flask translate compile","link":"/python/flask-mega-tutorial/chapter_13_i18n_and_l10n.html"},{"title":"","text":"目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs）","link":"/python/flask-mega-tutorial/chapter_16_full_text_search.html"},{"title":"Chapter 15: A Better Application Structure","text":"Posted by on Miguel Grinberg 這是 Flask 大型教學系列的第十五部分，在這裡我將使用適合更大型應用程式的風格來重構應用程式。 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 Microblog 已經是一個相當大的應用程式，所以我認為這是討論 Flask 應用程式如何在不變得混亂或太難管理的情況下成長的好機會。Flask 是一個旨在讓你以任何你想要的方式組織你的專案的框架，作為這種哲學的一部分，它使得當應用程式變得更大，或者你的需求或經驗水平變化時，改變或適應應用程式結構成為可能。 在這一章中，我將討論一些適用於大型應用程式的模式，並為了展示它們，我將對我的 Microblog 專案的結構進行一些改變，目的是使程式碼更容易維護和更好地組織。但當然，保持著真正的 Flask 精神，我鼓勵你將這些改變僅作為一個建議，當你試圖決定如何組織你自己的專案時。 這一章的 GitHub 連結是：Browse Zip Diff 當前的限制應用程式目前狀態存在兩個基本問題。如果你看看應用程式的結構，你會注意到有幾個不同的子系統可以被識別，但支持它們的程式碼都混雜在一起，沒有任何明確的界限。讓我們回顧一下這些子系統是什麼： 使用者認證子系統，包括一些在 app/routes.py 中的視圖函式、一些在 app/forms.py 中的表單、一些在 app/templates 中的範本和在 app/email.py 中的電子郵件支持。 錯誤子系統，定義了在 app/errors.py 中的錯誤處理器和在 app/templates 中的範本。 核心應用程式功能，包括顯示和撰寫部落格帖子、使用者個人資料和追蹤，以及部落格帖子的即時翻譯，這些功能散布在大部分的應用程式模組和範本中。 考慮到我已經識別的這三個子系統以及它們的結構，你可能會注意到一個模式。到目前為止，我所遵循的組織邏輯是基於有不同應用程式功能的專用模組。有一個模組是為視圖函式，另一個是為網頁表單，一個 是錯誤，一個是電子郵件，一個目錄是 HTML 範本，等等。雖然這是一個對於小型專案有意義的結構，但一旦一個專案開始成長，它傾向於使這些模組變得非常大和混亂。 一個清楚看到問題的方式是考慮如何通過從這個專案中盡可能多地重用來開始第二個專案。例如，使用者認證部分應該在其他應用程式中運作良好，但如果你想要如實使用那些程式碼，你將不得不進入幾個模組，並將相關部分複製 / 貼上到新專案中的新檔案中。看看這有多不方便？如果這個專案將所有與認證相關的檔案與應用程式的其餘部分分開，不是更好嗎？Flask 的藍圖功能有助於實現更實用的組織，使程式碼重用變得更容易。 還有第二個問題不那麼明顯。Flask 應用程式實例是作為全局變數在 app/init.py 中建立的，然後由許多應用程式模組導入。雖然這本身並不是問題，但將應用程式作為全局變數可能會使某些情況變得複雜，尤其是與測試相關的情況。想像你想要在不同配置下測試這個應用程式。因為應用程式被定義為全局變數，真的沒有辦法實例化兩個使用不同配置變數的應用程式。另一個不理想的情況是所有測試都使用相同的應用程式，所以一個測試可能會對應用程式進行更改，從而影響稍後運行的另一個測試。理想情況下，你希望所有測試都在原始的應用程式實例上運行。 藍圖在 Flask 中，藍圖是代表應用程式子集的邏輯結構。一個藍圖可以包括路由、視圖函式、表單、範本和靜態檔案等元素。如果你在一個單獨的 Python 套件中撰寫你的藍圖，那麼你就有了一個封裝與應用程式特定功能相關元素的元件。 藍圖的內容最初處於休眠狀態。為了啟動這些元素，需要將藍圖註冊到應用程式。在註冊期間，加入到藍圖的所有元素都被傳遞到應用程式。因此，你可以將藍圖視為暫時儲存應用程式功能的工具，有助於組織你的程式碼。 錯誤處理藍圖我建立的第一個藍圖是封裝錯誤處理器支持的藍圖。這個藍圖的結構如下： 123456789app/ errors/ &lt;-- 藍圖套件 __init__.py &lt;-- 藍圖建立 handlers.py &lt;-- 錯誤處理器 templates/ errors/ &lt;-- 錯誤範本 404.html 500.html __init__.py &lt;-- 藍圖註冊 本質上，我所做的是將 app/errors.py 模組移至 app/errors/handlers.py， 並將兩個錯誤範本移至 app/templates/errors，以便將它們與其他範本分離。我還必須更改兩個錯誤處理器中的 render_template() 調用，以使用新的錯誤範本子目錄。之後，我在 app/errors/init.py 模組中加入了藍圖建立，並在應用程式實例建立後，將藍圖註冊到 app/init.py。 我應該指出，Flask 藍圖可以配置為擁有單獨的範本或靜態檔案目錄。我決定將範本移到應用程式的範本目錄的子目錄中，這樣所有範本都在單一層級結構中，但如果你更喜歡將屬於藍圖的範本儲存在藍圖套件內，這也是支援的。例如，如果你在 Blueprint() 建構子中加入了 template_folder='templates' 參數，那麼你可以將藍圖的範本儲存在 app/errors/templates 中。 藍圖的建立與應用程式的建立相當相似。這在藍圖套件的 _init.py 模組中完成： 1234567app/errors/__init__.py: 錯誤藍圖。from flask import Blueprintbp = Blueprint('errors', __name__)from app.errors import handlers Blueprint 類別需要藍圖的名稱、基礎模組的名稱（通常設置為 __name__，就像 Flask 應用程式實例一樣），以及一些可選參數，在這種情況下我不需要。在建立藍圖物件後，我導入了 handlers.py 模組，以便將其中的錯誤處理器註冊到藍圖。這個導入放在底部是為了避免循環依賴。 在 handlers.py 模組中，我使用藍圖的 @bp.app_errorhandler 裝飾器來附加錯誤處理器，而不是使用應用程式的 @app.errorhandler 裝飾器。雖然這兩個裝飾器達到相同的最終結果，但目標是嘗試使藍圖獨立於應用程式，使其更具可移植性。我還需要修改兩個錯誤範本的路徑，以適應新的錯誤子目錄。 完成錯誤處理器重構的最後一步是將藍圖註冊到應用程式： 123456789101112app/__init__.py: 將錯誤藍圖註冊到應用程式。app = Flask(__name__)## ...from app.errors import bp as errors_bpapp.register_blueprint(errors_bp)## ...from app import routes, models ## &lt;-- 從這個導入中移除 errors！ 要註冊藍圖，使用 Flask 應用程式實例的 register_blueprint() 方法。當藍圖被註冊後，任何視圖函式、範本、靜態檔案、錯誤處理器等都會連接到應用程式。我將藍圖的導入放在 app.register_blueprint() 上方，以避免循環依賴問題。 身份驗證藍圖將應用程式的身份驗證功能重構為藍圖的過程與錯誤處理器相當類似。以下是重構後藍圖的結構圖： 12345678910111213app/ auth/ &lt;-- 藍圖套件 __init__.py &lt;-- 藍圖建立 email.py &lt;-- 身份驗證郵件 forms.py &lt;-- 身份驗證表單 routes.py &lt;-- 身份驗證路由 templates/ auth/ &lt;-- 藍圖範本 login.html register.html reset_password_request.html reset_password.html __init__.py &lt;-- 藍圖註冊 要建立這個藍圖，我必須將所有與身份驗證相關的功能移至藍圖中我建立的新模組。這包括一些視圖函式、網頁表單和支援函式，例如通過電子郵件發送密碼重設令牌的函式。我還將範本移至子目錄中，與應用程式的其餘部分分離，就像我對錯誤頁面所做的那樣。 在藍圖中定義路由時，使用 @bp.route 裝飾器，而不是 @app.route。還需要更改 url_for() 構建 URL 的語法。對於直接附加到應用程式的常規視圖函式，url_for() 的第一個參數是視圖函式名稱。當在藍圖中定義路由時，此參數必須包括藍圖名稱和視圖函式名稱，用句點分隔。例如，我必須將所有 url_for('login') 的出現替換為 url_for('auth.login')，其餘視圖函式也是如此。 要將 auth 藍圖與應用程式註冊，我使用了稍微不同的格式： 123456app/__init__.py: 將身份驗證藍圖註冊到應用程式。## ...from app.auth import bp as auth_bpapp.register_blueprint(auth_bp, url_prefix='/auth')## ... 這種情況下的 register_blueprint() 調用有一個額外的參數，url_prefix。這是完全可選的，但 Flask 給你選擇在 URL 前綴下附加藍圖的選項，因此藍圖中定義的任何路由都會在其 URL 中獲得此前綴。在許多情況下， 這作為一種「命名空間」很有用，它將藍圖中的所有路由與應用程式或其他藍圖中的其他路由分開。對於身份驗證，我認為讓所有路由以 /auth 開頭很好，所以我加入了前綴。所以現在登錄 URL 將是 http://localhost:5000/auth/login。因為我使用 url_for() 生成 URL，所以所有 URL 都將自動包含前綴。 主應用程式藍圖第三個藍圖包含核心應用程式邏輯。重構這個藍圖的過程與前兩個藍圖相同。我給這個藍圖命名為 main，所以所有引用視圖函式的 url_for() 調用都必須加上 main. 前綴。鑑於這是應用程式的核心功能，我決定將範本保留在原來的位置。這不是問題，因為我已將其他兩個藍圖的範本移至子目錄中。 應用程式工廠模式正如我在本章引言中提到的，將應用程式作為全域變數引入了一些複雜性，主要是對某些測試場景的限制。在我引入藍圖之前，應用程式必須是一個全域變數，因為所有視圖函式和錯誤處理器都需要用來自 app 的裝飾器進行裝飾，例如 @app.route。但現在所有路由和錯誤處理器都移至藍圖，將應用程式保持為全域的理由就少了很多。 因此，我將要做的是加入一個名為 create_app() 的函式，用於構建 Flask 應用程式實例，並消除全域變數。這次轉換並非微不足道，我必須解決一些複雜問題，但讓我們先看看應用程式工廠函式： app/init.py: Application factory function. 123456789101112131415161718192021222324252627## ...db = SQLAlchemy()migrate = Migrate()login = LoginManager()login.login_view = 'auth.login'login.login_message = _l('Please log in to access this page.')mail = Mail()moment = Moment()babel = Babel()def create_app(config_class=Config): app = Flask(__name__) app.config.from_object(config_class) db.init_app(app) migrate.init_app(app, db) login.init_app(app) mail.init_app(app) moment.init_app(app) babel.init_app(app) ## ... no changes to blueprint registration if not app.debug and not app.testing: ## ... no changes to logging setup return app 你已經看到，大多數 Flask 擴充套件是通過建立擴充套件的實例並將應用程式作為參數傳遞來初始化的。當應用程式不作為全域變數存在時，有一種替代模式，即擴充套件通過兩階段初始化。首先在全域範圍內建立擴充套件實例，如同以前一樣，但不傳遞任何參數。這建立了一個未附加到應用程式的擴充套件實例。在工廠函式中建立應用程式實例時，必須對擴充套件實例調用 init_app() 方法，以便將其綁定到現在已知的應用程式。 在初始化期間執行的其他任務保持不變，但移至工廠函式而不是在全域範圍內。這包括藍圖的註冊和日誌配置。請注意，我在決定是否啟用電子郵件和檔案日誌的條件中加入了一個 not app.testing 子句，以便在單元測試期間跳過所有這些日誌。當執行單元測試時，app.testing 標誌將為 True，因為在配置中設置了 TESTING 變數為 True。 那麼誰來調用應用程式工廠函式？使用這個函式的顯而易見的地方是頂層的 microblog.py 腳本，這是應用程式現在存在於全域範圍的唯一模組。另一個地方是在 tests.py 中，我將在下一節中更詳細地討論單元測試。 正如我上面提到的，隨著藍圖的引入，大多數對 app 的引用都消失了，但在程式碼中仍然有一些我必須處理的。例如，app/models.py、app/translate.py 和 app/main/routes.py 模組都有對 app.config 的引用。幸運的是，Flask 開發者試圖使視圖函式易於訪問應用程式實例，而不必像我到現在為止一直在做的那樣導入它。Flask 提供的 current_app 變數是一個特殊的「上下文」變數，Flask 在分發請求之前用應用程式初始化它。你之前已經看到了另一個上下文變數，即我用來儲存當前語境的 g 變數。這兩個，以及 Flask-Login 的 current_user 和一些你還沒見過的其他變數，是有些「魔法」的變數，它們像全域變數一樣工作，但只能在處理請求期間和處理它的線程中訪問。 用 Flask 的 current_app 變數替換 app 消除了將應用程式實例作為全域變數導入的需求。我能夠毫無困難地通過簡單的搜索和替換將所有對 app.config 的引用改為 current_app.config。 app/email.py 模組提出了一個稍微大一點的挑戰，所以我不得不使用一個小技巧： 1234567891011121314app/email.py: 將應用程式實例傳遞給另一個線程。from flask import current_appdef send_async_email(app, msg): with app.app_context(): mail.send(msg)def send_email(subject, sender, recipients, text_body, html_body): msg = Message(subject, sender=sender, recipients=recipients) msg.body = text_body msg.html = html_body Thread(target=send_async_email, args=(current_app._get_current_object(), msg)).start() 在 send_email() 函式中，應用程式實例作為參數傳遞給一個背景線程，然後該線程將在不阻塞主應用程式的情況下發送電子郵件。在作為背景線程運行的 send_async_email() 函式中直接使用 current_app 是不行的，因為 current_app 是一個與處理客戶端請求的線程綁定的上下文感知變數。在不同的線程中，current_app 將沒有分配值。將 current_app 直接作為參數傳遞給線程對象也是不行的，因為 current_app 實際上是一個動態映射到應用程式實例的代理物件。因此，傳遞代理物件將與在線程中直接使用 current_app 相同。我需要做的是訪問存儲在代理物件內部的真實應用程式實例，並將其作為 app 參數傳遞。current_app._get_current_object() 表達式從代理物件內部提取實際的應用程式實例，所以這就是我傳遞給線程的參數。 另一個棘手的模組是 app/cli.py，它實現了一些用於管理語言翻譯的捷徑命令，並使用了 @app.cli.group() 裝飾器。在這種情況下，用 current_app 替換 app 是不行的，因為這些命令是在啟動時註冊的，而不是在處理請求期間，這是唯一可以使用 current_app 的時候。為了在這個模組中移除對 app 的引用，我建立了另一個藍圖： 1234567891011121314151617181920212223242526272829app/cli.py: 自定義應用程式命令的藍圖。import osfrom flask import Blueprintimport clickbp = Blueprint('cli', __name__, cli_group=None)@bp.cli.group()def translate(): &quot;&quot;&quot;翻譯和本地化命令。&quot;&quot;&quot; pass@translate.command()@click.argument('lang')def init(lang): &quot;&quot;&quot;初始化新語言。&quot;&quot;&quot; ## ...@translate.command()def update(): &quot;&quot;&quot;更新所有語言。&quot;&quot;&quot; ## ...@translate.command()def compile(): &quot;&quot;&quot;編譯所有語言。&quot;&quot;&quot; ## ... Flask 預設將附加到藍圖的命令放在以藍圖名稱為名的分組下。這會導致這些命令可以透過 flask cli translate ... 的方式使用。為了避免額外的 cli 分組，藍圖中設定了 cli_group=None。 然後，我在應用程式工廠函式中註冊這個 cli 藍圖： 1234567891011app/__init__.py: 應用程式工廠函式。## ...def create_app(config_class=Config): ## ... from app.cli import bp as cli_bp app.register_blueprint(cli_bp) ## ... return app 單元測試的改進正如我在本章開頭所暗示的，我到目前為止所做的工作目標是改善單元測試的工作流程。當你運行單元測試時，你希望確保應用程式以不干擾你的開發資源（例如你的資料庫）的方式進行配置。 目前版本的 tests.py 依靠在應用程式實例上應用配置之後修改配置的技巧，這是一種危險的做法，因為並非所有類型的更改在那麼晚的時候都有效。我想要的是在配置加入到應用程式之前有機會指定我的測試配置。 現在的 create_app() 函式接受一個配置類作為參數。預設情況下使用 config.py 中定義的 Config 類，但現在我可以通過向工廠函式傳遞一個新類來建立使用不同配置的應用程式實例。以下是一個適合用於我的單元測試的配置類範例： 1234567tests.py: 測試配置。from config import Configclass TestConfig(Config): TESTING = True SQLALCHEMY_DATABASE_URI = 'sqlite://' 這裡我所做的是建立應用程式的 Config 類的子類，並覆寫 SQLAlchemy 配置以使用內存中的 SQLite 資料庫。我還加入了設置為 True 的 TESTING 屬性，這在應用程式需要確定它是否在單元測試下運行時很有用。 如果你還記得，我的單元測試依賴於 setUp() 和 tearDown() 方法，這些方法由單元測試框架自動調用，以建立和銷毀每個測試運行所需的環境。現在我可以使用這兩個方法來為每個測試建立和銷毀一個全新的應用程式： 12345678910111213tests.py: 為每個測試建立一個應用程式。class UserModelCase(unittest.TestCase): def setUp(self): self.app = create_app(TestConfig) self.app_context = self.app.app_context() self.app_context.push() db.create_all() def tearDown(self): db.session.remove() db.drop_all() self.app_context.pop() 新的應用程式將存儲在 `self.app ` 中，並且像以前一樣，從中建立了一個應用程式上下文，但這是什麼呢？ 記得 current_app 變數嗎？當沒有全域應用程式可以導入時，它以某種方式作為應用程式的代理。這個變數知道應用程式實例，因為它查找在當前線程中推送的應用程式上下文。如果它找到一個，就從中獲得應用程式實例。如果沒有上下文，則無法知道哪個應用程式是活躍的，所以 current_app 會引發異常。以下是在 Python 控制台中這是如何工作的範例。這需要通過運行 python 啟動的控制台，因為 flask shell 命令為方便起見自動激活了一個應用程式上下文。 1234567891011&gt;&gt;&gt; from flask import current_app&gt;&gt;&gt; current_app.config['SQLALCHEMY_DATABASE_URI']Traceback (most recent call last): ...RuntimeError: Working outside of application context.&gt;&gt;&gt; from app import create_app&gt;&gt;&gt; app = create_app()&gt;&gt;&gt; app.app_context().push()&gt;&gt;&gt; current_app.config['SQLALCHEMY_DATABASE_URI']'sqlite:////home/miguel/microblog/app.db' 這就是秘密！在調用你的視圖函式之前，Flask 推送了一個應用程式上下文，從而使 current_app 和 g 活躍起來。當請求完成時，上下文被移除，以及這些變數。為了使 setUp() 方法中的 db.create_all() 調用有效，必須為應用程式實例推送一個應用程式上下文，這樣 db.create_all() 就可以使用 current_app.config 來知道資料庫的位置。然後在 tearDown() 方法中我彈出上下文，將一切重置為乾淨狀態。 你還應該知道，應用程式上下文是 Flask 使用的兩種上下文之一。還有一個是請求上下文，它更具體，因為它適用於一個請求。當一個請求上下文在處理請求之前被激活時，Flask 的 request 和 session 變數變得可用，以及 Flask-Login 的 current_user。 環境變數正如你在建立這個應用程式時所見，有許多配置選項依賴於在啟動伺服器之前在你的環境中設置變數。這包括你的密鑰、電子郵件伺服器資訊、資料庫 URL 和 Microsoft Translator API 金鑰。你可能會同意這是不便的，因為每次你打開一個新的終端會話時，這些變數都需要再次設置。 依賴大量環境變數的應用程式通常將這些變數儲存在根應用程式目錄的 .env 檔案中。當應用程式啟動時，它會導入此檔案中的變數，這樣就無需手動設置所有這些變數。 有一個支援 .env 檔案的 Python 套件叫作 python-dotenv，它已經安裝了，因為我在 .flaskenv 檔案中使用了它。雖然 .env 和 .flaskenv 檔案相似，但 Flask 預期 Flask 自己的配置變數放在 .flaskenv 中，而應用程式配置變數（包括一些可能屬於敏感性質的變數）則放在 .env 中。.flaskenv 檔案可以加入到你的原始碼控制中，因為它不包含任何秘密或密碼。.env 檔案則不應加入原始碼控制，以確保你的秘密受到保護。 flask 命令會自動將定義在 .flaskenv 和 .env 檔案中的任何變數導入環境。對於 .flaskenv 檔案來說，這足夠了，因為它的內容僅在通過 flask 命令運行應用程式時需要。然而，.env 檔案還將在這個應用程式的生產部署中使用，這不會使用 flask 命令。出於這個原因，明確導入 .env 檔案的內容是個好主意。 由於 config.py 模組是我讀取所有環境變數的地方，我將在建立 Config 類之前導入 .env 檔案，以便在類構建時變數已經設置好： 12345678910config.py: 導入帶有環境變數的 .env 檔案。import osfrom dotenv import load_dotenvbasedir = os.path.abspath(os.path.dirname(__file__))load_dotenv(os.path.join(basedir, '.env'))class Config(object): ## ... 所以現在你可以建立一個 .env 檔案，其中包含應用程式所需的所有環境變數。重要的是，不要將你的 .env 檔案加入原始碼控制。你不會希望包含密碼和其他敏感資訊的檔案被包含在你的原始碼庫中。 .env 檔案可用於所有配置時變數，但不能用於 Flask 的 FLASK_APP 和 FLASK_DEBUG 環境變數，因為這些在應用程式啟動過程的非常早期就需要了，早於應用程式實例及其配置物件的存在。 以下範例顯示了一個定義秘密鑰匙、配置郵件在本地運行的郵件伺服器上的 8025 端口且無需認證、設置 Microsoft Translator API 金鑰，並讓資料庫配置使用預設值的 .env 檔案： 1234SECRET_KEY=a-really-long-and-unique-key-that-nobody-knowsMAIL_SERVER=localhostMAIL_PORT=8025MS_TRANSLATOR_KEY=&lt;your-translator-key-here&gt; 需求檔案此時，我已經在 Python 虛擬環境中安裝了相當多的套件。如果你需要在另一台機器上重新生成你的環境，你將會有記住安裝了哪些套件的困難，因此普遍接受的做法是在項目的根文件夾中寫一個 requirements.txt 檔案，列出所有依賴項及其版本。製作這個列表實際上很容易： 1(venv) $ pip freeze &gt; requirements.txt pip freeze 命令會以 requirements.txt 檔案所需的正確格式將安裝在你虛擬環境中的所有套件傾印出來。現在，如果你需要在另一台機器上建立相同的虛擬環境，而不是一個一個安裝套件，你可以運行： 1(venv) $ pip install -r requirements.txt","link":"/python/flask-mega-tutorial/chapter_15_a_better_application_structure.html"},{"title":"","text":"目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） Flask 大型教程，第十七部分：在 Linux 上部署這是 Flask 大型教程系列的第十七篇文章，在這篇文章中，我將會將 Microblog 部署到一台 Linux 伺服器上。 在這個章節中，我達到了我的 Microblog 應用程式生命週期中的一個里程碑，因為我將討論將應用程式部署到生產伺服器上的方式，使其可以被真實用戶訪問。 部署的主題是廣泛的，因此不可能在這裡涵蓋所有可能的選項。這一章節致力於探索傳統的主機選項，作為主題，我將使用運行 Ubuntu 的專用 Linux 伺服器，以及廣受歡迎的 Raspberry Pi 迷你電腦。我將在後續章節中涵蓋其他選項，如雲端和容器部署。 這個章節的 GitHub 連結是：瀏覽、Zip、Diff。 傳統主機當我提到「傳統主機」時，我的意思是應用程式是手動或通過腳本安裝程式在一台標準伺服器機器上安裝。這個過程涉及安裝應用程式、它的依賴項以及一個生產規模的網頁伺服器，並配置系統以使其安全。 當你準備部署自己的專案時，你需要問的第一個問題是在哪裡可以找到一台伺服器。如今，有許多經濟型主機服務。例如，每月 5 美元，Digital Ocean、Linode 或 Amazon Lightsail 將租用一台虛擬化的 Linux 伺服器給你來進行部署實驗（Linode 和 Digital Ocean 提供的入門級伺服器配備了 1GB 的 RAM，而 Amazon 僅提供 512MB）。如果你希望在不花錢的情況下練習部署，那麼 Vagrant 和 VirtualBox 是兩個結合使用可以在你自己的電腦上建立與付費伺服器類似的虛擬伺服器的工具。 就作業系統選擇而言，從技術角度來看，這個應用程式可以部署在任何主要作業系統上，這包括大量開源的 Linux 和 BSD 發行版，以及商業的 macOS 和 Microsoft Windows（macOS 是一個混合的開源/商業選項，因為它是基於 Darwin 的，Darwin 是一個開源的 BSD 衍生物）。 由於 macOS 和 Windows 是桌面作業系統，不是優化用來作為伺服器的，我將把它們作為候選項排除在外。在 Linux 或 BSD 作業系統之間的選擇大多基於偏好，所以我將選擇兩者中最受歡迎的，即 Linux。就 Linux 發行版而言，我再次根據受歡迎程度進行選擇，選擇 Ubuntu。 建立一個 Ubuntu 伺服器如果你有興趣跟著我一起進行這次部署，你顯然需要一台伺服器來操作。我將為你推薦兩個獲取伺服器的選項，一個付費，一個免費。如果你願意花一點錢，你可以在 Digital Ocean、Linode 或 Amazon Lightsail 開設一個帳戶，並建立一個帶有當前長期支援（LTS）版本的 Ubuntu 虛擬伺服器，寫這篇文章時是 22.04。你應該使用最小的伺服器選項，那個大約每月 5 美元。成本按照你擁有伺服器的小時數來按比例計算，所以如果你建立了伺服器，玩了幾個小時然後刪除它，你將只需支付幾分錢。 免費的替代方案是基於一個你可以在自己的電腦上運行的虛擬機。使用這個選項，請在你的機器上安裝 Vagrant 和 VirtualBox，然後建立一個名為 Vagrantfile 的檔案來描述你的 VM 規格，內容如下： Vagrantfile: Vagrant 配置。 1234567Vagrant.configure(&quot;2&quot;) do |config| config.vm.box = &quot;ubuntu/jammy64&quot; config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot; config.vm.provider &quot;virtualbox&quot; do |vb| vb.memory = &quot;2048&quot; endend 這個檔案配置了一個帶有 2GB RAM 的 Ubuntu 22.04 伺服器，你將能夠從主機電腦在 IP 地址 192.168.56.10 訪問它。要建立伺服器，運行以下命令： 1$ vagrant up 諮詢 Vagrant 命令列文件以了解管理你的虛擬伺服器的其他選項。 使用 SSH 客戶端你的伺服器是無頭的，所以你不會像你自己的電腦上那樣有一個桌面。你將通過 SSH 客戶端連接到你的伺服器，並通過命令列在其上工作。如果你使用 Linux 或 Mac OS X，你可能已經安裝了 OpenSSH。如果你使用 Microsoft Windows，Cygwin、Git 和 Windows 子系統為 Linux 提供了 OpenSSH，所以你可以安裝這些選項中的任何一個。 當使用來自第三方提供商的虛擬伺服器時，你會得到一個 IP 地址。你可以用以下命令打開一個終端會話與你全新的伺服器： 1$ ssh root@&lt;server-ip-address&gt; 你將被提示輸入一個密碼。根據服務，密碼可能已經自動生成並在你建立伺服器後顯示給你，或者你可能有選擇你自己的密碼的選項。 如果你使用 Vagrant VM，你可以使用命令打開一個終端會話： 1$ vagrant ssh 如果你使用 Windows 並有一個 Vagrant VM，請注意你需要從可以調用 OpenSSH 的 ssh 命令的 shell 運行上述命令，所以它可能是一 個 bash 或類似提示符，而不是一個原生 Windows 終端。 無密碼登錄如果你使用 Vagrant VM，你可以跳過這一節，因為你的 VM 已經由 Vagrant 自動配置為使用一個名為 vagrant 或 ubuntu 的非 root 帳戶，而且自動沒有密碼。 當使用虛擬伺服器時，建議你建立一個常規用戶帳戶來進行你的部署工作，並配置這個帳戶以便在不使用密碼的情況下登錄你，這一開始可能看起來是一個壞主意，但你會看到它不僅更方便，而且更安全。 我將建立一個名為 ubuntu 的用戶帳戶（如果你喜歡，你可以使用不同的名字）。要建立這個用戶帳戶，使用上一節的 ssh 指令登錄到你的伺服器的 root 帳戶，然後輸入以下命令來建立用戶，給它 sudo 權限，最後切換到它： 123$ adduser --gecos &quot;&quot; ubuntu$ usermod -aG sudo ubuntu$ su ubuntu 現在我將配置這個新的 ubuntu 帳戶使用公鑰認證，這樣你就可以在不需要輸入密碼的情況下登錄。 暫時離開你在伺服器上打開的終端會話，並在你自己的機器上啟動第二個終端。如果你使用 Windows，這需要是你可以訪問 ssh 命令的終端，所以它可能是一個 bash 或類似提示符，而不是原生 Windows 終端。在那個終端會話中，檢查 ~/.ssh 目錄的內容： 12$ ls ~/.sshid_rsa id_rsa.pub 如果目錄列表顯示了名為 id_rsa 和 id_rsa.pub 的檔案，那麼你已經有一個鑰匙了。如果你沒有這兩個檔案，或者你根本沒有 ~/.ssh 目錄，那麼你需要通過運行以下命令來建立你的 SSH 鑰匙對，這也是 OpenSSH 工具集的一部分： 1$ ssh-keygen 這個應用程式將提示你輸入一些東西，對於這些提示我建議你接受預設值，通過按 Enter 鍵在所有提示上。如果你知道你在做什麼並想要做其他事情，你當然可以。 這個命令運行後，你應該有了上面列出的兩個檔案。id_rsa.pub 檔案是你的公鑰，這是一個你將提供給第三方作為識別你的方式的檔案。id_rsa 檔案是你的私鑰，不應該與任何人分享。 你現在需要配置你的公鑰作為你伺服器上的授權主機。在你自己的電腦上打開的終端上，將你的公鑰打印到螢幕上： 1234$ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCjw....F8Xv4f/0+7WT miguel@miguelspc 這將是一個非常長的字符序列，可能跨越多行。你需要將這些數據複製到剪貼板，然後切換回你遠程伺服器上的終端，然後發出這些命令來儲存公鑰： 12$ echo &lt;paste-your-key-here&gt; &gt;&gt; ~/.ssh/authorized_keys$ chmod 600 ~/.ssh/authorized_keys 無密碼登錄現在應該在工作了。這個想法是你的機器上的 ssh 將通過執行需要私鑰的加密操作來識別自己給伺服器。然後伺服器使用你的公鑰驗證操作是否有效。 你現在可以登出你的 ubuntu 會話，然後從你的 root 會話登出，然後嘗試直接使用以下命令登錄到 ubuntu 帳戶： 1$ ssh ubuntu@&lt;server-ip-address&gt; 這次你不應該需要輸入密碼！ 保護你的伺服器為了最小化你的伺服器被攻破的風險，你可以採取一些步驟，針對關閉攻擊者可能通過它們獲取訪問的潛在門戶。 我將進行的第一個更改是禁用通過 SSH 的 root 登錄。你現在可以無密碼訪問 ubuntu 帳戶，並可以通過 sudo 從這個帳戶運行管理員命令，所以真的沒有必要暴露 root 帳戶。要禁用 root 登錄，你需要編輯你伺服器上的 /etc/ssh/sshd_config 檔案。你的伺服器可能已經安裝了 vi 和 nano 文本編輯器，你可以使用它們來編輯檔案（如果你不熟悉它們中的任何一個，先試試 nano）。你需要在編輯器前加上 sudo，因為 SSH 配置對普通用戶不可訪問（即 sudo vi /etc/ssh/sshd_config）。你需要在這個檔案中更改單行： /etc/ssh/sshd_config: 禁用 root 登錄。 1PermitRootLogin no 注意要進行這個更改，你需要找到以 PermitRootLogin 開頭的行，並將值更改為 no，無論你的伺服器上的值是什麼。 下一個更改也在同一個檔案中。現在我將禁用所有帳戶的密碼登錄。你已經設置了無密碼登錄，所以完全沒有必要允許密碼。如果你對完全禁用密碼感到緊張，你可以跳過這個更改，但對於生產伺服器來說，這是一個好主意，因為攻擊者不斷嘗試在所有伺服器上隨機帳戶名和密碼，希望能夠幸運。要禁用密碼登錄，在 /etc/ssh/sshd_config 中更改以下行： /etc/ssh/sshd_config: 禁用密碼登錄。 1PasswordAuthentication no 在你完成編輯 SSH 配置後，需要重新啟動服務以使更改生效 ： 1$ sudo service ssh restart 我將進行的第三個更改是安裝一個防火牆。這是一個軟體，它阻止在沒有明確啟用的端口上訪問伺服器： 123456$ sudo apt-get install -y ufw$ sudo ufw allow ssh$ sudo ufw allow http$ sudo ufw allow 443/tcp$ sudo ufw --force enable$ sudo ufw status 這些命令安裝 ufw，即 Uncomplicated Firewall，並將其配置為僅允許在端口 22（ssh）、80（http）和 443（https）上的外部流量。任何其他端口都不會被允許。 安裝基本依賴如果你遵循我的建議並用 Ubuntu 20.04 版本配置了你的伺服器，那麼你有一個系統，它完全支援 Python 3.8，所以這是我將用於部署的版本。 基本的 Python 解釋器可能已經預裝在你的伺服器上，但可能有一些額外的包還沒有，還有一些其他的包在 Python 之外將在建立一個健壯的、準備就緒的生產部署中很有用。對於數據庫伺服器，我將從 SQLite 切換到 MySQL。postfix 包是一個郵件傳輸代理，我將用它來發送郵件。supervisor 工具將監控 Flask 伺服器進程，並在它崩潰時自動重啟它，或者也在伺服器重啟時。nginx 伺服器將接受來自外部世界的所有請求，並將它們轉發給應用程式。最後，我將使用 git 作為我的工具選擇，直接從其 git 儲存庫下載應用程式。 123$ sudo apt-get -y update$ sudo apt-get -y install python3 python3-venv python3-dev$ sudo apt-get -y install mysql-server postfix supervisor nginx git 這些安裝大多是無人值守的。根據你安裝的 Ubuntu 版本，你可能會收到一個提示，要求重新啟動服務，你可以接受預設選擇。當你運行第三個安裝語句時，你將被問到一些關於 postfix 包安裝的問題，你也可以接受它們的預設答案。 注意對於這次部署，我選擇不安裝 Elasticsearch。這個服務需要大量的 RAM，所以只有當你有一個大於 2GB RAM 的大伺服器時才可行。為了避免伺服器內存不足的問題，我將留出搜索功能。如果你有一個足夠大的伺服器，你可以從 Elasticsearch 網站下載官方 .deb 包，並按照他們的安裝指南將其添加到你的伺服器。 我還應該指出，postfix 的默認安裝可能不足以在生產環境中發送電子郵件。為了避免垃圾郵件和惡意電子郵件，許多伺服器要求發件伺服器通過安全 擴展來識別自己，這意味著你至少必須擁有一個與你的伺服器關聯的域名。如果你想學習如何完全配置一個電子郵件伺服器，使其通過標準安全測試，請參見以下 Digital Ocean 指南： Postfix 配置 添加 SPF 記錄 DKIM 安裝和配置 安裝應用程式現在我將使用 git 從我的 GitHub 儲存庫下載 Microblog 源代碼。如果你不熟悉 git 源控制，我建議你閱讀 git 入門。 要將應用程式下載到伺服器，請確保你在 ubuntu 用戶的家目錄中，然後運行： 123$ git clone https://github.com/miguelgrinberg/microblog$ cd microblog$ git checkout v0.17 這將在你的伺服器上安裝代碼，並將其與本章同步。如果你將本教程代碼的版本保持在你自己的 git 儲存庫中，你可以將儲存庫 URL 更改為你的，並在這種情況下你可以跳過 git checkout 命令。 現在我需要建立一個虛擬環境並用所有包依賴填充它，這些依賴我在第 15 章方便地保存到了 requirements.txt 檔案中： 123$ python3 -m venv venv$ source venv/bin/activate(venv) $ pip install -r requirements.txt 除了 requirements.txt 中的常見要求外，我將使用三個特定於這次生產部署的包，所以它們不包含在常見要求檔案中。gunicorn 包是一個 Python 應用程式的生產網頁伺服器。pymysql 包包含 MySQL 驅動程序，使得 SQLAlchemy 能夠與 MySQL 數據庫工作。cryptography 包由 pymsql 使用，用於對 MySQL 數據庫伺服器進行身份驗證。 1(venv) $ pip install gunicorn pymysql cryptography 我需要建立一個 .env 檔案，帶有所有需要的環境變量： /home/ubuntu/microblog/.env: 環境配置。 12345SECRET_KEY=52cb883e323b48d78a0a36e8e951ba4aMAIL_SERVER=localhostMAIL_PORT=25DATABASE_URL=mysql+pymysql://microblog:&lt;db-password&gt;@localhost:3306/microblogMS_TRANSLATOR_KEY=&lt;your-translator-key-here&gt; 這個 .env 檔案與我在第 15 章中顯示的例子大致相似，但我使用了一個隨機字符串作為 SECRET_KEY。你應該在這裡生成你自己的密鑰。你可以使用以下命令： 1python3 -c &quot;import uuid; print(uuid.uuid4().hex)&quot; 對於 DATABASE_URL 變量，我定義了一個 MySQL URL。我將在下一節中向你展示如何配置數據庫。 我需要設置 FLASK_APP 環境變量到應用程式的入口點，以啟動 flask 命令工作。如果你的專案儲存庫中沒有 .flaskenv 檔案，那麼現在是添加一個的時候了。你可以通 過運行 flask –help 確認 FLASK_APP 變量是否配置。如果幫助訊息顯示了應用程式添加的 translate 命令，那麼你知道應用程式被找到了。 現在 flask 命令是功能性的，我可以編譯語言翻譯： 1(venv) $ flask translate compile 設置 MySQL在開發期間我使用的 SQLite 數據庫非常適合簡單應用程式，但當部署一個可能需要同時處理多個請求的完整網頁伺服器時，最好使用更健壯的數據庫。因此我將設置一個我將稱為 microblog 的 MySQL 數據庫。 要管理數據庫伺服器，我將使用 mysql 命令，它應該已經在你的伺服器上安裝： 1234567891011121314$ sudo mysql -u rootWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 8Server version: 8.0.25-0ubuntu0.20.04.1 (Ubuntu)Copyright (c) 2000, 2021, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 請注意，你需要使用 sudo 從管理員帳戶訪問 MySQL root 用戶。 這些是建立一個名為 microblog 的新數據庫，以及一個同名用戶的命令，該用戶對它擁有完全訪問權限： 12345mysql&gt; create database microblog character set utf8 collate utf8_bin;mysql&gt; create user 'microblog'@'localhost' identified by '&lt;db-password&gt;';mysql&gt; grant all privileges on microblog.* to 'microblog'@'localhost';mysql&gt; flush privileges;mysql&gt; quit; 你需要將 替換為你選擇的密碼。你在這裡選擇的密碼需要與你在 .env 檔案中的 DATABASE_URL 變量中包含的密碼匹配。 如果你的數據庫配置正確，你現在應該能夠運行數據庫遷移，建立所有表格： 1(venv) $ flask db upgrade 在你繼續之前，確保上述命令完成並且沒有產生任何錯誤。 設置 Gunicorn 和 Supervisor當你使用 flask run 運行伺服器時，你正在使用 Flask 附帶的網頁伺服器。這個伺服器在開發期間非常有用，但它不是用於生產伺服器的好選擇，因為它沒有考慮到性能和健壯性。與 Flask 的開發伺服器不同，對於這次部署，我決定使用 Gunicorn，這也是一個純 Python 網頁伺服器，但與 Flask 的不同，它是一個健壯的生產伺服器，被很多人使用，同時配置非常簡單。 要在 Gunicorn 下啟動 Microblog，你可以使用以下命令： 1(venv) $ gunicorn -b localhost:8000 -w 4 microblog:app -b 選項告訴 Gunicorn 在哪裡聽請求，我將其設置 為在內部網絡接口的 8000 端口。通常建議在沒有外部訪問的情況下運行 Python 網頁應用程式，然後有一個非常快的網頁伺服器優化以服務靜態檔案接受來自客戶端的所有請求。這個快速的網頁伺服器將直接服務靜態檔案，並將任何針對應用程式的請求轉發給內部伺服器。我將在下一節中向你展示如何設置 nginx 作為公共面向伺服器。 -w 選項配置 Gunicorn 將運行多少個工作進程。擁有四個工作進程允許應用程式同時處理多達四個客戶端，對於一個網頁應用程式來說，通常足以處理相當多的客戶端，因為不是所有的客戶端都在不斷請求內容。根據你的伺服器擁有的 RAM 量，你可能需要調整工作進程的數量，以便你不會耗盡記憶體。 microblog:app 參數告訴 Gunicorn 如何加載應用程式實例。冒號前的名稱是包含應用程式的模塊，對於這個應用程式是 microblog.py。冒號後的名稱是應用程式實例的名稱。 雖然 Gunicorn 非常簡單地設置，但實際上從命令列運行伺服器並不是生產伺服器的好解決方案。我想做的是讓伺服器在後台運行，並且處於不斷監控的狀態，因為如果由於任何原因伺服器崩潰並退出，我想確保自動啟動一個新伺服器來取代它的位置。而且我還想確保如果機器被重啟，伺服器在啟動時自動運行，無需我登錄並啟動事物。我將使用上面安裝的 supervisor 包來做到這一點。 supervisor 實用程式使用配置檔案告訴它監控哪些程式以及如何在必要時重新啟動它們。配置檔案必須存儲在 /etc/supervisor/conf.d 中。以下是 Microblog 的配置檔案，我將其命名為 microblog.conf： /etc/supervisor/conf.d/microblog.conf: Supervisor 配置。 12345678[program:microblog]command=/home/ubuntu/microblog/venv/bin/gunicorn -b localhost:8000 -w 4 microblog:appdirectory=/home/ubuntu/microbloguser=ubuntuautostart=trueautorestart=truestopasgroup=truekillasgroup=true command、directory 和 user 設置告訴 supervisor 如何運行應用程式。autostart 和 autorestart 設置自動重新啟動，由於電腦啟動或崩潰。stopasgroup 和 killasgroup 選項確保當 supervisor 需要停止應用程式以重新啟動它時，它也達到了頂級 Gunicorn 進程的子進程。 在你 寫這個配置檔案後，你必須重新加載 supervisor 服務以導入它： 1$ sudo supervisorctl reload 就這樣，Gunicorn 網頁伺服器應該已經啟動並運行並且被監控了！ 設置 Nginx由 Gunicorn 提供動力的 microblog 應用程式伺服器現在在 8000 端口上私下運行。我現在需要做的是啟用我的公共面向網頁伺服器在端口 80 和 443 上，這兩個端口我在防火牆上打開以處理應用程式的網頁流量。 我希望這是一個安全的部署，所以我將配置端口 80 將所有流量轉發到端口 443，這將是加密的。所以我將從建立一個 SSL 證書開始。現在，我將建立一個自簽名的 SSL 證書，這對於測試一切都很好，但對於真實部署來說不好，因為網頁瀏覽器將警告用戶證書沒有由受信任的證書授權機構簽發。為 microblog 建立 SSL 證書的命令是： 123$ mkdir certs$ openssl req -new -newkey rsa:4096 -days 365 -nodes -x509 \\ -keyout certs/key.pem -out certs/cert.pem 命令將要求你輸入有關你的應用程式和你自己的一些訊息。這是將包含在 SSL 證書中的訊息，網頁瀏覽器將向用戶顯示它，如果他們請求查看它。上述命令的結果將是兩個名為 key.pem 和 cert.pem 的檔案，我將它們放在 Microblog 根目錄的 certs 子目錄中。 要由 nginx 服務一個網站，你需要為它寫一個配置檔案。在大多數 nginx 安裝中，這個檔案需要在 /etc/nginx/sites-available 目錄中。以下你可以看到 nginx 為 Microblog 的配置檔案，它位於 /etc/nginx/sites-available/microblog 中： /etc/nginx/sites-available/microblog: Nginx 配置。 12345678910111213141516171819202122232425262728293031323334353637server { # listen on port 80 (http) listen 80; server_name _; location / { # redirect any requests to the same URL but on https return 301 https://$host$request_uri; }}server { # listen on port 443 (https) listen 443 ssl; server_name _; # location of the self-signed SSL certificate ssl_certificate /home/ubuntu/microblog/certs/cert.pem; ssl_certificate_key /home/ubuntu/microblog/certs/key.pem; # write access and error logs to /var/log access_log /var/log/microblog_access.log; error_log /var/log/microblog_error.log; location / { # forward application requests to the gunicorn server proxy_pass http://localhost:8000; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location /static { # handle static files directly, without forwarding to the application alias /home/ubuntu/microblog/app/static; expires 30d; }} nginx 配置遠非微不足道，但我添加了一些註釋，這樣至少你知道每個部分做了什麼。如果你想要有關特定指令的訊息，請諮詢 nginx 官方文件。 網站現在已經配置好了，但還沒有啟用。要啟用它，需要在 /etc/nginx/sites-enabled 目錄中為這個檔案建立一個鏈接。Nginx 附帶了一個我真的不需要的測試網站，所以我將從刪除它開始： 1$ sudo rm /etc/nginx/sites-enabled/default 現在我可以建立一個鏈接到 microblog 配置： 1sudo ln -s /etc/nginx/sites-available/microblog /etc/nginx/sites-enabled/microblog 在你添加這個檔案後，你需要告訴 nginx 重新加載配置： 1$ sudo service nginx reload 現在應用程式應該已經部署了。在你的網頁瀏覽器中，你可以輸入你的伺服器的 IP 地址（或如果你使用 Vagrant VM 則為 192.168.56.10），這將連接到應用程式。因為你使用了自簽名證書，你將從網頁瀏覽器收到一個警告，你將不得不駁回。 在你根據上述說明完成自己的專案部署後，我強烈建議你用一個真正的證書替換自簽名證書，這樣瀏覽器就不會警告你的用戶關於你的網站了。為此，你首先需要購買一個域名，並將其配置為指向你的伺服器的 IP 地址。一旦你有了一個域名，你可以請求一個免費的 Let’s Encrypt SSL 證書。我在我的博客上寫了一篇詳細的文章，講述如何通過 HTTPS 運行你的 Flask 應用程式。 部署應用程式更新我想討論的最後一個關於基於 Linux 的部署的主題是如何處理應用程式升級。應用程式源代碼通過 git 安裝在伺服器上，所以每當你想要將你的應用程式升級到最新版本時，你可以只運行 git pull 下載自上次部署以來所做的新提交。 但當然，下載新版本的代碼不會導致升級。當前運行的伺服器進程將繼續運行舊代碼，這已經被讀取並儲存在記憶體中。要觸發升級，你必須停止當前伺服器並啟動一個新伺服器，以強制重新讀取所有代碼。 一般來說，進行升級比僅僅重新啟動伺服器更複雜。你可能需要應用數據庫遷移，或編譯新語言翻譯，所以實際上，執行升級的過程涉及一系列命令： 12345(venv) $ git pull # 下載新版本(venv) $ sudo supervisorctl stop microblog # 停止當前伺服器(venv) $ flask db upgrade # 升級數據庫(venv) $ flask translate compile # 升級翻譯(venv) $ sudo supervisorctl start microblog # 啟動一個新伺服器 Raspberry Pi 主機Raspberry Pi 是一款成本低廉的小型 Linux 電腦，它耗電量非常小，因此非常適合用來架設一個家用的網頁伺服器，它可以24小時不間斷地在線，而不需要佔用你的桌面電腦或筆記型電腦。有幾種 Linux 發行版可以在 Raspberry Pi 上運行。我的選擇是 Raspberry Pi OS，這是 Raspberry Pi 基金會的官方發行版。 為了準備 Raspberry Pi，我將安裝一個全新的 Raspberry Pi OS 發行版。我會使用 Lite 版本，因為我不需要桌面使用者介面。你可以在他們的操作系統頁面上找到 Raspberry Pi OS 的最新發行版。 Raspberry Pi OS 映像檔需要安裝在一張 SD 卡上，然後你將其插入 Raspberry Pi，以便它能夠進行開機。在 Raspberry Pi 網站上有關於如何從 Windows、Mac OS X 和 Linux 將 Raspberry Pi OS 映像檔複製到 SD 卡的指南。 當你第一次開機 Raspberry Pi 時，連接鍵盤和顯示器進行開機，這樣你才能進行設定。你至少應該啟動 SSH，這樣你就可以從你的電腦登入，更舒適地進行部署任務。 就像 Ubuntu，Raspberry Pi OS 是 Debian 的衍生版，所以上述針對 Ubuntu Linux 的指南在大部分情況下也同樣適用於 Raspberry Pi。然而，如果你計劃在家庭網路上運行一個小型應用程式，而且不需要外部存取，你可能會決定跳過一些步驟。例如，你可能不需要防火牆，或無密碼登錄。在這樣的小型電腦上，你可能會想使用 SQLite 而不是 MySQL。你可能選擇不使用 nginx，只讓 Gunicorn 伺服器直接監聽來自客戶端的請求。你可能只想要一兩個 Gunicorn 工作進程。supervisor 服務在確保應用程式始終上線方面非常有用，所以我建議你也在 Raspberry Pi 上使用它。 繼續進行到下一章。","link":"/python/flask-mega-tutorial/chapter_17_deployment_on_linux.html"},{"title":"Chapter 1 : Hello, World","text":"Posted by on Miguel Grinberg 歡迎！你即將開始學習如何使用 Python 和 Flask 框架建立網頁應用程式。在這第一章中，你將學習如何設置一個 Flask 專案。在本章結束時，你將能夠讓一個簡單的 Flask 網頁應用程式在你的電腦上運行！ 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 本書中展示的所有範例程式碼都托管在 GitHub 倉庫上。從 GitHub 下載程式碼可以節省你很多打字的時間，但我強烈建議你自己打出程式碼，至少對於前幾章來說。一旦你對 Flask 和範例應用程式更熟悉，如果打字變得太繁瑣，你可以直接從 GitHub 存取程式碼。 在每章的開始，我會給你三個 GitHub 連結，這些在你研讀章節時會很有用。瀏覽連結將打開 GitHub 倉庫中 Microblog 的位置，在這裡加入了你正在閱讀的章節中的變更，而不包括未來章節中引入的任何變更。壓縮檔連結是一個下載連結，包括整個應用程式直到本章節的變更。Diff 連結將打開一個圖形視圖，顯示你即將閱讀的章節中所做的所有變更。 這一章的 GitHub 連結有：Browse Zip Diff 安裝 Python如果你的電腦還沒有安裝 Python，現在就去安裝吧。如果你的作業系統沒有提供 Python 套件，你可以從 Python 官方網站下載安裝程式。如果你正在使用 Microsoft Windows 並且有 WSL 或 Cygwin，請注意你將不會使用 Windows 本機版本的 Python，而是需要從 Ubuntu（如果你使用 WSL）或 Cygwin 獲得一個 UNIX 友好版本的 Python。 為了確保你的 Python 安裝是可用的，你可以打開一個終端機視窗並輸入 python3，或者如果那不行，就輸入 python。以下是你應該看到的內容： 1234$ python3Python 3.12.0 (main, Oct 5 2023, 10:46:39) [GCC 11.4.0] on linux輸入 &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; 或 &quot;license&quot; 來獲取更多資訊。&gt;&gt;&gt; _ Python 直譯器現在正在互動提示符下等待，你可以在此輸入 Python 語句。在未來的章節中，你將學習這個互動提示符有哪些用途。但現在，你已經確認了你的系統上安裝了 Python。要退出互動提示符，你可以輸入 exit() 並按 Enter。在 Linux 和 Mac OS X 版本的 Python 上，你也可以通過按 Ctrl-D 來退出直譯器。在 Windows 上，退出快捷方式是 Ctrl-Z，然後按 Enter。 安裝 Flask下一步是安裝 Flask，但在我講解之前，我想告訴你關於安裝 Python 套件的最佳實踐。 在 Python 中，像 Flask 這樣的套件可在公共倉庫中獲得，任何人都可以從中下載並安裝它們。官方的 Python 套件倉庫稱為 PyPI，代表 Python Package Index（有些人也將這個倉庫稱為 “乳酪店”）。從 PyPI 安裝套件非常簡單，因為 Python 附帶了一個叫做 pip 的工具來完成這項工作。 要在你的機器上安裝套件，你可以如下使用 pip： 1$ pip install &lt;套件名稱&gt; 有趣的是，這種安裝套件的方法在大多數情況下都不會奏效。如果你的 Python 直譯器是為你電腦的所有使用者全局安裝的，那麼你的普通使用者帳戶可能沒有權限對其進行修改，所以上面命令的唯一方法是從管理員帳戶運行。但即使沒有這種複雜情況，想想當你以這種方式安裝套件時會發生什麼。pip 工具將從 PyPI 下載套件，然後將其加入到你的 Python 安裝中。從那時起，你系統上的每個 Python 指令稿都將能夠存取這個套件。想像一下這樣的情況：當你開始時，你已經使用 Flask 第 2 版完成了一個網頁應用程式，那是你開始時 Flask 的最新版本，但現在它已經 被第 3 版取代。現在你想開始第二個應用程式，你希望使用第 3 版，但如果你升級了你安裝的第 1 版，你可能會破壞你的舊應用程式。你看到問題了嗎？如果能夠有 Flask 第 2 版安裝並可供你的舊應用程式使用，同時也為你的新應用程式安裝 Flask 第 3 版，那將是理想的。 為了解決為不同應用程式維護不同版本的套件的問題，Python 使用了虛擬環境的概念。一個虛擬環境是 Python 直譯器的一個完整副本。當你在虛擬環境中安裝套件時，系統範圍的 Python 直譯器不會受到影響，只有副本會受到影響。因此，為每個應用程式使用不同的虛擬環境來完全自由地安裝任何版本的套件是解決方案。虛擬環境的另一個好處是它們是由建立它們的使用者擁有的，因此不需要管理員帳戶。 讓我們開始建立一個專案將生活的目錄。我將這個目錄稱為 microblog，因為這是應用程式的名稱： 12$ mkdir microblog$ cd microblog 最近版本的 Python 都內建了對虛擬環境的支援，所以你需要做的就是這樣來建立一個： 1$ python3 -m venv venv 使用這個命令，我請求 Python 運行 venv 套件，該套件建立了一個名為 venv 的虛擬環境。命令中的第一個 venv 是 -m 選項的參數，這是 Python 虛擬環境套件的名稱，第二個是我要用於這個特定環境的虛擬環境名稱。如果你覺得這有點混淆，你可以將第二個 venv 替換為你想要指派給你的虛擬環境的不同名稱。一般來說，我在專案目錄中使用名為 venv 的名稱來建立我的虛擬環境，所以每當我進入一個專案時，我都會找到它對應的虛擬環境。 請注意，在某些作業系統中，你可能需要在上面的命令中使用 python 代替 python3。一些安裝使用 python 表示 2.x 版本的 Python，並使用 python3 表示 3.x 版本，而其他安裝則將 python 映射到 3.x 版本，根本沒有 python3 命令。 命令完成後，你將擁有一個名為 venv 的目錄，其中存儲了虛擬環境文件。 現在你必須告訴系統你想使用這個虛擬環境，你通過激活它來做到這一點。要激活你全新的虛擬環境，使用以下命令： 12$ source venv/bin/activate(venv) $ _ 如果你使用的是 Microsoft Windows 命令提示字元視窗，激活命令略有不同： 12$ venv\\Scripts\\activate(venv) $ _ 如果你在 Windows 上使用 PowerShell 而不是命令提示字元，那麼還有另一個激活命令你應該使用： 12$ venv\\Scripts\\Activate.ps1(venv) $ _ 當你激活一個虛擬環境時，你的終端機會話配置會被修改，以便當你輸入 python 時，存儲在其中的 Python 直譯器是被調用的那一個。此外，終端機提示符也會被修改以包括已激活虛擬環境的名稱。對你的終端機會話所做的更改都是臨時的，並且是私有的，所以當你關閉終端機視窗時它們不會持續存在。如果你同時打開多個終端機視窗工作，那麼在每一個上激活不同的虛擬環境是完全可以的。 現在你已經建立並激活了一個虛擬環境，你終於可以在其中安裝 Flask 了： 1(venv) $ pip install flask 如果你想確認你的虛擬環境現在已經安裝了 Flask，你可以啟動 Python 解釋器並導入 Flask： 12&gt;&gt;&gt; import flask&gt;&gt;&gt; _ 如果這個語句沒有產生任何錯誤，你可以慶祝一下，因為 Flask 已經安裝好並準備好被使用了。 請注意，上面的安裝指令並未指定你想安裝的 Flask 版本。當沒有指定版本時，預設會安裝套件庫中可用的最新版本。這份教學是為 Flask 的第 3 版設計的，但也應該適用於第 2 版。上面的指令會安裝最新的 3.x 版本，這對大多數使用者來說應該是合適的。如果你因為某些原因想要按照這份教學在 Flask 的 2.x 版本上操作，你可以使用以下指令來安裝最新的 1.x 版本： 1(venv) $ pip install &quot;flask&lt;3&quot; &quot;werkzeug&lt;3&quot; “Hello, World” Flask 應用程式如果你前往 Flask 的快速入門頁面，你會看到一個非常簡單的範例應用程式，只有五行程式碼。我不打算重複那個簡單的範例，而是要展示一個稍微複雜一點的，這將為你寫更大型應用程式提供一個良好的基礎結構。 這個應用程式將存在於一個套件中。在 Python 中，包含 init.py 檔案的子目錄被認為是一個套件，並且可以被導入。當你導入一個套件時，init.py 會執行並定義套件對外界暴露的符號。 我們來建立一個叫做 app 的套件，用來承載這個應用程式。確保你在 microblog 目錄中，然後執行以下指令： 1(venv) $ mkdir app app 套件的 init.py 將包含以下程式碼： app/init.py: Flask 應用程式實例 12345from flask import Flaskapp = Flask(__name__)from app import routes 上面的腳本建立了一個應用程式物件，作為從 flask 套件導入的 Flask 類別的實例。傳遞給 Flask 類別的 name 變數是 Python 預先定義的變數，設置為使用它的模組的名稱。Flask 使用這裡傳遞的模組位置作為起點，當它需要載入相關資源時，例如範本檔案，我將在第 2 章中介紹。出於所有實際目的，傳遞 name 幾乎總是會以正確的方式配置 Flask。然後應用程式導入了尚不存在的 routes 模組。 一個起初可能會讓人困惑的方面是，有兩個叫做 app 的實體。app 套件是由 app 目錄和 init.py 腳本定義的，並在 from app import routes 語句中被引用。app 變數是在 init.py 腳本中定義為 Flask 類別的實例，這使它成為 app 套件的成員。 另一個特殊之處是在腳本底部而不是頂部導入 routes 模組，這通常是習慣。底部導入是一個眾所周知的解決方法，用來避免循環導入，這是 Flask 應用程式的常見問題。你將看到 routes 模組需要導入這個腳本中定義的 app 變數，所以將互相導入的其中一個放在底部可以避免因這兩個檔案之間的相互引用而導致的錯誤。 那麼 routes 模組中有什麼內容呢？路由處理應用程式支援的不同 URL。在 Flask 中，應用程式路由的處理器寫成 Python 函式，稱為視圖函式。視圖函式映射到一個或多個路由 URL，以便 Flask 知道當使用者端請求給定 URL 時該執行什麼邏輯。 這是該應用程式的第一個視圖函式，你需要在一個名為 app/routes.py 的新模組中寫入： app/routes.py: 主頁路由 123456from app import app@app.route('/')@app.route('/index')def index(): return &quot;Hello, World!&quot; 這個視圖函式實際上相當簡短，它只是返回一個問候作為字串。上面函式的兩個奇怪的 @app.route 行是裝飾器，Python 語言的一個獨特功能。裝飾器修改其後面的函式。裝飾器的一個常見模式是將它們用來註冊函式作為某些事件的回調。在這個案例中，@app.route 裝飾器在給定的 URL 和函式之間建立了關聯。在這個範例中有兩個裝飾器，將 URL / 和 /index 與此函式關聯。這意味著當網路瀏覽器請求這兩個 URL 中的任何一個時，Flask 將調用此函式，並將其返回值作為回應傳回瀏覽器。如果這還沒有完全理解，當你運行這個應用程式時很快就會明白。 要完成應用程式，你需要在頂層有一個 Python 腳本，定義 Flask 應用程式實例。我們將這個腳本稱為 microblog.py，並將其定義為一個導入應用程式實例的單行： microblog.py: 主要應用程式模組 1from app import app 還記得兩個 app 實體嗎？在這裡你可以在同一句話中看到它們。Flask 應用程式實例被稱為 app，是 app 套件的成員。from app import app 語句導入了 app 套件的成員 app 變數。如果你覺得這很困惑，你可以將套件或變數之一重新命名為其他東西。 為了確保你正確地做了一切，以下你可以看到到目前為止項目結構的圖表： microblog/ venv/ app/ init.py routes.py microblog.py不管你信不信，這個應用程式的第一版現在已經完成了！但是在運行它之前，需要通過設置 FLASK_APP 環境變數來告訴 Flask 如何導入它： 1(venv) $ export FLASK_APP=microblog.py 如果你在使用 Microsoft Windows 命令提示字元，請在上述指令中使用 set 而不是 export。 你準備好被震撼了嗎？你可以通過輸入以下指令來運行你的第一個網路應用程式： 1234567(venv) $ flask run * Serving Flask app 'microblog.py' (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 這裡發生了什麼？flask run 指令將在 FLASK_APP 環境變數引用的模組中查找 Flask 應用程式實例，在這種情況下是 microblog.py。該指令設置了一個網路伺服器，配置為將請求轉發給這個應用程式。 伺服器初始化後將等待使用者端連接。flask run 的輸出表明伺服器正在 IP 地址 127.0.0.1 上運行，這總是你自己電腦的地址。這個地址如此常見，以至於也有一個更簡單的名稱你可能以前見過：localhost。網路伺服器監聽特定埠號上的連接。部署在生產網路伺服器上的應用程式通常在埠 443 監聽，或者如果它們不實施加密，有時是 80，但訪問這些埠需要管理員權限。由於這個應用程式在開發環境中運行，Flask 使用埠 5000。現在打開你的網路瀏覽器，並在地址欄中輸入以下 URL： 1http://localhost:5000/ 或者你可以使用這個其他 URL： 1http://localhost:5000/index 你看到應用程式路由對應的執行了嗎？第一個 URL 對應到 /，而第二個對應到 /index。這兩個路由都關聯到應用程式中唯一的視圖函式，所以它們產生相同的輸出，這就是函式回傳的字串。如果你輸入其他的 URL，你會得到一個錯誤，因為只有這兩個 URL 被應用程式識別。 當你玩完伺服器後，你可以按 Ctrl-C 停止它。 恭喜你，你已經完成成為網頁開發者的第一大步！ Flask 應用程式執行問題你在執行 Flask 應用程式時遇到麻煩了嗎？在大多數電腦中，5000 端口是可用的，但你的電腦可能已經在運行一個使用這個端口的應用程式，在這種情況下，flask run 指令將因為「地址已被使用」或類似的錯誤而失敗。如果你使用 Macintosh 電腦，macOS 的某些版本會在這個端口上運行一個名為「Airplay Receiver」的服務。如果你無法找出如何移除使用端口 5000 的軟體，你可以嘗試在不同端口上執行 Flask。例如，以下是如何在端口 5001 上啟動伺服器： 1(venv) $ flask run --port 5001 環境變數的註冊在我結束這章之前，我要再向你展示一件事。由於環境變數在終端會話之間不會被記住，當你開啟一個新的終端視窗來處理你的 Flask 應用程式時，你可能會發現每次都要設定 FLASK_APP 環境變數很麻煩。但幸運的是，Flask 允許你註冊你希望在執行 flask 指令時自動使用的環境變數。要使用這個選項，你必須安裝 python-dotenv 套件： 1(venv) $ pip install python-dotenv 現在你只需在項目頂層目錄中名為 .flaskenv 的檔案中寫下環境變數名稱和值： .flaskenv: flask 指令的環境變數 1FLASK_APP=microblog.py flask 指令會尋找 .flaskenv 檔案並導入其中定義的所有變數，就如同它們是在環境中定義的一樣。","link":"/python/flask-mega-tutorial/chapter_1_hello_world.html"},{"title":"","text":"目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） Flask 大教程，第十九部分：在 Docker 容器上部署這是 Flask 大教程系列的第十九篇文章，在這篇文章中，我將會將 Microblog 部署到 Docker 容器平台上。 在第十七章，你學到了傳統部署的方法，這種方法需要你自己處理伺服器配置的每一個細節。然後在第十八章中，我引導你了解到另一個極端，我介紹了 Heroku 這個服務，它完全控制了配置和部署任務，讓你可以完全專注於你的應用程式。在這一章，你將學習到基於容器的第三種應用程式部署策略，特別是基於 Docker 容器平台。這第三個選項在部署工作所需的努力上介於其他兩者之間。 容器建立在一種輕量級虛擬化技術之上，允許應用程式連同其依賴和配置在完全隔離的環境中運行，但不需要使用如虛擬機這樣的完整虛擬化解決方案，這會需要更多資源並有時會與主機相比有顯著的性能下降。配置為容器主機的系統可以執行許多容器，所有這些容器都共享主機的核心和直接訪問主機的硬體。這與虛擬機形成對比，虛擬機需要模擬完整的系統，包括 CPU、硬盤、其他硬體、核心等。 儘管需要共享核心，容器中的隔離程度相當高。一個容器有其自己的檔案系統，並可以基於與容器主機使用的作業系統不同的作業系統。例如，你可以在 Fedora 主機上運行基於 Ubuntu Linux 的容器，反之亦然。雖然容器是 Linux 作業系統的原生技術，但得益於虛擬化，也可以在 Windows 和 macOS 主機上運行 Linux 容器。這允許你在開發系統上測試你的部署，並且如果你願意，也可以將容器納入你的開發工作流程。 安裝 Docker雖然 Docker 不是唯一的容器平台，但它是迄今為止最受歡迎的，所以這將是我的選擇。 要使用 Docker，你首先需要在你的系統上安裝它。Docker 網站提供了 Windows、macOS 和幾個 Linux 發行版的安裝程式。到目前為止，在你的電腦上設置 Docker 最簡單的方法是使用你的作業系統的 Docker Desktop 安裝程式。如果你在 Microsoft Windows 系統上工作，重要的是要注意 Docker 需要 Hyper-V。如果需要，安裝程式將為你啟動這一功能，但請記住，啟動 Hyper-V 可能會阻止其他虛擬化技術如 VirtualBox 的工作。 一旦在你的系統上安裝了 Docker Desktop，你可以通過在終端視 窗或命令提示符上輸入以下命令來驗證安裝是否成功： 1$ docker version 建立容器映像為 Microblog 建立容器的第一步是為它建立一個映像。容器映像是用來建立容器的模板。它包含了容器檔案系統的完整表示，以及關於網絡、啟動選項等的各種設置。 最基本的建立應用程式容器映像的方式是啟動一個你想要使用的基本作業系統（如 Ubuntu、Fedora 等）的容器，連接到在其中運行的 bash shell 程序，然後手動安裝你的應用程式，也許遵循我在第十七章為傳統部署提供的指南。安裝完所有東西後，你可以對容器進行快照，那就成了映像。這種工作流程支持使用 docker 命令，但我不打算討論它，因為每次需要生成新映像時都要手動安裝應用程式並不方便。 更好的方法是通過腳本生成容器映像。建立腳本化容器映像的命令是 docker build。這個命令從一個稱為 Dockerfile 的檔案中讀取並執行建構指令，我將需要建立這個檔案。Dockerfile 基本上是一個安裝程式腳本，執行安裝步驟來部署應用程式，加上一些特定於容器的設置。 這裡是一個為 Microblog 準備的基本 Dockerfile： 12345678910111213141516FROM python:slimCOPY requirements.txt requirements.txtRUN pip install -r requirements.txtRUN pip install gunicornCOPY app appCOPY migrations migrationsCOPY microblog.py config.py boot.sh ./RUN chmod a+x boot.shENV FLASK_APP microblog.pyRUN flask translate compileEXPOSE 5000ENTRYPOINT [&quot;./boot.sh&quot;] Dockerfile 中的每一行都是一個命令。FROM 命令指定了新映像將建立在哪個基本容器映像之上。思路是從一個現有的映像開始，添加或更改一些東西，最終得到一個衍生的映像。映像通過名稱和標籤來引用，用冒號分隔。標籤用作版本控制機制，允許容器映像提供多於一個變體。我選擇的映像名稱是 python，這是 Python 的官方 Docker 映像。標籤允許你指定解釋器版本和基本作業系統。slim 標籤選擇了只包含運行 Python 解釋器所需最小套件的容器映像。你可以在 Python 映像庫中看到 Python 的其他可用標籤。 啟動容器已經建立了映像，你現在可以運行應用程式的容器版本了。這是用 docker run 命令完成的，該命令接受一長串參數。我將從顯示一個基本示例開始： 1$ docker run --name microblog -d -p 8000:5000 --rm microblog:latest 如果 你想查看哪些容器正在運行，你可以使用 docker ps 命令： 1$ docker ps 如果現在你想停止容器，你可以使用 docker stop 並傳遞容器 ID 或者是用 –name 選項給它的名字： 1$ docker stop microblog 使用第三方「容器化」服務Microblog 的容器版本看起來不錯，但我還沒有真正考慮過儲存問題。實際上，由於我沒有設定 DATABASE_URL 環境變數，應用程式正在使用預設的 SQLite 資料庫，這由磁碟上的一個檔案支持。當你停止並刪除容器時，你認為那個 SQLite 檔案會發生什麼？檔案會消失！ 容器中的檔案系統是短暫的，意味著當容器消失時，它也會消失。你可以向檔案系統寫入資料，如果容器需要讀取它，資料就會在那裡，但如果由於任何原因你需要回收你的容器並用一個新的替換它，任何應用程式儲存到磁碟上的資料都將永遠丟失。 部署容器化應用程式關於在 Docker 容器中運行你的應用程式的最好事情之一是，一旦你在本地測試了容器，你就可以將它們帶到任何提供 Docker 支持的平台。例如，你可以使用我在第十七章推薦的 Digital Ocean、Linode 或 Amazon Lightsail 的相同伺服器。即使是這些提供商中最便宜的產品也足以運行 Docker 和少數幾個容器。 Amazon 容器服務（ECS）為你提供了在完全集成的 AWS 環境中建立容器主機集群並在其上運行容器的能力，支持擴展和負載平衡，還有使用私有容器註冊表為你的容器映像的選項。 最後，如 Kubernetes 這樣的容器編排平台提供了更高層次的自動化和便利，通過允許你以 YAML 格式的文本檔案描述你的多容器部署，具有負載平衡、擴展、安全管理秘密以及滾動升級和回滾的功能。 繼續到下一章。","link":"/python/flask-mega-tutorial/chapter_19_deployment_on_docker_containers.html"},{"title":"","text":"Chapter 20: Some JavaScript Magic Posted by on Miguel Grinberg 這是 Flask Mega-Tutorial 系列的第二十篇，我將在這篇中新增一個當你將滑鼠懸停在使用者暱稱上時會顯示的漂亮彈出視窗。 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 如今，建立一個不使用至少一點點 JavaScript 的網頁應用程式已經是不可能的事了。我確信你知道，原因是 JavaScript 是唯一一種在網頁瀏覽器中原生運行的語言。在第十四章，你看到我在 Flask 範本中新增了一個簡單的 JavaScript 啟用連結，以提供部落格貼文的即時語言翻譯。在這一章，我將深入探討這個主題，並向你展示另一個有用的 JavaScript 技巧，讓應用程式對使用者來說更加有趣和吸引人。 在社交網站上，一個常見的使用者介面模式是當你將滑鼠懸停在使用者名稱上時，在頁面上的任何地方顯示使用者的快速摘要彈出面板。如果你從未注意過這一點，去 Twitter、Facebook、LinkedIn 或任何其他主要的社交網路，當你看到一個使用者名稱，只需將你的滑鼠指標放在它上方幾秒鐘，就會看到彈出視窗出現。這一章將致力於為 Microblog 建立該功能，下面是一個預覽： 這一章的 GitHub 連結為：瀏覽、壓縮檔、差異。 伺服器端支援在我們深入客戶端之前，讓我們先完成支援這些使用者彈出視窗所必需的伺服器工作。使用者彈出視窗的內容將由一個新路由返回，這將是現有使用者個人檔案路由的簡化版。這裡是視圖函式： 12345678app/main/routes.py: 使用者彈出視窗視圖函式。@bp.route('/user/&lt;username&gt;/popup')@login_requireddef user_popup(username): user = db.first_or_404(sa.select(User).where(User.username == username)) form = EmptyForm() return render_template('user_popup.html', user=user, form=form) 這個路由將被附加到 /user/&lt;username&gt;/popup URL 上，並將簡單地載入所請求的使用者，然後用它渲染一個範本。範本是用於使用者個人檔案頁面的那個的短版本： 12345678910111213141516171819202122232425262728293031app/templates/user_popup.html: 使用者彈出視窗範本。&lt;div&gt; &lt;img src=&quot;{{ user.avatar(64) }}&quot; style=&quot;margin: 5px; float: left&quot;&gt; &lt;p&gt;&lt;a href=&quot;{{ url_for('main.user', username=user.username) }}&quot;&gt;{{ user.username }}&lt;/a&gt;&lt;/p&gt; {% if user.about_me %}&lt;p&gt;{{ user.about_me }}&lt;/p&gt;{% endif %} &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; {% if user.last_seen %} &lt;p&gt;{{ _('Last seen on') }}: {{ moment(user.last_seen).format('lll') }}&lt;/p&gt; {% endif %} &lt;p&gt;{{ _('%(count)d followers', count=user.followers_count()) }}, {{ _('%(count)d following', count=user.following_count()) }}&lt;/p&gt; {% if user != current_user %} {% if not current_user.is_following(user) %} &lt;p&gt; &lt;form action=&quot;{{ url_for('main.follow', username=user.username) }}&quot; method=&quot;post&quot;&gt; {{form.hidden_tag() }} {{form.submit(value=_('Follow'), class_='btn btn-outline-primary btn-sm') }} &lt;/form&gt; &lt;/p&gt; {% else %} &lt;p&gt; &lt;form action=&quot;{{ url_for('main.unfollow', username=user.username) }}&quot; method=&quot;post&quot;&gt; {{form.hidden_tag() }} {{form.submit(value=_('Unfollow'), class_='btn btn-outline-primary btn-sm') }} &lt;/form&gt; &lt;/p&gt; {% endif %} {% endif %}&lt;/div&gt; 我將在後續部分新增的彈出視窗組件將在使用者將滑鼠指標懸停在使用者名稱上時調用此路由。作為回應，伺服器將返回彈出視窗的 HTML 內容，客戶端將顯示該內容。當使用者將滑鼠移開時，彈出視窗將被移除。 引入 Bootstrap 彈出視窗組件在第十一章，我向你介紹了 Bootstrap 框架，作為建立精美網頁的遍歷方法。到目前為止，我只使用了這個框架的一小部分。Bootstrap 附帶了許多常見的使用者介面元素，所有這些元素都在 Bootstrap 文件中有示範和範例，網址為 https://getbootstrap.com。其中一個組件是彈出視窗，文件中描述為「用於容納次要資訊的小型覆蓋內容」。這正是我需要的！ 大多數 Bootstrap 組件都是通過 HTML 標記定義的，這些標記引用了 Bootstrap CSS 定義，加入了精美的樣式。一些最先進的組件還需要 JavaScript。應用程式將這些組件包含在網頁中的標準方式是在適當的位置加入 HTML，然後對於需要腳本支援的組件，調用一個 JavaScript 函式來初始化或啟動它。彈出視窗組件確實需要 JavaScript 支援。 首先，我需要決定哪些頁面元素將觸發彈出視窗的顯示。為此，我將使用每篇貼文中出現的可點擊使用者名稱。app/templates/_post.html 子範本已經定義了使用者名稱： 123&lt;a href=&quot;{{ url_for('main.user', username=post.author.username) }}&quot;&gt; {{post.author.username}}&lt;/a&gt; 現在根據彈出視窗文件，我需要為頁面上出現的像上面那樣的每個連結建立一個 bootstrap.Popover 類的物件，這將初始化彈出視窗。不幸的是，閱讀這個之後，我遇到了更多問題而不是答案，因為這個組件似乎並不是設計來按照我需要的方式工作。以下是我需要解決的問題列表，以實現這個功能： 頁面中將有許多使用者名稱連結，每個顯示的部落格貼文一個。我需要有一種方法來找到所有這些連結，這樣我就可以在使用者有機會與頁面互動之前，通過一個 JavaScript 函式將它們初始化為彈出視窗。 Bootstrap 文件中的彈出視窗範例都提供了作為加入到目標 HTML 元素的 data-bs-content 屬性的彈出視窗內容。這對我來說真的很不方便，因為我想要進行 Ajax 調用到伺服器，以獲得顯示在彈出視窗中的內容。 使用「懸停」模式時，只要你將滑鼠指標保持在目標元素內，彈出視窗就會保持可見。當你將滑鼠移開時，彈出視窗會消失。這有一個不好的副作用，即如果使用者想要將滑鼠指標移入彈出視窗本身，彈出視窗將會消失。我需要找出一種 方法來擴展懸停行為，也包括彈出視窗，這樣使用者就可以移入彈出視窗並且，例如，點擊其中的連結。 在處理基於瀏覽器的應用程式時，事情實際上變得很快就很複雜，這並不罕見。你必須非常具體地考慮 DOM 元素如何相互作用，並使它們以一種為使用者提供良好體驗的方式行為。在接下來的部分，我將一一查看上述問題。 在頁面加載時執行函式彈出視窗組件需要用 JavaScript 明確初始化，所以很明顯，我需要在每個頁面加載時立即運行一些程式碼，這將搜索頁面中所有到使用者名稱的連結，並在它們上面初始化 Bootstrap 的彈出視窗組件。 在現代瀏覽器中運行初始化程式碼的標準方法是為 DOMContentLoaded 事件定一個處理器。我可以在 app/templates/base.html 範本中加入這個處理器，這樣每個應用程式的頁面都會運行這個： 1234567891011app/templates/base.html: 在頁面加載後運行函式。...&lt;script&gt; // ... function initialize_popovers() { // 寫初始化程式碼在這裡 } document.addEventListener('DOMContentLoaded', initialize_popovers);&lt;/script&gt; 如你所見，我在 &lt;script&gt; 元素內加入了我的初始化函式，我在第十四章中定義了 translate() 函式就在這裡。 使用選擇器查找 DOM 元素我接下來的問題是編寫 JavaScript 邏輯，以找到頁面中所有的使用者連結。 如果你還記得第十四章，參與即時翻譯的 HTML 元素有唯一的 ID。例如，一個 ID=123 的貼文有一個 id=&quot;post123&quot; 屬性加入。然後我可以使用 document.getElementById() 函式來定位 DOM 中的這個元素。這個函式是一組允許在瀏覽器中運行的應用程式根據其特性找到元素的函式之一。 對於翻譯功能，我需要找到一個具有 id 屬性的特定元素，該屬性在頁面上唯一識別元素。當尋找元素群組時，更適當的另一個搜索選項是給它們加入一個 CSS 類。不同於 id，class 屬性可以分配給多個元素，所以它非常適合找到所有需要彈出視窗的連結。我將做的是將所有使用者連結標記為 class=&quot;user_popup&quot; 屬性，然後我將用 document.getElementsByClassName('user_popup') 從 JavaScript 獲取連結列表。在這種情況下，返回值將是具有該類的所有元素的集合。 1234567891011121314app/templates/base.html: 在頁面加載後運行函式。...&lt;script&gt; // ... function initialize_popovers() { const popups = document.getElementsByClassName('user_popup'); for (let i = 0; i &lt; popups.length; i++) { // 在這裡建立彈出視窗 } } document.addEventListener('DOMContentLoaded', initialize_popovers);&lt;/script&gt; 彈出視窗與 DOM在前一節中，我加入了初始化程式碼，尋找頁面中被分配了 user_popup 類的所有元素。這個類需要加入到 _post.html 範本頁面中定義的使用者名稱連結。 123456789app/templates/_post.html: 使用者彈出視窗範本。... {% set user_link %} &lt;a class=&quot;user_popup&quot; href=&quot;{{ url_for('main.user', username=post.author.username) }}&quot;&gt; {{post.author.username}} &lt;/a&gt; {% endset %}... 如果你想知道彈出視窗的 HTML 元素在哪裡定義，好消息是我不需要擔心這個。當我建立 Popover 物件時，Bootstrap 框架將為我動態插入與彈出視窗相關的元素。 建立彈出視窗組件現在我準備好為頁面上找到的所有使用者名稱連結建立彈出視窗組件了。 app/templates/base.html: 懸停延遲。 123456789101112131415161718&lt;script&gt; function initialize_popovers() { const popups = document.getElementsByClassName('user_popup'); for (let i = 0; i &lt; popups.length; i++) { const popover = new bootstrap.Popover(popups[i], { content: '加載中...', trigger: 'hover focus', placement: 'right', html: true, sanitize: false, delay: {show: 500, hide: 0}, container: popups[i], customClass: 'd-inline', }); } } document.addEventListener('DOMContentLoaded', initialize_popovers);&lt;/script&gt; bootstrap.Popover 構造函式將獲得彈出視窗的元素作為第一個參數，和一個包含選項的物件作為 第二個參數。選項包括將出現在彈出視窗中的內容，用什麼方法觸發彈出視窗出現或消失（點擊、懸停在元素上等），彈出視窗的放置位置，內容是純文本還是 HTML，以及更多選項。 我上面提到，這個彈出視窗實現的一個大問題是，需要顯示的 HTML 內容是通過向伺服器發出請求獲得的。因此，我用「加載中…」文本初始化內容，一旦從伺服器接收到使用者的 HTML 內容，這將被動態替換。為此，我將 html 選項設置為 true，並禁用一個選項來清理 HTML 內容。清理 HTML 是一個非常重要的安全功能，當內容來自使用者時應該使用。在這個使用案例中，HTML 內容由 Flask 伺服器通過 Jinja 範本生成，預設會對所有動態內容進行清理。 延遲選項配置彈出視窗組件在懸停半秒後出現。當彈出視窗因使用者移動滑鼠指標而移除時，不配置延遲。容器選項告訴 Bootstrap 將彈出視窗組件作為連結元素的子項插入。這是一個經常推薦的技巧，允許使用者將滑鼠指標移入彈出視窗而不會導致彈出視窗消失。customClass 選項給代表彈出視窗組件的 &lt;div&gt; 元素一個內聯顯示樣式。這確保當組件被插入時，由於 &lt;div&gt; 元素的預設顯示樣式是塊，不會間接在頁面中的那個位置加入換行。 Ajax 請求Ajax 請求不是一個新話題，因為我在第十四章作為即時語言翻譯功能的一部分介紹過這個話題。和之前一樣，我將使用 fetch() 函式發送一個異步請求到伺服器。 請求需要使用 /user/&lt;username&gt;/popup URL，這是我在本章開頭加入到應用程式的。這個請求的回應將包含我需要插入到彈出視窗組件中的 HTML，替換初始的「加載中…」訊息。 我的第一個問題是如何在使用者通過懸停在使用者連結上時請求彈出視窗的時候觸發請求。通過查看彈出視窗文件，描述這個組件支援的事件的部分包括一個名為 show.bs.popover 的事件，當彈出視窗組件即將顯示時觸發。 1234567891011121314app/templates/base.html: 懸停延遲。 function initialize_popovers() { const popups = document.getElementsByClassName('user_popup'); for (let i = 0; i &lt; popups.length; i++) { const popover = new bootstrap.Popover(popups[i], { ... }); popups[i].addEventListener('show.bs.popover', async (ev) =&gt; { // 在這裡發送請求 }); } } document.addEventListener('DOMContentLoaded', initialize_popovers); 下一個問題是如何知道我需要在這個請求的 URL 中包含什麼使用者名稱。這個名稱在 &lt;a&gt; 連結的文本中。彈出視窗組件的 show 事件接收一個 ev 參數，帶有事件物件。觸發事件的元素可以用 ev.target 獲取，提取這個連結文本的表達式是： 1ev.target.innerText.trim() 頁面元素的 innerText 屬性返回節點的文本內容。文本返回時不進行任何修剪，所以例如，如果你有 &lt;a&gt; 在一行，文本在下一行，和關閉的 &lt;/a&gt; 在另一行，innerText 將返回圍繞文本的換行符和額外的空白。為了消除所有那些空白，只留下文本，我使用了 JavaScript 函式 trim()。 這就是我需要能夠向伺服器發出請求的所有資訊： 1234567891011121314151617app/templates/base.html: XHR 請求。&lt;script&gt; function initialize_popovers() { const popups = document.getElementsByClassName('user_popup'); for (let i = 0; i &lt; popups.length; i++) { const popover = new bootstrap.Popover(popups[i], { ... }); popups[i].addEventListener('show.bs.popover', async (ev) =&gt; { const response = await fetch('/user/' + ev.target.innerText.trim() + '/popup'); const data = await response.text(); // 在這裡更新彈出視窗 }); } } document.addEventListener('DOMContentLoaded', initialize_popovers);&lt;/script&gt; 這裡我使用了 fetch() 函式請求連結元素代表的使用者的 /popup URL。不幸的是，當在 JavaScript 邊直接構建 URL 時，我不能使用 Flask 的 url_for()，所以在這種情況下我必須明確地連接 URL 部分。一旦我獲得了回應，我從中提取文本到 data 中。這是需要存儲在彈出視 窗組件中的 HTML。 更新彈出視窗所以最後我現在可以用從伺服器接收到的、存儲在 data 常量中的 HTML 更新我的彈出視窗組件了： app/templates/base.html: 顯示彈出視窗。 12345678910111213141516171819202122232425&lt;script&gt; function initialize_popovers() { const popups = document.getElementsByClassName('user_popup'); for (let i = 0; i &lt; popups.length; i++) { const popover = new bootstrap.Popover(popups[i], { ... }); popups[i].addEventListener('show.bs.popover', async (ev) =&gt; { if (ev.target.popupLoaded) { return; } const response = await fetch('/user/' + ev.target.innerText.trim() + '/popup'); const data = await response.text(); const popover = bootstrap.Popover.getInstance(ev.target); if (popover &amp;&amp; data) { ev.target.popupLoaded = true; popover.setContent({'.popover-body': data}); flask_moment_render_all } }); } } document.addEventListener('DOMContentLoaded', initialize_popovers);&lt;/script&gt; 要進行這個更新，我首先獲得了彈出視窗組件，Bootstrap 通過 getInstance() 方法提供。如果我有一個彈出視窗組件和 HTML 內容，那麼我就調用彈出視窗的 setContent() 方法來更新它的主體。 作為一種優化，我還在連結元素中設置了一個 popupLoaded 屬性為 true。這樣做是為了不在彈出視窗第二次打開時重新發送相同的請求。注意我如何更新了 show 事件處理器的開頭，以檢查這個 popupLoaded 屬性，如果它被設置，那麼就直接返回，因為彈出視窗的內容已經更新了。 需要處理的最後一個細節是插入彈出視窗組件中的 HTML 內容中包含的日期和時間。這些時間戳是用 Jinja 範本中的 Flask-Moment 的 moment() 函式生成的。Flask-Moment 向頁面加入了 JavaScript 程式碼，當頁面加載時渲染所有的時間戳。當在頁面加載後動態加入新的時間戳時，需要手動調用 flask_moment_render_all() 函式來渲染它們，所以我在更新 HTML 內容後插入了對這個函式的調用。","link":"/python/flask-mega-tutorial/chapter_20_some_javascript_magic.html"},{"title":"","text":"Chapter 21: User Notifications Posted by on Miguel Grinberg 這是 Flask Mega-Tutorial 系列的第二十一篇，在這篇中，我將新增一個私人訊息功能，以及出現在導航欄中的使用者通知，無需刷新頁面即可看到。 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 在這一章，我想繼續致力於提升我的 Microblog 應用的使用者體驗。許多應用都適用的一個方面是向使用者展示警告或通知。社交應用顯示這些通知，讓你知道你收到了新的提及或私人訊息，通常是通過在頂部導航欄中顯示一個帶有數字的小徽章。雖然這是最明顯的用法，通知模式可以應用於許多其他類型的應用，以通知使用者某事需要他們的注意。 但為了向你展示建立使用者通知所涉及的技術，我需要擴展 Microblog，增加一個可以從中受益的功能，所以在本章的第一部分，我將建立一個使用者訊息系統，允許任何使用者向另一位使用者發送私人訊息。這實際上比聽起來簡單，它將是對核心 Flask 實踐的一個很好的複習，以及如何精簡、高效和有趣地使用 Flask 的提醒。一旦訊息系統到位，我將討論一些實現顯示未讀訊息數量的通知徽章的選項。 這一章的 GitHub 連結為：瀏覽、壓縮檔、差異。 私人訊息我將要實現的私人訊息功能將非常簡單。當你訪問一位使用者的個人檔案頁面時，將有一個發送私人訊息給該使用者的連結。該連結將帶你到一個新頁面，在那裡一個網頁表單接收訊息。要閱讀發送給你的訊息，頁面頂部的導航欄將有一個新的「訊息」連結，該連結將帶你到一個結構類似於索引或探索頁面的頁面，但顯示的是其他使用者發送給你的訊息，而不是部落格貼文。 以下部分描述了我實現此功能所採取的步驟。 為私人訊息提供數據庫支援第一個任務是擴展數據庫以支援私人訊息。這裡是一個新的 Message 模型： 12345678910111213141516app/models.py: 訊息模型。class Message(db.Model): id: so.Mapped[int] = so.mapped_column(primary_key=True) sender_id: so.Mapped[int] = so.mapped_column(sa.ForeignKey(User.id), index=True) recipient_id: so.Mapped[int] = so.mapped_column(sa.ForeignKey(User.id), index=True) body: so.Mapped[str] = so.mapped_column(sa.String(140)) timestamp: so.Mapped[datetime] = so.mapped_column( index=True, default=lambda: datetime.now(timezone.utc)) def __repr__(self): return '&lt;Message {}&gt;'.format(self.body) 這個模型類似於 Post 模型，唯一的區別是有兩個使用者外鍵，一個用於發送者，一個用於接收者。User 模型可以獲得兩個寫入關聯，用於發送和接收的訊息，加上一個新字段，表示每位使用者上次閱讀他們私人訊息的時間： 1234567891011121314151617181920app/models.py: User 模型中支援私人訊息。class User(UserMixin, db.Model): ## ... last_message_read_time: so.Mapped[Optional[datetime]] ## ... messages_sent: so.WriteOnlyMapped['Message'] = so.relationship( foreign_keys='Message.sender_id', back_populates='author') messages_received: so.WriteOnlyMapped['Message'] = so.relationship( foreign_keys='Message.recipient_id', back_populates='recipient') ## ... def unread_message_count(self): last_read_time = self.last_message_read_time or datetime(1900, 1, 1) query = sa.select(Message).where(Message.recipient == self, Message.timestamp &gt; last_read_time) return db.session.scalar(sa.select(sa.func.count()).select_from( query.subquery())) last_message_read_time 字段將記錄使用者最後一次訪問訊息頁面的時間，並將用於確定是否有未讀訊息，所有這些訊息的時間戳都會比這個字段更新。unread_message_count() 輔助方法實際上使用這個字段返回使用者有多少未讀訊息。到本章結束時，我將在頁面頂部的導航欄中有這個數字作為一個漂亮的徽章。 這兩個關聯返回給定使用者發送和接收的訊息。在 Message 關聯的一側，我也包括了反向關聯，我稱之為 author 和 recipient： 1234567891011app/models.py: Message 模型中的私人訊息關係。class Message(db.Model): ## ... author: so.Mapped[User] = so.relationship( foreign_keys='Message.sender_id', back_populates='messages_sent') recipient: so.Mapped[User] = so.relationship( foreign_keys='Message.recipient_id', back_populates='messages_received') 我使用 author 名稱作為關係而不是更預期的 sender 的原因是，使用 author 我可以用與部落格貼文相同的邏輯來渲染這些訊息，鑑於貼文和訊息的相似性。 這完成了數據庫的更改，現在是時候生成一個新的遷移並用它升級數據庫了： 12(venv) $ flask db migrate -m &quot;private messages&quot;(venv) $ flask db upgrade 發送私人訊息接下來我將著手發送訊息。我需要一個簡單的網頁表單接受訊息： 123456app/main/forms.py: 私人訊息表單類。class MessageForm(FlaskForm): message = TextAreaField(_l('Message'), validators=[ DataRequired(), Length(min=0, max=140)]) submit = SubmitField(_l('Submit')) 我還需要 HTML 範本在網頁上渲染這個表單： 123456789101112131415app/templates/send_message.html: 發送私人訊息 HTML 範本。{% extends &quot;base.html&quot; %}{% import 'bootstrap/wtf.html' as wtf %}{% block app_content %} &lt;h1&gt;{{ _('Send Message to %(recipient)s', recipient=recipient) }}&lt;/h1&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; {{wtf.quick_form(form) }} &lt;/div&gt; &lt;/div&gt;{% endblock %} 接下來我將新增一個 /send_message/&lt;recipient&gt; 路由來處理實際發送私人訊息： 123456789101112131415161718192021app/main/routes.py: 發送私人訊息路由。from app.main.forms import MessageFormfrom app.models import Message## ...@bp.route('/send_message/&lt;recipient&gt;', methods=['GET', 'POST'])@login_requireddef send_message(recipient): user = db.first_or_404(sa.select(User).where(User.username == recipient)) form = MessageForm() if form.validate_on_submit(): msg = Message(author=current_user, recipient=user, body=form.message.data) db.session.add(msg) db.session.commit() flash(_('Your message has been sent.')) return redirect(url_for('main.user', username=recipient)) return render_template('send_message.html', title=_('Send Message'), form=form, recipient=recipient) 我認為這個視圖函式中的邏輯應該大部分是不言自明的。發送私人訊息的動作僅僅是通過向數據庫加入一個新的 Message 實例來實現的。 將所有內容綁定在一起的最後更改是在使用者個人檔案頁面中加入到上述路由的連結： 12345678910app/templates/user.html: 使用者個人檔案頁面中發送私人訊息連結。 {% if user != current_user %} &lt;p&gt; &lt;a href=&quot;{{ url_for('main.send_message', recipient=user.username) }}&quot;&gt; {{_('Send private message') }} &lt;/a&gt; &lt;/p&gt; {% endif %} 查看私人訊息這個功能的第二大部分是查看私人訊息。為此，我將新增一個 /messages 路由，其工作方式與索引和探索頁面相當類似，包括完整的分頁支援： 12345678910111213141516171819app/main/routes.py: 查看訊息路由。@bp.route('/messages')@login_requireddef messages(): current_user.last_message_read_time = datetime.now(timezone.utc) db.session.commit() page = request.args.get('page', 1, type=int) query = current_user.messages_received.select().order_by( Message.timestamp.desc()) messages = db.paginate(query, page=page, per_page=current_app.config['POSTS_PER_PAGE'], error_out=False) next_url = url_for('main.messages', page=messages.next_num) \\ if messages.has_next else None prev_url = url_for('main.messages', page=messages.prev_num) \\ if messages.has_prev else None return render_template('messages.html', messages=messages.items, next_url=next_url, prev_url=prev_url) 這個視圖函式中的第一件事是將 User.last_message_read_time 字段更新為當前時間。這基本上標記了發送給該使用者的所有訊息為已讀。然後我查詢 Message 模型以獲取訊息列表，按時間戳從新到舊排序。我決定在這裡重用 POSTS_PER_PAGE 配置項，因為帶有貼文和訊息的頁面看起來會非常相似，但當然，如果頁面要分開，加入一個單獨的配置變數用於訊息可能是有意義的。分頁邏輯與我用於貼文的相同，所以這對你來說應該都是熟悉的。 上述視圖函式最後通過渲染一個新的 /app/templates/messages.html 範本檔案結束，如下所示： 123456789101112131415161718192021222324app/templates/messages.html: 查看訊息 HTML 範本。{% extends &quot;base.html&quot; %}{% block app_content %} &lt;h1&gt;{{ _('Messages') }}&lt;/h1&gt; {% for post in messages %} {% include '_post.html' %} {% endfor %} &lt;nav aria-label=&quot;...&quot;&gt; &lt;ul class=&quot;pager&quot;&gt; &lt;li class=&quot;previous{% if not prev_url %} disabled{% endif %}&quot;&gt; &lt;a href=&quot;{{ prev_url or'#'}}&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;larr;&lt;/span&gt; {{ _('Newer messages') }} &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;next{% if not next_url %} disabled{% endif %}&quot;&gt; &lt;a href=&quot;{{ next_url or'#'}}&quot;&gt; {{_('Older messages') }} &lt;span aria-hidden=&quot;true&quot;&gt;&amp;rarr;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;{% endblock %} 這裡我使用了另一個小技巧。我注意到 Post 和 Message 實例的結構幾乎相同，除了 Message 獲得了一個額外的 recipient 關係（在訊息頁面中我不需要顯示，因為它始終是當前使用者）。所以我決定重用 app/templates/_post.html 子範本來渲染私人訊息。因此，這個範本使用了奇怪的 for-loop for post in messages，這樣子範本中對 post 的所有引用也適用於訊息。 為了讓使用者訪問新的視圖函式，導航頁面獲得了一個新的「訊息」連結： 1234567891011121314app/templates/base.html: 導航欄中的訊息連結。 {% if current_user.is_anonymous %} ... {% else %} &lt;li&gt; &lt;a href=&quot;{{ url_for('main.messages') }}&quot;&gt; {{_('Messages') }} &lt;/a&gt; &lt;/li&gt; ... {% endif %} 功能現在已經完成，但作為所有這些變更的一部分，有一些新的文本被加入在幾個地方，這些需要被納入語言翻譯。第一步是更新所有語言目錄： 1(venv) $ flask translate update 然後，app/translations 中的每種語言都需要更新其 messages.po 檔案以包含新的翻譯。你可以在這個項目的 GitHub 倉庫或下載的壓縮檔中找到西班牙語翻譯。 靜態訊息通知徽章現在私人訊息功能已經實現了，但當然沒有任何東西告訴使用者有私人訊息在等待被讀取。最簡單的導航欄指示器實現可以作為基本範本的一部分渲染，使用 Bootstrap 徽章小部件： 12345678910111213app/templates/base.html: 導航欄中的靜態訊息數量徽章。 ... &lt;li&gt; &lt;a href=&quot;{{ url_for('main.messages') }}&quot;&gt; {{_('Messages') }} {% set unread_message_count = current_user.unread_message_count() %} {% if unread_message_count %} &lt;span class=&quot;badge&quot;&gt;{{ unread_message_count }}&lt;/span&gt; {% endif %} &lt;/a&gt; &lt;/li&gt; ... 這裡我直接從範本中調用了我之前加入到 User 模型的 unread_message_count() 方法，並將該數字存儲在一個同名的範本變數中。然後，如果該變數非零，我就在「訊息」連結旁邊加入徽章與數字。這是頁面上的外觀： 訊息徽章 動態訊息通知徽章上一節中提出的解決方案是顯示通知的一種體面且簡單的方法，但它的缺點是徽章只有在加載新頁面時才會出現。如果使用者花很長時間閱讀一頁上的內容而不點擊任何連結，那麼在這段時間內來的新訊息將不會顯示，直到使用者最終點擊連結並加載新頁面。 為了讓這個應用對我的使用者更有用，我希望徽章可以自己更新未讀訊息的數量，無需使用者點擊連結和加載新頁面。上一節解決方案的一個問題是，當頁面加載時訊息數量為非零時，徽章才會被渲染到頁面上。更方便的是，總是在導航欄中包含徽章，並在訊息數量為零時將其標記為隱藏。這樣使用 JavaScript 使徽章可見就很容易了： 123456789101112131415app/templates/base.html: 對 JavaScript 友好的未讀訊息徽章。 &lt;li&gt; &lt;a href=&quot;{{ url_for('main.messages') }}&quot;&gt; {{_('Messages') }} {% set unread_message_count = current_user.unread_message_count() %} &lt;span id=&quot;message_count&quot; class=&quot;badge&quot; style=&quot;visibility: {% if unread_message_count %}visible {% else %}hidden {% endif %};&quot;&gt; {{unread_message_count}} &lt;/span&gt; &lt;/a&gt; &lt;/li&gt; 在這個徽章版本中，我總是包含它，但當 unread_message_count 非零時，CSS 的 visibility 屬性設置為 visible，如果是零則設為 hidden。我還給表示徽章的 &lt;span&gt; 元素加入了一個 id 屬性，以便使用 document.getElementById('message_count') 輕鬆定位這個元素。 接下來，我可以編寫一個簡短的 JavaScript 函式來更新這個徽章的數字： 1234567891011121314app/templates/base.html: 導航欄中的靜態訊息數量徽章。...{% block scripts %} &lt;script&gt; // ... function set_message_count(n) { const count = document.getElementById('message_count'); count.innerText = n; count.style.visibility = n ? 'visible' : 'hidden'; } &lt;/script&gt;{% endblock %} 這個新的 set_message_count() 函式將設置徽章元素中的訊息數量，並調整可見性，使得當計數為 0 時徽章被隱藏，否則可見。 將通知傳遞給客戶端現在剩下的是新增一個機制，使客戶端可以定期獲取使用者未讀訊息數量的更新。當其中一次更新發生時，客戶端將調用 set_message_count() 函式，以讓使用者知道更新。 實際上有兩種方法讓伺服器將這些更新傳遞給客戶端，你可能已經猜到了，兩者都有優缺點，所以選擇哪一個在很大程度上取決於項目。在第一種方法中，客戶端定期向伺服器請求更新，通過發送一個異步請求。這個請求的回應是一個更新列表，客戶端可以使用它來更新頁面的不同元素，例如未讀訊息數量徽章。第二種方法需要客戶端和伺服器之間的一種特殊連接，允許伺服器自由地將數據推送到客戶端。注意，無論選擇哪種方法，我都希望將通知視為通用實體，以便我可以擴展這個框架以支持未讀訊息徽章之外的其他類型事件。 第一種解決方案最大的優點是它易於實現。我所需要做的就是再新增一個路由到應用中，比如 /notifications，它返回一個 JSON 格式的通知列表。然後客戶端應用遍歷通知列表，並為每一個進行必要的頁面更改。這個解決方案的缺點是實際事件和通知之間會有延遲，因為客戶端將定期請求通知列表。例如，如果客戶端每 10 秒請求一次通知，則通知可能會延遲最多 10 秒收到。 第二種解決方案需要在協議層面進行更改，因為 HTTP 沒有任何規定允許伺服器在客戶端未請求的情況下向客戶端發送數據。目前最常見的實現伺服器主動發送訊息的方式是通過擴展伺服器以支持 WebSocket 連接以及 HTTP。WebSocket 是一種與 HTTP 不同的協議，它建立了伺服器和客戶端之間的永久連接。伺服器和客戶端都可以隨時向對方發送數據，無需對方請求。這種機制的優點是，每當發生客戶端感興趣的事件時，伺服器可以立即發送通知，無需任何延遲。缺點是，WebSocket 比 HTTP 需要更複雜的設置，因為伺服器需要與每個客戶端保持永久連接。想象一下，一個伺服器例如有四個工作進程，通常可以服務幾百個 HTTP 客戶端，因為 HTTP 中的連接是短暫的，並且不斷被回收。同一伺服器只能處理四個 WebSocket 客戶端，在絕大多數情 況下這將是不夠的。正是由於這個限制，WebSocket 應用通常圍繞異步伺服器設計，因為這些伺服器在管理大量工作人員和活動連接方面更有效率。 好消息是，無論你使用哪種方法，在客戶端你都會有一個回調函式，將被更新列表調用。所以我可以從第一種解決方案開始，這種方法更容易實現，然後，如果我發現它不夠用，遷移到 WebSocket 伺服器，它可以配置為調用相同的客戶端回調。在我看來，對於這類應用，第一種解決方案實際上是可以接受的。基於 WebSocket 的實現對於需要將更新以接近零延遲的方式交付的應用程式會很有用。 如果你好奇的話，Twitter 也使用第一種方法來處理他們導航欄的通知。Facebook 使用它的一種變體稱為長輪詢，這在一定程度上解決了直接輪詢的一些限制，同時仍然使用 HTTP 請求。Stack Overflow 和 Trello 是兩個實現 WebSocket 用於他們通知的網站。你可以通過查看瀏覽器的網絡調試器中的網絡標籤來找出任何網站上發生的背景活動類型。 那麼，讓我們繼續實施輪詢解決方案。首先，我將新增一個新模型來跟踪所有使用者的通知，以及在使用者模型中新增一個關係。 1234567891011121314151617181920212223242526app/models.py: 通知模型。import jsonfrom time import time## ...class User(UserMixin, db.Model): ## ... notifications: so.WriteOnlyMapped['Notification'] = so.relationship( back_populates='user') ## ...class Notification(db.Model): id: so.Mapped[int] = so.mapped_column(primary_key=True) name: so.Mapped[str] = so.mapped_column(sa.String(128), index=True) user_id: so.Mapped[int] = so.mapped_column(sa.ForeignKey(User.id), index=True) timestamp: so.Mapped[float] = so.mapped_column(index=True, default=time) payload_json: so.Mapped[str] = so.mapped_column(sa.Text) user: so.Mapped[User] = so.relationship(back_populates='notifications') def get_data(self): return json.loads(str(self.payload_json)) 一個通知將會有一個名稱、一個關聯的使用者、一個 Unix 時間戳和一個有效負載。時間戳的默認值來自 time.time() 函式。有效負載對於每種類型的通知來說將會不同，所以我將其寫為 JSON 字符串，這將允許我寫入列表、字典或單個值，如數字或字符串。我加入了 get_data() 方法作為一種遍歷，這樣調用者不必擔心 JSON 反序列化。 這些更改需要包含在一個新的數據庫遷移中： 12(venv) $ flask db migrate -m &quot;notifications&quot;(venv) $ flask db upgrade 為了方便起見，我將把新的 Message 和 Notification 模型加入到 shell 上下文中，這樣當我使用 `fl ask shell` 命令啟動一個 shell 時，模型類自動為我導入： 1234567891011microblog.py: 將 Message 模型加入到 shell 上下文。## ...from app.models import User, Post, Message, Notification## ...@app.shell_context_processordef make_shell_context(): return {'sa': sa, 'so': so, 'db': db, 'User': User, 'Post': Post, 'Message': Message, 'Notification': Notification} 我還將在使用者模型中新增一個 add_notification() 輔助方法，以便更容易地使用這些對象： 1234567891011app/models.py: 通知模型。class User(UserMixin, db.Model): ## ... def add_notification(self, name, data): db.session.execute(self.notifications.delete().where( Notification.name == name)) n = Notification(name=name, payload_json=json.dumps(data), user=self) db.session.add(n) return n 這個方法不僅為使用者新增了一個通知到數據庫，還確保如果已經存在同名的通知，首先將其刪除。你之前已經看到，可以通過調用 select() 方法來查詢僅寫入關係。delete() 方法返回一個刪除查詢，用於關係，它可以刪除所有元素而不加載它們。通過加入 where() 子句，我指定了我想刪除關係中的哪些元素。我將要處理的通知將被稱為 unread_message_count。如果數據庫已經有一個名為此的通知，例如，具有 3 的值，每當使用者收到一條新訊息且訊息計數增加到 4 時，我想替換舊的通知。 在未讀訊息計數變化的任何地方，我需要調用 add_notification()，以便我為使用者更新我的通知。有兩個地方這個變化。首先，當使用者收到一條新的私人訊息時，在 send_message() 視圖函式中： 12345678910111213app/main/routes.py: 更新使用者通知。@bp.route('/send_message/&lt;recipient&gt;', methods=['GET', 'POST'])@login_requireddef send_message(recipient): ## ... if form.validate_on_submit(): ## ... user.add_notification('unread_message_count', user.unread_message_count()) db.session.commit() ## ... ## ... 我需要通知使用者的第二個地方是當使用者訪問訊息頁面時，此時未讀計數回歸零： 123456789app/main/routes.py: 查看訊息路由。@bp.route('/messages')@login_requireddef messages(): current_user.last_message_read_time = datetime.utcnow() current_user.add_notification('unread_message_count', 0) db.session.commit() ## ... 現在所有使用者的通知都在數據庫中維護好了，我可以新增一個新路由，客戶端可以用它來檢索已登入使用者的通知： 123456789101112131415161718app/main/routes.py: 通知視圖函式。from app.models import Notification## ...@bp.route('/notifications')@login_requireddef notifications(): since = request.args.get('since', 0.0, type=float) query = current_user.notifications.select().where( Notification.timestamp &gt; since).order_by(Notification.timestamp.asc()) notifications = db.session.scalars(query) return [{ 'name': n.name, 'data': n.get_data(), 'timestamp': n.timestamp } for n in notifications] 這是一個相當簡單的函式，返回一個 JSON 負載，包含使用者的通知列表。每個通知以一個字典形式給出， 有三個元素，通知名稱、與通知相關的附加數據（如訊息計數），以及時間戳。通知按它們建立的順序交付，從最舊到最新。 我不希望客戶端獲得重複的通知，所以我給他們提供了一個選項，僅請求給定時間之後的通知。since 選項可以包含在請求 URL 的查詢字符串中，使用起始時間的 Unix 時間戳，作為一個浮點數。如果包含此參數，則僅返回此時間之後發生的通知。 完成這個功能的最後一步是在客戶端實現實際的輪詢。最好的地方是在基本範本中進行，這樣所有頁面自動繼承該行為： 1234567891011121314151617181920212223app/templates/base.html: 輪詢通知。...{% block scripts %} &lt;script&gt; // ... {% if current_user.is_authenticated %} function initialize_notifications() { let since = 0; setInterval(async function() { const response = await fetch('{{ url_for('main.notifications') }}?since=' + since); const notifications = await response.json(); for (let i = 0; i &lt; notifications.length; i++) { if (notifications[i].name == 'unread_message_count') set_message_count(notifications[i].data); since = notifications[i].timestamp; } }, 10000); } document.addEventListener('DOMContentLoaded', initialize_notifications); {% endif %} &lt;/script&gt; 這個函式被包含在一個範本條件中，因為我只想在使用者登入時進行新訊息的輪詢。對於未登入的使用者，這個函式不會被包含，因為他們不能接收通知。 你已經在第 20 章看到了 DOMContentLoaded 事件。這是你註冊一個在頁面加載後執行的函式的方式。對於這個功能，我需要在頁面加載時做的是設置一個定時器，獲取使用者的通知。你也看到了 JavaScript 函式 setTimeout()，它在指定時間過後運行給定的函式。setInterval() 函式使用與 setTimeout() 相同的參數，但不是只觸發一次計時器，它會定期調用回調函式。在這種情況下，我的間隔設置為 10 秒（以毫秒為單位），所以我將以每分鐘大約六次的頻率看到徽章更新。 與間隔計時器相關的函式使用 fetch() 發出一個 Ajax 請求到新的通知路由。當這個調用返回時，它遍歷通知列表。當收到名稱為 unread_message_count 的通知時，通過調用上面定義的函式並給出通知中的計數來調整訊息計數徽章。 我處理 since 參數的方式可能會讓人感到困惑。我開始時將這個參數初始化為 0。這個參數總是包含在請求 URL 中，但我不能使用 Flask 的 url_for() 來生成查詢字符串，就像我之前做的那樣，因為 url_for() 在伺服器上運行一次，我需要 since 參數動態更新。第 一次，請求將被發送到 /notifications?since=0，但一旦我收到一個通知，我就將 since 更新為它的時間戳。這確保了我不會收到重複的通知，因為我總是要求接收自我看到的最後一個通知以來發生的通知。同樣重要的是要注意，我在間隔函式外聲明了 since 變數，因為我不希望這是一個局部變數，我希望在所有調用中使用同一個變數。 試用這個功能的最簡單方法是使用兩個不同的瀏覽器。在兩個瀏覽器中使用不同的使用者登入 Microblog。然後從其中一個瀏覽器向另一個使用者發送一條或多條訊息。另一個瀏覽器的導航欄應該在不到 10 秒內更新以顯示你發送的訊息數量。當你點擊「訊息」連結時，未讀訊息計數重置回零。","link":"/python/flask-mega-tutorial/chapter_21_user_notifications.html"},{"title":"","text":"Chapter 22: Background Jobs Posted by on Miguel Grinberg 這是 Flask Mega-Tutorial 系列的第二十二篇，在這篇中，我將告訴你如何建立獨立於網頁伺服器運行的背景任務。 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 這一章專門介紹需要作為應用程式一部分運行的長時間或複雜過程。這些過程不能在請求的上下文中同步執行，因為那會在任務執行期間阻塞對客戶端的響應。我在第十章簡要提到了這個話題，當時我將發送電子郵件的工作移至背景執行緒中，以防止客戶端在發送電子郵件所需的那 3-4 秒內需要等待。雖然對於電子郵件使用執行緒是可接受的，但當問題中的過程更長時，這種解決方案並不適合擴展。公認的做法是將長時間任務卸載給工作進程，或更可能是給它們的一個池。 為了證明需要長時間運行任務的必要性，我將向 Microblog 引入一個匯出功能，通過該功能使用者將能夠請求一個包含他們所有部落格貼文的數據檔案。當使用者使用這個選項時，應用程式將啟動一個匯出任務，該任務將生成一個包含所有使用者貼文的 JSON 檔案，然後通過電子郵件將其發送給使用者。所有這些活動都將在一個工作進程中發生，而在此期間，使用者將看到顯示完成百分比的通知。 這一章的 GitHub 連結為：瀏覽、壓縮檔、差異。 任務隊列簡介任務隊列為應用程式提供了一個方便的解決方案，以請求工作進程執行任務。工作進程獨立於應用程式運行，甚至可以位於不同的系統上。應用程式和工作進程之間的通信是通過消息隊列完成的。應用程式提交一個任務，然後通過與隊列互動來監控其進度。下面的圖示顯示了一個典型的實現： 任務隊列圖示 對於 Python 來說，最受歡迎的任務隊列是 Celery。這是一個相當複雜的包，有許多選項，支持幾種消息隊列。另一個受歡迎的 Python 任務隊列是 Redis Queue 或僅 RQ，它犧牲了一些靈活性，如只支援 Redis 消息隊列，但相應地設置起來要比 Celery 簡單得多。 Celery 和 RQ 都非常適合支援 Flask 應用程式中的背景任務，所以我對這 個應用程式的選擇將偏向於 RQ 的簡單性。然而，用 Celery 實現相同的功能應該相對容易。如果你對 Celery 比 RQ 更感興趣，你可以閱讀我在我的部落格上的文章 《使用 Flask 與 Celery》。 使用 RQRQ 是一個標準的 Python 套件，可以透過 pip 安裝： 12(venv) $ pip install rq(venv) $ pip freeze &gt; requirements.txt 如我先前提到的，應用程式與 RQ 工作者之間的通訊將透過 Redis 訊息隊列進行，所以你需要有一個運行中的 Redis 伺服器。有很多選項可以安裝並啟動 Redis 伺服器，從一鍵安裝程式到直接在你的系統上下載原始碼並編譯。如果你使用 Windows，微軟在這裡維護安裝程式。在 Linux 上，你可能可以透過作業系統的套件管理器獲得它，macOS 使用者可以執行 brew install redis 然後手動用 redis-server 命令啟動服務。 你根本不需要與 Redis 互動，只需確保服務正在運行且 RQ 可以訪問即可。 注意，RQ 不運行在 Windows 原生的 Python 解譯器上。如果你使用 Windows 平台，你只能在 Unix 模擬層下運行 RQ。我推薦給 Windows 使用者的兩個 Unix 模擬層是 Cygwin 和 Windows 子系統 for Linux (WSL)，它們都與 RQ 兼容。 建立一個任務我將向你展示如何透過 RQ 執行一個簡單的任務，讓你熟悉它。一個任務，不過就是一個 Python 函式。這裡是一個範例任務，我將把它放在一個新的 app/tasks.py 模組中： 12345678910## app/tasks.py: 範例背景任務。import timedef example(seconds): print('Starting task') for i in range(seconds): print(i) time.sleep(1) print('Task completed') 這個任務接受一個秒數作為參數，然後等待那麼長的時間，每秒打印一次計數器。 運行 RQ 工作者現在任務準備好了，可以啟動一個工作者。這是用 rq worker 命令完成的： 12345(venv) $ rq worker microblog-tasks18:55:06 RQ worker 'rq:worker:miguelsmac.90369' started, version 0.9.118:55:06 Cleaning registries for queue: microblog-tasks18:55:0618:55:06 *** Listening on microblog-tasks... 工作者進程現在連接到 Redis，並等待在名為 microblog-tasks 的隊列上分配給它的任何工作。如果你想要擁有更多的工作者以提高吞吐量，你需要做的就是運行更多的 rq worker 實例，所有這些都連接到同一個隊列。然後當隊列中出現一個工作時，任何一個可用的工作進程都會接手它。在生產環境中，你可能會想要至少擁有和可用 CPU 一樣多的工作者。 執行任務現在打開第二個終端窗口並啟動虛擬環境。我將使用一個 shell 會話來啟動工作者中的 example() 任務： 123456&gt;&gt;&gt; from redis import Redis&gt;&gt;&gt; import rq&gt;&gt;&gt; queue = rq.Queue('microblog-tasks', connection=Redis.from_url('redis://'))&gt;&gt;&gt; job = queue.enqueue('app.tasks.example', 23)&gt;&gt;&gt; job.get_id()'c651de7f-21a8-4068-afd5-8b982a6f6d32' RQ 的 Queue 類別代表從應用程式側看到的任務隊列。它接受的參數是隊列名稱和一個 Redis 連接物件，在這個案例中我用一個預設的 URL 來初始化它。如果你的 Redis 伺服器運行在不同的主機或端口號上，你將需要使用不同的 URL。 隊列上的 enqueue() 方法用於加入一個工作到隊列中。第一個參數是你想要執行的任務名稱，直接作為一個函式物件給出，或作為一個導入字串。我發現字串選項更方便，因為這樣就不需要在應用程式的側導入函式了。給 enqueue() 的任何剩餘參數都將被傳遞給在工作者中運行的函式。 當你進行 enqueue() 調用時，你將會注意到你的第一個終端窗口，運行 RQ 工作者的那個，出現了一些活動。你會看到 example() 函式現在正在運行，並且每秒打印一次計數器。同時，你的另一個終端不會被阻塞，你可以繼續在 shell 中評估表達式。在上面的例子中，我調用了 job.get_id() 方法來獲取分配給任務的唯一標識符。你可以嘗試的另一個有趣的表達式是檢查工作者上的函式是否已經完成： 12&gt;&gt;&gt; job.is_finishedFalse 如果你像我在我的例子上傳遞了一個 23，那麼函式將運行大約 23 秒。之後，job.is_finished 表達式將變為 True。這不是很酷嗎？我真的很喜歡 RQ 的簡單性。 一旦函式完成，工作者就會回到等待新工作的狀態，所以如果你想要進一步實驗，可以重複 enqueue() 調用並給出不同的參數。關於任務在隊列中存儲的資料將會保留一段時間（預設是 500 秒），但最終會被移除。這很重要，任務隊列不保留已執行工作的歷史記錄。 報告任務進度我上面使用的範例任務過於簡單了。通常，對於一個長時間運行的任務，你會希望有某種進度資訊可以提供給應用程式，進而顯示給使用者。RQ 通過使用工作物件的 meta 屬性來支持這一點。讓我重寫 example() 任務來寫進度報告： 12345678910111213141516## app/tasks.py: 帶進度的範例背景任務。import timefrom rq import get_current_jobdef example(seconds): job = get_current_job() print('開始任務') for i in range(seconds): job.meta['progress'] = 100.0 * i / seconds job.save_meta() print(i) time.sleep(1) job.meta['progress'] = 100 job.save_meta() print('任務完成') 這個新版本的 example() 使用 RQ 的 get_current_job() 函式來獲取一個工作實例，這與應用程式提交任務時返回的實例相似。工作物件的 meta 屬性是一個字典，任務可以在其中寫入它想要通訊給應用程式的任何自定義資料。在這個範例中，我寫入了一個表示任務完成百分比的進度項目。每次更新進度時我都呼叫 job.save_meta()，指示 RQ 將資料寫入 Redis，應用程式可以在那裡找到它。 在應用程式側（目前僅是一個 Python shell），我可以運行這個任務然後如下監控進度： 1234567891011121314&gt;&gt;&gt; job = queue.enqueue('app.tasks.example', 23)&gt;&gt;&gt; job.meta{}&gt;&gt;&gt; job.refresh()&gt;&gt;&gt; job.meta{'progress': 13.043478260869565}&gt;&gt;&gt; job.refresh()&gt;&gt;&gt; job.meta{'progress': 69.56521739130434}&gt;&gt;&gt; job.refresh()&gt;&gt;&gt; job.meta{'progress': 100}&gt;&gt;&gt; job.is_finishedTrue 如你所見，在這邊，meta 屬性可以讀取。需要呼叫 refresh() 方法來從 Redis 更新內容。 任務的資料庫表示對於上述範例，啟動一個任務並觀看它運行已經足夠。對於一個網頁應用程式來說，事情會變得更複雜一些，因為一旦這些任務作為請求的一部分啟動，那個請求將會結束，並且所有關於該任務的上下文將會丟失。因為我希望應用程式能夠跟踪每個使用者正在運行什麼任務，我需要使用一個資料庫表來維持一些狀態。下面你可以看到新的 Task 模型實現： 123456789101112131415161718192021222324252627282930313233## app/models.py: Task 模型。## ...import redisimport rqclass User(UserMixin, db.Model): ## ... tasks: so.WriteOnlyMapped['Task'] = so.relationship(back_populates='user')## ...class Task(db.Model): id: so.Mapped[str] = so.mapped_column(sa.String(36), primary_key=True) name: so.Mapped[str] = so.mapped_column(sa.String(128), index=True) description: so.Mapped[Optional[str]] = so.mapped_column(sa.String(128)) user_id: so.Mapped[int] = so.mapped_column(sa.ForeignKey(User.id)) complete: so.Mapped[bool] = so.mapped_column(default=False) user: so.Mapped[User] = so.relationship(back_populates='tasks') def get_rq_job(self): try: rq_job = rq.job.Job.fetch(self.id, connection=current_app.redis) except (redis.exceptions.RedisError, rq.exceptions.NoSuchJobError): return None return rq_job def get_progress(self): job = self.get_rq_job() return job.meta.get('progress', 0) if job is not None else 100 這個模型與先前的模型之間一個有趣的區別是，id 主鍵欄位是一個字串，而不是一個整數。這是因為對於這個模型，我不會依賴資料庫自己的主鍵生成，而是將使用 RQ 生成的工作識別符。 這個模型將儲存任務的完全限定名（如傳給 RQ 的），一個適合顯示給使用者的任務描述，一個與請求任務的使用者的關聯，以及一個指示任務是否完成的布林值。complete 欄位的目的是為了將結束的任務與正在積極運行的任務分開，因為運行中的任務需要特殊處理以顯示進度更新。 get_rq_job() 方法是一個輔助方法，它從給定的任務 id 加載 RQ Job 實例，我可以從模型獲得這個 id。這是通過 Job.fetch() 完成的，它從 Redis 中關於它的數據加載 Job 實例。get_progress() 方法建立在 get_rq_job() 之上，返回任務的進度百分比。這個方法有一些有趣的假設。如果模型中的工作 id 不存在於 RQ 隊列中，那意味著該工作已經完成，數據過期並且從隊列中移除了，所以在那種情況下返回的百分比是 100。在另一個極端，如果工作存在，但沒有與 meta 屬性關聯的資訊，那麼可以安全地假設該工作已經排程運行，但還沒有機會開始，所以在那種情況下進度返回為 0。 要應用對資料庫架構的更改，需要生成一個新的遷移，然後升級資料庫： 12(venv) $ flask db migrate -m &quot;tasks&quot;(venv) $ flask db upgrade 新模型也可以加入到 shell 上下文中，使其在 shell 會話中無需導入即可訪問： 12345678910111213## microblog.py: 將 Task 模型加入到 shell 上下文。import sqlalchemy as saimport sqlalchemy.orm as sofrom app import create_app, dbfrom app.models import User, Post, Message, Notification, Taskapp = create_app()@app.shell_context_processordef make_shell_context(): return {'sa': sa, 'so': so, 'db': db, 'User': User, 'Post': Post, 'Message': Message, 'Notification': Notification, 'Task': Task} 整合 RQ 與 Flask 應用程式需要將 Redis 服務的連線 URL 加入到配置中： 123class Config(object): ## ... REDIS_URL = os.environ.get('REDIS_URL') or 'redis://' 一如既往，Redis 連線 URL 將從環境變數中獲取，如果變數未定義，將使用一個預設 URL，假設服務運行在同一主機上並使用預設端口。 應用程式工廠函式將負責初始化 Redis 和 RQ： 1234567891011121314## app/__init__.py: RQ 整合。## ...from redis import Redisimport rq## ...def create_app(config_class=Config): ## ... app.redis = Redis.from_url(app.config['REDIS_URL']) app.task_queue = rq.Queue('microblog-tasks', connection=app.redis) ## ... app.task_queue 將是提交任務的隊列。將隊列附加到應用程式上很方便，因為在應用程式的任何地方我都可以使用 current_app.task_queue 來訪問它。為了讓應用程式的任何部分都能輕鬆地提交或檢查任務，我可以在 User 模型中建立一些輔助方法： 1234567891011121314151617181920212223## app/models.py: User 模型中的任務輔助方法。## ...class User(UserMixin, db.Model): ## ... def launch_task(self, name, description, *args, **kwargs): rq_job = current_app.task_queue.enqueue(f'app.tasks.{name}', self.id, *args, **kwargs) task = Task(id=rq_job.get_id(), name=name, description=description, user=self) db.session.add(task) return task def get_tasks_in_progress(self): query = self.tasks.select().where(Task.complete == False) return db.session.scalars(query) def get_task_in_progress(self, name): query = self.tasks.select().where(Task.name == name, Task.complete == False) return db.session.scalar(query) launch_task() 方法負責將任務提交到 RQ 隊列，同時將其加入到資料庫中。name 參數是函式名稱，如在 app/tasks.py 中定義的。提交到 RQ 時，函式將 app.tasks. 預置於此名稱之前，以構建完全限定的函式名稱。description 參數是可以呈現給使用者的任務友好描述。對於將要導出博客帖子的函式，我將設定名稱為 export_posts，描述為 “導出帖子…”。剩餘的參數是位置和關鍵字參數，將傳遞給任務。函式首先呼叫隊列的 enqueue() 方法提交工作。返回的工作物件包含 RQ 分配的任務 id，因此我可以使用它來在我的資料庫中建立一個對應的 Task 物件。 注意，launch_task() 將新的任務物件加入到會話中，但它不發出提交。一般來說，最好在更高層函式中操作資料庫會話，這樣可以將由低層函式所做的幾個更新結合在一個事務中。這不是一條嚴格的規則，事實上，你將在本章後面看到一個例外，其中在子函式中發出了提交。 get_tasks_in_progress() 方法返回對於使用者來說尚未 完成的所有函式的完整列表。你將看到我稍後使用這個方法在渲染給使用者的頁面中包括關於運行中任務的資訊。 最後，get_task_in_progress() 是前一個的簡化版本，返回一個特定任務。我阻止使用者同時啟動兩個或更多同類型的任務，因此在我啟動任務之前，我可以使用這個方法來找出是否有之前的任務正在運行。 從 RQ 任務發送電子郵件這可能看起來像是偏離主題，但我上面提到，當背景導出任務完成時，將向使用者發送包含所有帖子的 JSON 文件的電子郵件。我在第 11 章構建的電子郵件功能需要以兩種方式擴展。首先，我需要加入對文件附件的支持，以便我可以附加一個 JSON 文件。其次，send_email() 函式總是異步發送電子郵件，使用一個背景執行緒。當我要從一個背景任務發送電子郵件時，這已經是異步的，基於執行緒的第二層背景任務就顯得沒有多大意義，所以我需要支持同步和異步發送電子郵件。 幸運的是，Flask-Mail 支持附件，所以我所需要做的就是擴展 send_email() 函式以在額外的參數中接受它們，然後在 Message 物件中配置它們。而要選擇性地在前台發送電子郵件，我只需要加入一個布林型的 sync 參數： 1234567891011121314151617## app/email.py: 帶附件發送電子郵件。## ...def send_email(subject, sender, recipients, text_body, html_body, attachments=None, sync=False): msg = Message(subject, sender=sender, recipients=recipients) msg.body = text_body msg.html = html_body if attachments: for attachment in attachments: msg.attach(*attachment) if sync: mail.send(msg) else: Thread(target=send_async_email, args=(current_app._get_current_object(), msg)).start() Message 類的 attach() 方法接受三個定義附件的參數：文件名、媒體類型和實際的文件數據。文件名只是收件人看到的與附件相關的名稱，它不需要是一個真實的文件。媒體類型定義了這是什麼類型的附件，這有助於電子郵件閱讀器適當地渲染它。例如，如果你發送 image/png 作為媒體類型，電子郵件閱讀器會知道附件是一張圖片，在這種情況下它可以這樣顯示。對於博客帖子數據文件，我將使用 JSON 格式，使用 application/json 媒體類型。第三個也是最後一個參數是帶有附件內容的字串或字節序列。 為了簡化，send_email() 的 attachments 參數將是一個元組列表，每個元組將有三個元素，對應於 attach() 的三 個參數。因此，對於這個列表中的每個元素，我需要將元組作為參數發送給 attach()。在 Python 中，如果你有一個列表或元組帶有你想要發送給一個函式的參數，你可以使用 func(*args) 來將該列表展開為實際的參數列表，而不是使用更繁瑣的語法如 func(args[0], args[1], args[2])。所以例如，如果你有 args = [1, 'foo']，調用將發送兩個參數，就像你調用 func(1, 'foo') 一樣。沒有 *，調用將有一個參數，將是列表。 至於同步發送電子郵件，我需要做的就是當 sync 為 True 時直接回退到調用 mail.send(msg)。 任務輔助函式雖然我上面使用的 example() 任務是一個簡單的獨立函式，導出博客帖子的函式將需要我在應用程式中的一些功能，如訪問資料庫和發送電子郵件的函式。因為這將在一個獨立的進程中運行，我需要初始化 Flask-SQLAlchemy 和 Flask-Mail，這又需要一個 Flask 應用實例來獲取它們的配置。所以我將在 app/tasks.py 模組的頂部加入一個 Flask 應用實例和應用上下文： 123456## app/tasks.py: 建立應用和上下文。from app import create_appapp = create_app()app.app_context().push() 這個模組建立應用是因為這是 RQ 工作者將要導入的唯一模組。當你使用 flask 命令時，根目錄中的 microblog.py 模組建立應用，但 RQ 工作者對此一無所知，所以如果任務函式需要它，它需要建立自己的應用實例。你已經在一些地方看到了 app.app_context() 方法，推送一個上下文使應用成為 “當前” 應用實例，這使得擴展如 Flask-SQLAlchemy 能夠使用 current_app.config 來獲取它們的配置。沒有上下文，current_app 表達式將返回一個錯誤。 然後我開始思考我將如何在這個函式運行時報告進度。除了通過 job.meta 字典傳遞進度資訊，我還想將通知推送給客戶端，使得完成百分比可以動態更新，而不需要使用者刷新頁面。為此，我將使用我在第 21 章構建的通知機制。更新將以非常類似於未讀消息徽章的方式工作。當伺服器渲染一個模板時，它將包括從 job.meta 獲得的 “靜態” 進度資訊，但一旦頁面在客戶端的瀏覽器上，通知將通過通知動態更新百分比。因為通知的存在，更新運行中任務 的進度將比我在前一個範例中所做的更複雜，所以我將建立一個專門用於更新進度的封裝函式： 12345678910111213141516171819## app/tasks.py: 設置任務進度。from rq import get_current_jobfrom app import dbfrom app.models import Task## ...def _set_task_progress(progress): job = get_current_job() if job: job.meta['progress'] = progress job.save_meta() task = db.session.get(Task, job.get_id()) task.user.add_notification('task_progress', {'task_id': job.get_id(), 'progress': progress}) if progress &gt;= 100: task.complete = True db.session.commit() 導出任務可以呼叫 _set_task_progress() 來記錄進度百分比。該函式首先將百分比寫入 job.meta 字典並保存到 Redis，然後從資料庫加載相應的任務物件，並使用 task.user 向請求任務的使用者推送一個通知，使用現有的 add_notification() 方法。通知將被命名為 task_progress，與之關聯的資料將是一個包含兩項內容的字典，任務標識符和進度數字。稍後我將加入 JavaScript 程式碼來對這種新的通知類型進行操作。 該函式檢查進度是否表明函式已完成，並在該情況下還將更新資料庫中任務物件的 complete 屬性。資料庫提交呼叫確保立即將任務和由 add_notification() 加入的通知物件一起保存到資料庫。我需要非常小心地設計父任務，以免做出任何資料庫更改，因為這次提交呼叫會寫入那些更改。 實作導出任務現在所有必要的部分都準備就緒，我可以編寫導出函式了。這個函式的高層結構將如下所示： 12345678910## app/tasks.py: 導出帖子的一般結構。def export_posts(user_id): try: ## 從資料庫讀取使用者帖子 ## 將數據透過電子郵件發送給使用者 except Exception: ## 處理意外錯誤 finally: ## 處理清理工作 為什麼要將整個任務包裝在一個 try/except 塊中？存在於請求處理器中的應用程式碼是受到保護的，因為 Flask 本身會捕獲異常，然後根據我為應用程式設置的任何錯誤處理器和日誌配置來處理它們。然而，這個函式將在一個由 RQ 控制、而不是 Flask 控制的獨立進程中運行，所以如果發生任何意外錯誤，任務將中止，RQ 將把錯誤顯示在控制台上，然後回到等待新工作的狀態。所以基本上，除非你正在觀看 RQ 工作者的輸出或將其記錄到文件中，否則你永遠不會發現有錯誤發生。 讓我們從上面帶有注釋的部分開始，處理錯誤處理和最後的清理，這些是最簡單的部分： 12345678910111213## app/tasks.py: 導出帖子的錯誤處理。import sys## ...def export_posts(user_id): try: ## ... except Exception: _set_task_progress(100) app.logger.error('未處理的異常', exc_info=sys.exc_info()) finally: _set_task_progress(100) 每當發生意外錯誤時，我將使用 Flask 應用程式的 logger 物件來記錄錯誤，以及由 sys.exc_info() 調用提供的堆棧跟踪資訊。在這裡使用 Flask 應用程式的 logger 記錄錯誤的好處是，你為 Flask 應用程式實現的任何日誌機制都會被遵守。例如，在第 7 章中，我配置了錯誤發送到管理員電子郵件地址。僅僅通過使用 app.logger，我也獲得了這些錯誤的行為。在 finally 子句中，無論是錯誤還是成功運行，我都將任務標記為完成，進度設置為 100%。 接下來，我將編碼實際的導出操作，它簡單地發出一個資料庫查詢並在循環中遍歷結果，將它們累積在一個字典中： 123456789101112131415161718192021222324252627282930## app/tasks.py: 從資料庫讀取使用者帖子。import timefrom app.models import User, Post## ...def export_posts(user_id): try: user = db.session.get(User, user_id) _set_task_progress(0) data = [] i = 0 total_posts = db.session.scalar(sa.select(sa.func.count()).select_from( user.posts.select().subquery())) for post in db.session.scalars(user.posts.select().order_by( Post.timestamp.asc())): data.append({'body': post.body, 'timestamp': post.timestamp.isoformat() + 'Z'}) time.sleep(5) i += 1 _set_task_progress(100 * i // total_posts) ## 將數據透過電子郵件發送給使用者 except Exception: ## ... finally: ## ... 對於每個帖子，函式將包括一個帶有兩個元素的字典，帖子正文和帖子編寫的時間。時間將按照 ISO 8601 標準寫入。我使用的 Python datetime 物件不存儲時區，所以在我將時間導出為 ISO 格式後，我加入了’Z’，表示 UTC。 由於需要跟踪進度，程式碼變得稍微複雜。我維護計數器 i，並且需要在進入循環之前發出一個額外的資料庫查詢以獲得 total_posts 的數量。使用 i 和 total_posts，每個循環迭代都可以用 0 到 100 的數字更新任務進度。 你可能已經注意到我在每次循環迭代中也加入了一個 time.sleep(5) 調用。我加入 sleep 的主要原因是讓導出任務持續更長時間，即使導出僅涵蓋少量博客帖子時也能看到進度上升。 下面你可以看到函式的最後部分，它將所有在 data 中收集的資訊作為附件通過電子郵件發送給使用者： 123456789101112131415161718192021222324## app/tasks.py: 透過電子郵件將帖子發送給使用者。import jsonfrom flask import render_templatefrom app.email import send_email## ...def export_posts(user_id): try: ## ... send_email( '[Microblog] 你的博客帖子', sender=app.config['ADMINS'][0], recipients=[user.email], text_body=render_template('email/export_posts.txt', user=user), html_body=render_template('email/export_posts.html', user=user), attachments=[('posts.json', 'application/json', json.dumps({'posts': data}, indent=4))], sync=True) except Exception: ## ... finally: ## ... 這純粹是對 send_email() 函式的調用。附件被定義為一個元組，帶有三個元素，然後傳遞給 Flask-Mail 的 Message 物件的 attach() 方法。元組中的第三個元素是附件內容，使用 Python 的 json.dumps() 函式生成。 這裡引用了一對新模板，它們提供了純文本和 HTML 形式的電子郵件正文內容。這是文本模板： 123456789&lt;!-- app/templates/email/export_posts.txt: 導出帖子的文本電子郵件模板。 --&gt;親愛的 {{user.username}}，請查找附件中你要求的帖子存檔。誠摯地，Microblog 團隊 這是電子郵件的 HTML 版本： 123456&lt;!-- app/templates/email/export_posts.html: 導出帖子的 HTML 電子郵件模板。 --&gt;&lt;p&gt; 親愛的 {{ user.username }}，&lt;/p&gt;&lt;p&gt; 請查找附件中你要求的帖子存檔。&lt;/p&gt;&lt;p&gt; 誠摯地，&lt;/p&gt;&lt;p&gt;Microblog 團隊 &lt;/p&gt; 應用程式中的導出功能 所有支持背景導出任務的核心部分現在都就位了。剩下的是將這個功能連接到應用程式，以便使用者可以請求將他們的帖子通過電子郵件發送給他們。 下面你可以看到一個新的 export_posts 視圖函式： 1234567891011## app/main/routes.py: 導出帖子的路由和視圖函式。@bp.route('/export_posts')@login_requireddef export_posts(): if current_user.get_task_in_progress('export_posts'): flash(_('正在進行的導出任務')) else: current_user.launch_task('export_posts', _('導出帖子...')) db.session.commit() return redirect(url_for('main.user', username=current_user.username)) 函式首先檢查使用者是否有未完成的導出任務，如果是，則只顯示一條消息。同時為同一使用者進行兩次導出任務真的沒有意義，因此這是被防止的。我可以使用之前實現的 get_task_in_progress() 方法檢查這個條件。 如果使用者沒有正在進行的導出，則調用 launch_task() 開始一個。第一個參數是將傳遞給 RQ 工作者的函式名稱，前綴為 app.tasks.。第二個參數僅是將顯示給使用者的友好文本描述。這兩個值都被寫入資料庫中的 Task 物件。函式以重定向到使用者個人頁面結束。 現在我需要暴露一個連結到這個路由，使用者可以訪問以請求導出。我認為最合適的地方是在使用者個人頁面，當使用者查看自己的頁面時，可以在 “編輯你的個人資料” 連結下方顯示連結： 12345678910111213141516&lt;!-- app/templates/user.html: 使用者個人頁面中的導出連結。 --&gt; ... &lt;p&gt; &lt;a href=&quot;{{ url_for('main.edit_profile') }}&quot;&gt; {{_('編輯你的個人資料') }} &lt;/a&gt; &lt;/p&gt; {% if not current_user.get_task_in_progress('export_posts') %} &lt;p&gt; &lt;a href=&quot;{{ url_for('main.export_posts') }}&quot;&gt; {{_('導出你的帖子') }} &lt;/a&gt; &lt;/p&gt; ... {% endif %} 這個連結與一個條件綁定，因為我不想在使用者已經有一個進行中的導出時顯示它。 此時，背景工作應該是功能性的，但沒有給使用者任何反饋。如果你想試試，可以如下啟動應用程式和 RQ 工作者： 確保你有運行中的 Redis 在第一個終端窗口，啟動一個或多個 RQ 工作者實例。對此你必須使用命令 rq worker microblog-tasks 在第二個終端窗口，使用 flask run 啟動 Flask 應用程式（記得先設置 FLASK_APP） 進度通知為了完善這個功能，我想在背景任務運行時，包括完成百分比，通知使用者。查看 Bootstrap 組件選項時，我決定在導航欄下方使用一個警告來實現這一點。警告是這些顯示給使用者資訊的彩色水平條。我用藍色警告框來顯示閃現消息。現在我將加入一個綠色的警告框來顯示進度狀態。下面你可以看到它將如何顯示： 進度警告1234567891011121314151617181920&lt;!-- app/templates/base.html: 基礎模板中的導出進度警告。 --&gt;...{% block content %} &lt;div class=&quot;container&quot;&gt; {% if current_user.is_authenticated %} {% with tasks = current_user.get_tasks_in_progress() %} {% if tasks %} {% for task in tasks %} &lt;div class=&quot;alert alert-success&quot; role=&quot;alert&quot;&gt; {{task.description}} &lt;span id=&quot;{{ task.id}}-progress&quot;&gt;{{ task.get_progress() }}&lt;/span&gt;% &lt;/div&gt; {% endfor %} {% endif %} {% endwith %} {% endif %} ...{% endblock %}... 渲染任務警告的方法幾乎與閃現消息一樣。當使用者未登錄時，外部條件跳過所有與警告相關的標記。對於已登錄的使用者，我通過調用我之前建立的 get_tasks_in_progress() 方法來獲取當前進行中的任務列表。在應用程式的當前版本中，我最多只會獲得一個結果，因為我不允許同一時間有多個活動的導出，但未來我可能想要支持可以共存的其他類型的任務，所以以泛化的方式編寫這些程式碼可能以後會節省我時間。 對於每個任務，我在頁面上寫了一個警告元素。警告的顏色由第二個 CSS 樣式控制，在這個案例中是 alert-success，而在閃現消息的案例中是 alert-info。Bootstrap 文件包含了警告的 HTML 結構細節。警告的文本包括存儲在 Task 模型中的描述欄位，後面跟著完成百分比。 百分比被包裹在一個具有 id 屬性的 &lt;span&gt; 元素中。這樣做的原因是我將在收到通知時通過 JavaScript 刷新百分比。我用於給定任務的 id 是構造為任務 id 加上 -progress 結尾。當通知到達時，它將包含任務 id，所以我可以輕鬆地定位正確的 &lt;span&gt; 元素以使用 #&lt;task.id&gt;-progress 選擇器進行更新。 如果此時你嘗試應用程式，你將看到每次你導航到一個新頁面時的 “靜態” 進度更新。你會注意到，在你啟動一個導出任務後，你可以自由地導航到應用程式的不同頁面，並且運行中的任務的狀態總是被回憶起來。 為了準備對百分比 &lt;span&gt; 元素進行動 態更新，我將在 JavaScript 邊編寫一個小幫助函式： 12345678910111213141516&lt;!-- app/templates/base.html: 動態更新任務進度的幫助函式。 --&gt;...{% block scripts %} ... &lt;script&gt; ... function set_task_progress(task_id, progress) { const progressElement = document.getElementById(task_id + '-progress'); if (progressElement) { progressElement.innerText = progress; } } &lt;/script&gt; ...{% endblock %} 這個函式接受一個任務 id 和一個進度值，使用瀏覽器中的 DOM API 定位任務的 &lt;span&gt; 元素，如果該元素存在，則將新的進度作為其新內容寫入。 通知已經到達瀏覽器，因為 app/tasks.py 中的 _set_task_progress() 函式在每次更新進度時都會調用 add_notification()。如果你對這些通知如何到達瀏覽器感到困惑，沒有我做任何事情，那是因為在第 21 章中，我明智地以完全泛化的方式實現了通知功能。任何通過 add_notification() 方法加入的通知，當瀏覽器定期向伺服器請求通知更新時，都會被瀏覽器看到。 但處理這些通知的 JavaScript 程式碼只識別具有 unread_message_count 名稱的通知，並忽略其餘的。現在我需要做的是擴展該函式，也處理 task_progress 通知，通過調用我上面定義的 set_task_progress() 函式。這裡是處理 JavaScript 通知的循環的更新版本： 123456789101112for (let i = 0; i &lt; notifications.length; i++) { switch (notifications[i].name) { case 'unread_message_count': set_message_count(notifications[i].data); break; case 'task_progress': set_task_progress(notifications[i].data.task_id, notifications[i].data.progress); break; } since = notifications[i].timestamp;} 現在我需要處理兩種不同的通知，我決定用一個 switch 語句替換檢查 unread_message_count 通知名稱的 if 語句，該語句包含我現在需要支持的每種通知的一個部分。如果你對 “C” 語言家族不是很熟悉，你可能以前沒有看到過 switch 語句。這些提供了一種方便的語法，替代了長鏈的 if/elseif 語句。這很好，因為當我需要支持更多通知時，我可以簡單地繼續加入它們作為額外的 case 塊。 回憶一下，RQ 任務附加到 task_progress 通知的資料是一個包含兩個元素的字典，task_id 和 progress，這是我需要用來調用 set_task_progress() 的兩個參數。 如果你現在運行應用程式，綠色警告框中的進度指示器將每 10 秒刷新一次，隨著通知被送達到客戶端。 由於我在這章引入了新的可翻譯字串，翻譯文件需要被更新。如果你正在維護一個非英語語言文件，你需要使用 Flask-Babel 刷新你 的翻譯文件，然後加入新的翻譯： 1(venv) $ flask translate update 如果你正在使用西班牙語翻譯，那麼我已經為你完成了翻譯工作，所以你只需要從這章的下載包中提取 app/translations/es/LC_MESSAGES/messages.po 文件並將其加入到你的項目中。 翻譯完成後，你必須編譯翻譯文件： 1(venv) $ flask translate compile 部署考量為了完成這一章節，我想討論應用程式部署的變化。為了支持背景任務，我在技術棧中增加了兩個新組件，一個 Redis 伺服器和一個或多個 RQ 工作者。顯然，這些需要被納入你的部署策略中，所以我將簡要回顧我在前幾章中涵蓋的不同部署選項以及它們如何受到這些變化的影響。 在 Linux 伺服器上部署如果你在一個 Linux 伺服器上運行你的應用程式，加入 Redis 應該和從你的作業系統安裝這個套件一樣簡單。對於 Ubuntu Linux，你需要執行 sudo apt-get install redis-server。 要運行 RQ 工作者進程，你可以按照第 17 章中的 “設置 Gunicorn 和 Supervisor” 部分建立第二個 Supervisor 配置，在其中運行 rq worker microblog-tasks 而不是 gunicorn。如果你想運行多個工作者（而你在生產環境中可能應該這麼做），你可以使用 Supervisor 的 numprocs 指令來指示你想要同時運行多少個實例。 在 Heroku 上部署要在 Heroku 上部署應用程式，你需要為你的帳戶加入一個 Redis 服務。這類似於我用來加入 Postgres 資料庫的過程。Redis 也有一個免費層，可以用以下命令加入： 1$ heroku addons:create heroku-redis:hobby-dev 你的新 Redis 服務的訪問 URL 將被加入到你的 Heroku 環境中作為一個 REDIS_URL 變數，這正是應用程式所期望的。 Heroku 的免費計劃允許一個 web dyno 和一個 worker dyno，所以你可以在不產生任何費用的情況下，與你的應用程式一起託管一個 RQ 工作者。為此，你需要在你的 procfile 中另外一行聲明工作者： 12web: flask db upgrade; flask translate compile; gunicorn microblog:appworker: rq worker -u $REDIS_URL microblog-tasks 部署這些更改後，你可以用以下命令啟動工作者： 1$ heroku ps:scale worker=1 在 Docker 上部署如果你將應用程式部署到 Docker 容器中，那麼首先需要在應用程式使用的相同網絡上建立一個 Redis 容器。對此，你可以使用 Docker 註冊表中的官方 Redis 映像之一： 1$ docker run --name redis -d -p 6379:6379 --network microblog-network redis:latest 當你運行你的應用程式時，你將需要設置 REDIS_URL 環境變數，類似於處理 MySQL 容器的方式。這裡是包括 Redis 連結的啟動應用程式的完整命令： 123456789$ docker run --name microblog -d -p 8000:5000 --rm -e SECRET_KEY=my-secret-key \\ -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \\ -e MAIL_USERNAME=&lt;your-gmail-username&gt; -e MAIL_PASSWORD=&lt;your-gmail-password&gt; \\ --network microblog-network \\ -e DATABASE_URL=mysql+pymysql://microblog:&lt;database-password&gt;@mysql/microblog \\ -e REDIS_URL=redis://redis:6379/0 \\ microblog:latest 最後，你需要為 RQ 工作者運行一個或多個容器。因為工作者是基於與主應用程式相同的程式碼，所以你可以使用與你的應用程式相同的容器映像，覆蓋啟動命令，以便啟動工作者而不是網頁應用程式。這裡是一個啟動工作者的範例 docker run 命令： 12345678$ docker run --name rq-worker -d --rm -e SECRET_KEY=my-secret-key \\ -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \\ -e MAIL_USERNAME=&lt;your-gmail-username&gt; -e MAIL_PASSWORD=&lt;your-gmail-password&gt; \\ --network microblog-network \\ -e DATABASE_URL=mysql+pymysql://microblog:&lt;database-password&gt;@mysql/microblog \\ -e REDIS_URL=redis://redis:6379/0 \\ --entrypoint venv/bin/rq \\ microblog:latest worker -u redis://redis:6379/0 microblog-tasks 覆蓋 Docker 映像的默認啟動命令有點棘手，因為命令需要分成兩部分給出。--entrypoint 參數僅接受可執行名稱，但參數（如果有的話）需要在命令行的末尾、在映像和標籤之後給出。注意，rq 需要作為 venv/bin/rq 給出，以便在不啟動虛擬環境的情況下工作。","link":"/python/flask-mega-tutorial/chapter_22_background_jobs.html"},{"title":"","text":"Chapter 23: Application Programming Interfaces (APIs) Posted by on Miguel Grinberg 這篇文章是 Flask Mega-Tutorial 系列的第二十三部分，也是最後一部分，我將告訴你如何透過擴展微部落格加入一個應用程式介面 (API)，客戶端可以用來以更直接的方式比傳統的網頁瀏覽器工作流程來與應用程式進行互動。 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 到目前為止，我為這個應用程式建立的所有功能都是為了一種特定類型的客戶端：網頁瀏覽器。但是其他類型的客戶端呢？例如，如果我想要為 Android 或 iOS 應用程式建立一個簡單的應用程式，只有一個填滿整個螢幕的網頁視圖組件，載入微部落格網站，但這比在設備的網頁瀏覽器中打開應用程式提供的好處要少。一個更好的解決方案（儘管更勞累）是建立一個原生應用程式，但這個應用程式如何與只返回 HTML 頁面的伺服器互動呢？ 這是應用程式介面 (API) 可以幫助解決的問題領域。API 是一系列的 HTTP 路由，設計為應用程式的低層次入口點。API 允許客戶端直接與應用程式的資源進行工作，而不是定義路由和視圖函式返回 HTML 供網頁瀏覽器使用，將如何向使用者展示資訊的決定完全留給客戶端。例如，微部落格中的一個 API 可以提供使用者和部落格文章資訊給客戶端，並且也允許使用者編輯現有的部落格文章，但只是在資料層面，而不將此邏輯與 HTML 混合。 如果你研究目前在應用程式中定義的所有路由，你會注意到有一些可能符合我上述使用的 API 定義。你找到它們了嗎？我在談論一些返回 JSON 的路由，例如在第 14 章定義的 / translate 路由。這是一個路由，它接收一個文本、源語言和目標語言，所有這些都在 POST 請求中以 JSON 格式給出。對這個請求的回應是該文本的翻譯，也是以 JSON 格式。伺服器只返回請求的資訊，將向使用者展示這些資訊的責任留給客戶端。 雖然應用程式中的 JSON 路由具有 API 的 “感覺”，但它們被設計來支援在瀏覽器中運行的網頁應用程式。考慮到如果智能手機應用程式想要使用這些路由，它們將無法做到，因為它們要求一個已登入的使用者，而登入只能通過 HTML 表單進行。在這一章中，我將展示如何建立不依賴於網頁瀏覽器的 API，並且不 對連接到它們的客戶端類型做出任何假設。 本章的 GitHub 連結為：Browse、Zip、Diff REST 作為 API 設計的基礎有些人可能強烈不同意我上面的說法，即 / translate 和其他 JSON 路由是 API 路由。其他人可能同意，但會加上一個免責聲明，認為它們是設計不良的 API。那麼，什麼是設計良好的 API 的特點，為什麼 JSON 路由不在該類別中呢？ 你可能聽說過 REST API 這個術語。REST，代表表現性狀態轉移，是 Roy Fielding 博士在他的博士論文中提出的一種架構。在他的工作中，Fielding 博士以相當抽象和通用的方式提出了 REST 的六個定義特徵。 除了 Fielding 博士的論文外，沒有 REST 的官方規範，這留下了很多細節供讀者解釋。關於一個給定的 API 是否符合 REST 的話題，經常是 REST「純粹主義者」之間的激烈辯論的源頭，他們相信一個 REST API 必須觀察所有六個特徵，並以非常特定的方式這樣做，與 REST「實用主義者」形成對比，後者將 Fielding 博士在他的論文中提出的想法作為指導或建議。Fielding 博士本人站在純粹主義者一邊，並在博客文章和網上評論中提供了對他的願景的一些額外見解。 目前實施的絕大多數 API 都遵循「實用」的 REST 實現。這包括來自「大玩家」的大多數 API，如 Facebook、GitHub、Twitter 等。很少有公開 API 被一致認為是純 REST 的，因為大多數 API 缺少純粹主義者認為必須擁有的某些實現細節。儘管 Fielding 博士和其他 REST 純粹主義者對什麼是或不是 REST API 有嚴格的觀點，但在軟體行業中，將 REST 以實用的意義引用是常見的。 為了給你一個 REST 論文內容的想法，以下部分描述了 Fielding 博士列舉的六個原則。 Client-Server 客戶端 - 伺服器客戶端 - 伺服器原則相當直接，它簡單地指出在 REST API 中，客戶端和伺服器的角色應該被清楚地區分開來。在實踐中，這意味著客戶端和伺服器處於分開的程式中，透過一種傳輸進行通訊，這種傳輸在大多數情況下是透過 TCP 網路的 HTTP 協定。 Layered System 分層系統分層系統原則說明，當客戶端需要與伺服器通訊時，它可能最終連接到一個中介，而不是實際的伺服器。這個想法是，對於客戶端來說，如果不是直接連接到伺服器，它發送請求的方式應該完全沒有差別，事實上，它甚至可能不知道自己是否連接到目標伺服器。同樣，這個原則指出，伺服器可能從一個中介而不是直接從客戶端接收客戶端請求，因此它絕不能假設連接的另一端是客戶端。 這是 REST 的一個重要特性，因為能夠加入中介節點允許應用程式架構師設計大型和複雜的網絡，這些網絡能夠透過使用負載平衡器、快取、代理伺服器等滿足大量的請求。 Cache 快取這個原則通過明確指出允許伺服器或中介快取經常接收到的請求響應來擴展分層系統，以改善系統性能。你可能熟悉的一種快取實現是所有網頁瀏覽器中的快取。網頁瀏覽器的快取層經常被用來避免反覆請求相同的文件，如圖像等。 對於 API 的目的，目標伺服器需要透過使用快取控制來指示一個響應是否可以被中介在返回客戶端時快取。注意，因為安全原因，部署到生產環境的 API 必須使用加密，除非這個節點終止 SSL 連接或執行解密和重新加密，通常不在中介節點進行快取。 Code On Demand這是一個可選要求，指出伺服器可以在對客戶端的響應中提供可執行程式碼。因為這個原則要求伺服器和客戶端之間就客戶端能夠執行哪種可執行程式碼達成協議，這在 API 中很少使用。你可能會認為伺服器可以返回 JavaScript 程式碼供網頁瀏覽器客戶端執行，但 REST 並不是專門針對網頁瀏覽器客戶端的。例如，執行 JavaScript 可能會引入一個複雜性，如果客戶端是 iOS 或 Android 設備的話。 Stateless 無狀態無狀態原則是 REST 純粹主義者和實用主義者之間大多數辯論的中心之一。它指出 REST API 不應該保存任何客戶端狀態以供每次給定客戶端發送請求時回調。這意味著，網頁開發中常見的用於 “記住” 使用者隨著他們通過應用程式的頁面導航的機制不能被使用。在一個無狀態的 API 中，每個請求都需要包含伺服器需要的資訊來識別和認證客戶端並執行請求。這也意味著伺服器不能在資料庫或其他形式的存儲中存儲與客戶端連接相關的任何資料。 如果你想知道為什麼 REST 要求無狀態伺服器，主要原因是無狀態伺服器非常容易擴展，你需要做的就是在負載平衡器後面運行伺服器的多個實例。如果伺服器存儲客戶端狀態，事情就會變得更複雜，因為你必須弄清楚多個伺服器如何訪問和更新該狀態，或者另外確保給定客戶端總是由同一伺服器處理，這通常被稱為粘性會話。 如果你再次考慮章節引言中討論的 /translate 路由，你會意識到它不能被認為是 RESTful，因為與該路由相關的視圖函式依賴於 Flask-Login 的 @login_required 裝飾器，該裝飾器反過來將使用者的登入狀態存儲在 Flask 使用者會話中。 Uniform Interface 統一介面最後，最重要，最有爭議，也是最模糊記錄的 REST 原則是統一介面。Fielding 博士列舉了 REST 統一介面的四個區別方面：唯一資源標識符、資源表示、自描述消息和超媒體。 唯一資源標識符通過為每個資源分配一個唯一的 URL 來實現。例如，與給定使用者相關聯的 URL 可以是 /api/users/&lt;user-id&gt;，其中 &lt;user-id&gt; 是在資料庫表的主鍵中分配給使用者的標識符。這在大多數 API 中實施得相當好。 使用資源表示意味著當伺服器和客戶端交換關於資源的資訊時，它們必須使用一個雙方都同意的格式。對於大多數現代 API 來說，使用 JSON 格式來構建資源表示。一個 API 可以選擇支援多種資源表示格式，在這種情況下，HTTP 協定中的內容協商選項是客戶端和伺服器可以同意雙方都喜歡的格式的機制。 自描述消息意味著客戶端和伺服器之間交換的請求和響應必須包含另一方需要的所有資訊。作為一個典型的例子，HTTP 請求方法被用來指示客戶端希望伺服器執行什麼操作。GET 請求表明客戶端想要檢索有關資源的資訊，POST 請求表明客戶端想要建立一個新資源，PUT 或 PATCH 請求定義對現有資源的修改，而 DELETE 表明請求移除一個資源。目標資源作為請求 URL 指出，額外資訊在 HTTP 頭部、URL 的查詢字符串部分或請求體中提供。 超媒體要求是這套中最有爭議的，也是很少有 API 實施的，那些實施它的 API 很少以滿足 REST 純粹主義者的方式這樣做。由於應用程式中的資源都是相互關聯的，這個要求要求在資源表示中包含這些關係，以便客戶端可以通過遍歷關係發現新資源，幾乎就像你通過點擊連結從一個頁面跳轉到另一個頁面在網頁應用程式中發現新頁面一樣。這個想法是客戶端可以在沒有關於其中資源的任何先前知識的情況下進入一個 API，並僅僅通過跟隨超媒體連結來了解它們。實施這個要求的一個方面是，與 HTML 和 XML 不同，常用於 API 中的資源表示的 JSON 格式沒有定義一種標準方式來包含連結，所以你被迫使用一個自定義結構，或者嘗試解決這個差距的一個建議的 JSON 擴展，如 JSON-API、HAL、JSON-LD 或類似的。 實現 API 藍圖為了讓你體驗開發 API 所涉及的內容，我將向微部落格加入一個 API。這不會是一個完整的 API，我將實現所有與使用者相關的功能，將其他資源如部落格文章的實現留給讀者作為練習。 為了保持組織性，並遵循我在第 15 章中描述的結構，我將建立一個新的藍圖，其中將包含所有 API 路由。所以讓我們開始建立這個藍圖將要存放的目錄： 1(venv) $ mkdir app/api 藍圖的 __init__.py 檔案建立了藍圖對象，類似於應用中的其他藍圖： 1234567## app/api/__init__.py: API 藍圖構造器。from flask import Blueprintbp = Blueprint('api', __name__)from app.api import users, errors, tokens 你可能記得有時需要將導入移至底部以避免循環依賴錯誤。這就是為什麼在建立藍圖後導入 app/api/users.py、app/api/errors.py 和 app/api/tokens.py 模塊（我還未寫）的原因。 API 的核心將存儲在 app/api/users.py 模塊中。下表總結了我將要實現的路由： HTTP 方法 資源 URL 說明 GET /api/users/&lt;id&gt; 返回一個使用者。 GET /api/users 返回所有使用者的集合。 GET /api/users/&lt;id&gt;/followers 返回這個使用者的追隨者。 GET /api/users/&lt;id&gt;/following 返回這個使用者正在追隨的使用者。 POST /api/users 註冊一個新使用者帳號。 PUT /api/users/&lt;id&gt; 修改一個使用者。 目前，我將建立一個帶有所有這些路由占位符的骨架模塊： 123456789101112131415161718192021222324252627## app/api/users.py: 使用者 API 資源占位符。from app.api import bp@bp.route('/users/&lt;int:id&gt;', methods=['GET'])def get_user(id): pass@bp.route('/users', methods=['GET'])def get_users(): pass@bp.route('/users/&lt;int:id&gt;/followers', methods=['GET'])def get_followers(id): pass@bp.route('/users/&lt;int:id&gt;/following', methods=['GET'])def get_following(id): pass@bp.route('/users', methods=['POST'])def create_user(): pass@bp.route('/users/&lt;int:id&gt;', methods=['PUT'])def update_user(id): pass app/api/errors.py 模塊將定義一些處理錯誤響應的輔助函式。但現在，我也將使用一個稍後會填充的占位符： 1234## app/api/errors.py: 錯誤處理占位符。def bad_request(): pass app/api/tokens.py 是將要定義身份驗證子系統的模塊。這將為非網頁瀏覽器客戶端提供一種登錄的替代方式。目前，我也將為這個模塊寫一個占位符： 123456789## app/api/tokens.py: 令牌處理占位符。def get_token(): passdef revoke_token(): pass 新的 API 藍圖需要在應用工廠函式中註冊： 12345678910111213## app/__init__.py: 在應用中註冊 API 藍圖。## ...def create_app(config_class=Config): app = Flask(__name__) ## ... from app.api import bp as api_bp app.register_blueprint(api_bp, url_prefix='/api') ## ... 將使用者表示為 JSON 對象實現 API 時要考慮的第一個方面是決定其資源的表示方式。我將實現一個與使用者工作的 API，所以我需要決定我的使用者資源的表示。經過一番頭腦風暴，我想出了以下 JSON 表示： 1234567891011121314151617{ &quot;id&quot;: 123, &quot;username&quot;: &quot;susan&quot;, &quot;password&quot;: &quot;my-password&quot;, &quot;email&quot;: &quot;susan@example.com&quot;, &quot;last_seen&quot;: &quot;2021-06-20T15:04:27+00:00&quot;, &quot;about_me&quot;: &quot;Hello, my name is Susan!&quot;, &quot;post_count&quot;: 7, &quot;follower_count&quot;: 35, &quot;following_count&quot;: 21, &quot;_links&quot;: { &quot;self&quot;: &quot;/api/users/123&quot;, &quot;followers&quot;: &quot;/api/users/123/followers&quot;, &quot;following&quot;: &quot;/api/users/123/following&quot;, &quot;avatar&quot;: &quot;https://www.gravatar.com/avatar/...&quot; }} 許多字段直接來自使用者資料庫模型。password 字段特殊之處在於它僅在註冊新使用者時使用。正如你從第 5 章記得的那樣，使用者密碼不存儲在資料庫中，只存儲一個雜湊，所以密碼永遠不會被返回。email 字段也被特殊對待，因為我不想暴露使用者的電子郵件地址。email 字段僅在使用者請求他們自己的條目時返回，但在他們檢索其他使用者的條目時不返回。post_count、follower_count 和 following_count 字段是 “虛擬” 字段，它們不作為資料庫中的字段存在，但為了方便提供給客戶端。這是一個很好的例子，展示了資源表示不需要與伺服器中實際資源的定義相匹配。 注意 _links 部分，它實現了超媒體要求。定義的連結包括指向當前資源的連結、跟隨此使用者的使用者列表、使用者跟隨的使用者列表，以及使用者的頭像圖片的連結。將來，如果我決定向這個 API 加入文章，這裡也應該包括指向使用者文章列表的連結。 關於 JSON 格式的一件好事是它總是轉換為 Python 字典或列表的表示。Python 標準庫的 json 包負責將 Python 數據結構與 JSON 進行來回轉換。所以為了生成這些表示，我將向 User 模型加入一個名為 to_dict() 的方法，它返回一個 Python 字典： 1234567891011121314151617181920212223242526272829303132333435## app/models.py: 使用者模型到表示。from flask import url_for## ...class User(UserMixin, db.Model): ## ... def posts_count(self): query = sa.select(sa.func.count()).select_from( self.posts.select().subquery()) return db.session.scalar(query) def to_dict(self, include_email=False): data = { 'id': self.id, 'username': self.username, 'last_seen': self.last_seen.replace( tzinfo=timezone.utc).isoformat(), 'about_me': self.about_me, 'post_count': self.posts_count(), 'follower_count': self.followers_count(), 'following_count': self.following_count(), '_links': { 'self': url_for('api.get_user', id=self.id), 'followers': url_for('api.get_followers', id=self.id), 'following': url_for('api.get_following', id=self.id), 'avatar': self.avatar(128) } } if include_email: data['email'] = self.email return data 這個方法應該大致是不言自明的。我定下的使用者表示字典簡單地生成並返回。為了計算文章、追隨者和跟隨的數量，我使用輔助方法，為文章數量加入了一個方法，這是我之前從未需要使用過的。正如我上面提到的，email 字段需要特殊處理，因為我只想在使用者請求他們自己的數據時包含電子郵件。所以我使用 include_email 標誌來確定該字段是否包含在表示中。 注意 last_seen 字段是如何生成的。對於日期和時間字段，我將使用 ISO 8601 格式，Python 的 datetime 可以通過 isoformat() 方法生成。但因為 SQLAlchemy 使用的是 UTC 的天真 datetime 對象，但它們的狀態中沒有記錄時區，我需要首先設置時區，以確保它包含在 ISO 8601 字符串中。 最後，看看我如何實現超媒體連結。對於指向其他應用路由的三個連結，我使用 url_for() 生成 URL（目前指向我在 app/api/users.py 中定義的占位符視圖函數）。頭像連結是特殊的，因為它是一個應用外部的 Gravatar URL。對於這個連結，我使用了同樣的 avatar() 方法，我用它來在網頁中渲染頭像。 to_dict() 方法將使用者對象轉換為 Python 表示，然後將其轉換為 JSON。我還需要看看相反的方向，其中客戶端在請求中傳遞使用者表示，伺服器需要解析它並將其轉換為 User 對象。這是實現從 Python 字典到模型轉換的 from_dict() 方法： 1234567891011## app/models.py: 表示到使用者模型。class User(UserMixin, db.Model): ## ... def from_dict(self, data, new_user=False): for field in ['username', 'email', 'about_me']: if field in data: setattr(self, field, data[field]) if new_user and 'password' in data: self.set_password(data['password']) 在這種情況下，我決定使用一個循環來導入客戶端可以設置的任何字段，這些字段是 username、email 和 about_me。對於每個字段，我檢查在 data 參數中是否提供了一個值，如果有，我使用 Python 的 setattr() 在對象的相應屬性中設置新值。 password 字段被視為一個特例，因為它不是對象中 的一個字段。new_user 參數確定這是否是新使用者註冊，這意味著包含了一個密碼。要在使用者模型中設置密碼，我調用 set_password() 方法，它建立密碼雜湊。 表示使用者集合除了處理單一資源表示之外，這個 API 還需要一種表示集合的方式。當客戶端請求使用者列表或追隨者列表時，將使用這種格式。這是使用者集合的表示： 123456789101112131415161718{ &quot;items&quot;: [ {... user resource ...}, {... user resource ...}, ... ], &quot;_meta&quot;: { &quot;page&quot;: 1, &quot;per_page&quot;: 10, &quot;total_pages&quot;: 20, &quot;total_items&quot;: 195 }, &quot;_links&quot;: { &quot;self&quot;: &quot;http://localhost:5000/api/users?page=1&quot;, &quot;next&quot;: &quot;http://localhost:5000/api/users?page=2&quot;, &quot;prev&quot;: null }} 在這個表示中，items 是使用者資源的列表，每個資源都如前一節所述定義。_meta 部分包括客戶端可能在向使用者呈現分頁控制時發現有用的集合元數據。_links 部分定義了相關連結，包括指向集合本身的連結，以及前一頁和下一頁連結，也幫助客戶端分頁列表。 生成使用者集合的表示因分頁邏輯而棘手，但這個邏輯將對我未來可能想要加入到這個 API 中的其他資源通用，所以我將以一種我可以應用於其他模型的通用方式實現這個表示。回到第 16 章，我在全文檢索索引中處於類似情況，這是另一個我想要通用實現的功能，以便它可以應用於任何模型。我使用的解決方案是實現一個 SearchableMixin 類，任何需要全文索引的模型都可以繼承。我將使用相同的想法，所以這裡是一個我命名為 PaginatedAPIMixin 的新混入類： 12345678910111213141516171819202122232425## app/models.py: 分頁表示混入類。class PaginatedAPIMixin(object): @staticmethod def to_collection_dict(query, page, per_page, endpoint, **kwargs): resources = db.paginate(query, page=page, per_page=per_page, error_out=False) data = { 'items': [item.to_dict() for item in resources.items], '_meta': { 'page': page, 'per_page': per_page, 'total_pages': resources.pages, 'total_items': resources.total }, '_links': { 'self': url_for(endpoint, page=page, per_page=per_page, **kwargs), 'next': url_for(endpoint, page=page + 1, per_page=per_page, **kwargs) if resources.has_next else None, 'prev': url_for(endpoint, page=page - 1, per_page=per_page, **kwargs) if resources.has_prev else None } } return data to_collection_dict() 方法產生一個包含使用者集合表示的字典，包括 items、_meta 和 _links 部分。你可能需要仔細審查該方法以理解其運作方式。前三個參數是一個 SQLAlchemy 查詢、頁碼和頁面大小。這些參數決定了將返回哪些項目。實現使用 Flask-SQLAlchemy 的 db.paginate() 方法獲取一頁的項目，就像我在網頁應用的索引、探索和個人檔案頁面中對文章所做的那樣。 生成連結的複雜部分包 括自我參考和指向下一頁和前一頁的連結。我想讓這個函數通用，所以我不能，例如，使用 url_for('api.get_users', id=id, page=page) 生成自我連結。url_for() 的參數將依賴於特定的資源集合，所以我將依賴於呼叫者傳入 endpoint 參數作為 url_for() 調用中需要使用的視圖函數。由於許多應用中的路由需要參數，我還需要捕獲 kwargs 中的任何額外路由參數，並將這些參數傳遞給 url_for()。page 和 per_page 查詢字符串參數明確給出，因為這些控制了所有 API 路由的分頁。 這個混入類需要作為父類加入到 User 模型中： 1234## app/models.py: 將 PaginatedAPIMixin 加入到 User 模型。class User(PaginatedAPIMixin, UserMixin, db.Model): ## ... 在使用者集合的情況下，我不需要反向方向，因為我不會有任何路由需要客戶端發送使用者列表。如果項目要求客戶端發送使用者集合，我將需要實現一個 from_collection_dict() 方法。 錯誤處理我在第 7 章定義的錯誤頁面僅適用於使用網頁瀏覽器與應用交互的使用者。當 API 需要返回一個錯誤時，它需要是一種 “機器友好型” 的錯誤，客戶端應用可以輕鬆解釋的東西。所以就像我為我的 API 資源定義了 JSON 表示一樣，現在我將決定 API 錯誤消息的表示。這是我將使用的基本結構： 1234{ &quot;error&quot;: &quot;short error description&quot;, &quot;message&quot;: &quot;error message (optional)&quot;} 除了錯誤的有效負載外，我將使用 HTTP 協定的狀態碼來指示錯誤的一般類別。為了幫助我生成這些錯誤響應，我將在 app/api/errors.py 中編寫 error_response() 函數： 123456789## app/api/errors.py: 錯誤響應。from werkzeug.http import HTTP_STATUS_CODESdef error_response(status_code, message=None): payload = {'error': HTTP_STATUS_CODES.get(status_code, 'Unknown error')} if message: payload['message'] = message return payload, status_code 這個函數使用 Werkzeug 的方便的 HTTP_STATUS_CODES 字典（Flask 的一個核心依賴），為每個 HTTP 狀態碼提供了一個簡短描述性名稱。我使用這些名稱作為我的錯誤表示中的 error 字段，這樣我只需要擔心數字狀態碼和可選的長描述。這個表示被返回給 Flask，Flask 將其轉換為 JSON 並發送給客戶端。加入了一個帶有錯誤狀態碼的第二返回值，以覆蓋 Flask 發送的默認狀態碼 200（HTTP 狀態碼 “OK” 的狀態碼 ）。 API 將返回的最常見錯誤將是程式碼 400，這是 “錯誤請求” 的錯誤。當客戶端發送包含無效數據的請求時，使用這個錯誤。為了更容易生成這個錯誤，我將加入一個專門的函數，它只需要長描述消息作為參數。這是我之前加入的 bad_request() 占位符： 123456## app/api/errors.py: 錯誤請求響應。## ...def bad_request(message): return error_response(400, message) API 藍圖可能會生成各種錯誤，Flask 默認會將其渲染為 HTML 錯誤頁面。為了確保來自 API 藍圖的所有錯誤都返回 JSON 格式響應，我可以安裝一個捕獲所有 API 錯誤的錯誤處理器： 12345678910## app/api/errors.py: 捕獲所有 API 錯誤。from werkzeug.exceptions import HTTPExceptionfrom app.api import bp## ...@bp.errorhandler(HTTPException)def handle_exception(e): return error_response(e.code) API 藍圖的 errorhandler() 裝飾器現在將被調用來處理所有基於 HTTPException 類的錯誤，Flask 用於所有 HTTP 錯誤。 使用者資源端點我現在完成了處理使用者 JSON 表示所需的支持，所以我準備開始編碼 API 端點。 檢索一個使用者讓我們從檢索給定 id 的單一使用者請求開始： 1234567## app/api/users.py: 返回一個使用者。from app.models import User@bp.route('/users/&lt;int:id&gt;', methods=['GET'])def get_user(id): return db.get_or_404(User, id).to_dict() 視圖函數接收請求的使用者 id 作為 URL 中的動態參數。Flask-SQLAlchemy 的 db.get_or_404() 輔助函數如果存在給定 id 的模型則返回模型，但當 id 不存在時，它中止請求並向客戶端返回 404 錯誤。這很方便，因為它去除了檢查查詢結果的需要，簡化了視圖函數中的邏輯。 最後，我加入到 User 的 to_dict() 方法被用於生成選定使用者的資源表示的字典，當返回給客戶端時 Flask 將自動將其轉換為 JSON。 如果你想看看這個第一個 API 路由是如何工作的，啟動伺服器然後在瀏覽器的地址欄中輸入以下 URL： 1http://localhost:5000/api/users/1 這應該會以 JSON 格式顯示第一個使用者。也嘗試使用一個大的 id 值，看看 SQLAlchemy 查詢對象的 get_or_404() 方法如何觸發 404 錯誤（我稍後將展示如何擴展錯誤處理，以便這些錯誤也以 JSON 格式返回）。 為了以更合適的方式測試這個新路由，我將安裝 HTTPie，這是一個用 Python 編寫的命令行 HTTP 客戶端，使發送 API 請求變得容易： 123(venv) $ pip install httpie 我現在可以從終端請求有關 id 為 1 的使用者（可能是你自己）的資訊，使用以下命令： 1(venv) $ http GET http://localhost:5000/api/users/1 檢索使用者集合要返回所有使用者的集合，我現在可以依賴 PaginatedAPIMixin 的 to_collection_dict() 方法： 12345678910111213## app/api/users.py: 返回所有使用者的集合。import sqlalchemy as safrom flask import request## ...@bp.route('/users', methods=['GET'])def get_users(): page = request.args.get('page', 1, type=int) per_page = min(request.args.get('per_page', 10, type=int), 100) return User.to_collection_dict(sa.select(User), page, per_page, 'api.get_users') 對於這個實現，我首先從請求的查詢字符串中提取 page 和 per_page，如果它們未定義則分別使用 1 和 10 的默認值。per_page 參數有額外的邏輯，將其限制在 100 以內。給客戶端控制請求真正大的頁面並不是一個好主意，因為這可能會對伺服器造成性能問題。page 和 per_page 參數隨後傳遞給 to_collection_dict() 方法，連同返回所有使用者的查詢。最後一個參數是 api.get_users，這是我需要用於表示中使用的三個連結的端點名稱。 要用 HTTPie 測試這個端點，使用以下命令： 1(venv) $ http GET http://localhost:5000/api/users 接下來的兩個端點是返回追隨者和被追隨的使用者。這些與上面的非常相似： 123456789101112131415161718## app/api/users.py: 返回追隨者和被追隨的使用者。@bp.route('/users/&lt;int:id&gt;/followers', methods=['GET'])def get_followers(id): user = db.get_or_404(User, id) page = request.args.get('page', 1, type=int) per_page = min(request.args.get('per_page', 10, type=int), 100) return User.to_collection_dict(user.followers.select(), page, per_page, 'api.get_followers', id=id)@bp.route('/users/&lt;int:id&gt;/following', methods=['GET'])def get_following(id): user = db.get_or_404(User, id) page = request.args.get('page', 1, type=int) per_page = min(request.args.get('per_page', 10, type=int), 100) return User.to_collection_dict(user.following.select(), page, per_page, 'api.get_following', id=id) 由於這兩個路由特定於一個使用者，它們在 URL 中有 id 動態參數。id 被用於從資料庫獲取使用者，然後向 to_collection_dict() 方法提供 user.followers 和 user.following 關係查詢。希望現在你可以看到，花一點額外的時間並以通用方式設計這個方法真的是值得的。to_collection_dict() 的最後兩個參數是端點名稱，和 id，方法將其作為 kwargs 中的額外關鍵字參數接受，然後在生成表示的連結部分時將其傳遞給 url_for()。 類似於之前的例子，你可以使用 HTTPie 按照以下方式測試這兩個路 由： 12(venv) $ http GET http://localhost:5000/api/users/1/followers(venv) $ http GET http://localhost:5000/api/users/1/following 我應該指出，多虧了超媒體，你不需要記住這些 URL，因為它們包含在使用者表示的 _links 部分中。 註冊新使用者POST 請求到 /users 路由將被用來註冊新使用者帳號。你可以在下面看到這個路由的實現： 1234567891011121314151617181920212223## app/api/users.py: 註冊一個新使用者。from flask import url_forfrom app import dbfrom app.api.errors import bad_request@bp.route('/users', methods=['POST'])def create_user(): data = request.get_json() if 'username' not in data or 'email' not in data or 'password' not in data: return bad_request('必須包括使用者名稱、電子郵件和密碼字段') if db.session.scalar(sa.select(User).where( User.username == data['username'])): return bad_request('請使用不同的使用者名稱') if db.session.scalar(sa.select(User).where( User.email == data['email'])): return bad_request('請使用不同的電子郵件地址') user = User() user.from_dict(data, new_user=True) db.session.add(user) db.session.commit() return user.to_dict(), 201, {'Location': url_for('api.get_user', id=user.id)} 這個請求將接受客戶端提供的、以 JSON 格式的使用者表示，包含在請求體中。Flask 提供了 request.get_json() 方法從請求中提取 JSON 體並將其作為 Python 結構返回。如果客戶端發送的內容不是 JSON 格式，或者 JSON 內容格式錯誤，這個方法可能導致請求以 415 狀態碼（不支持的媒體類型）失敗，這兩種情況都將由 app/api/errors.py 中的 handle_http_exception() 處理器處理。 在我可以使用數據之前，我需要確保我獲得了所有訊息，所以我從檢查三個必需字段是否包含開始。這些是使用者名稱、電子郵件和密碼。如果任何這些缺失，那麼我使用 app/api/errors.py 模塊中的 bad_request() 輔助函數向客戶端返回一個錯誤。除了這個檢查外，我需要確保使用者名稱和電子郵件字段沒有被另一個使用者使用，所以我嘗試從資料庫通過提供的使用者名稱和電子郵件加載一個使用者，如果任何這些返回了一個有效的使用者，我也會向客戶端返回一個錯誤。 一旦我通過了數據驗證，我就可以輕鬆建立一個使用者對象並將其加入到資料庫中。建立使用者時，我依賴於 User 模型中的 from_dict() 方法。new_user 參數設置為 True，以便它也接受通常不是使用者表示的一部分的密碼字段。 對於這個請求的回應將是新使用者的表示，所以 to_dict() 生成了該有效載荷。建立資源的 POST 請求的狀態碼應該是 201，這是當新實體已被建立時使用的程式碼。此外，HTTP 協定要求 201 響應包含一個 Location 頭部，設置為新資源的 URL，我可以使用 url_for() 生成。 下面你可以看到如何 通過 HTTPie 從命令行註冊一個新使用者： 12(venv) $ http POST http://localhost:5000/api/users username=alice password=dog \\ email=alice@example.com &quot;about_me = 你好，我是 Alice。&quot; 編輯使用者我在我的 API 中將要使用的最後一個端點是用於修改現有使用者的： 1234567891011121314151617## app/api/users.py: 修改一個使用者。@bp.route('/users/&lt;int:id&gt;', methods=['PUT'])def update_user(id): user = db.get_or_404(User, id) data = request.get_json() if 'username' in data and data['username'] != user.username and \\ db.session.scalar(sa.select(User).where( User.username == data['username'])): return bad_request('請使用不同的使用者名稱') if 'email' in data and data['email'] != user.email and \\ db.session.scalar(sa.select(User).where( User.email == data['email'])): return bad_request('請使用不同的電子郵件地址') user.from_dict(data, new_user=False) db.session.commit() return user.to_dict() 對於這個請求，我收到一個使用者 id 作為 URL 的動態部分，所以我可以加載指定的使用者並在找不到時返回 404 錯誤。請注意，目前還沒有身份驗證，所以現在 API 將允許使用者對任何其他使用者的帳戶進行更改。這顯然是一個安全問題，但我將在下一節中解決。 像新使用者的情況一樣，我需要驗證客戶端提供的使用者名稱和電子郵件字段在我可以使用它們之前不會與其他使用者衝突，但在這種情況下，驗證更加棘手。首先，這些字段在這個請求中是可選的，所以我需要檢查一個字段是否存在。第二個複雜的是，客戶端可能提供了相同的值，所以在我檢查使用者名稱或電子郵件是否被占用之前，我需要確保它們與當前的不同。如果任何這些驗證檢查失敗，那麼我就像以前一樣向客戶端返回 400 錯誤。 一旦數據通過了驗證，我可以使用 User 模型的 from_dict() 方法導入客戶端提供的所有數據，然後將更改提交到資料庫。這個請求的回應將使用者更新的表示返回給使用者，默認狀態碼為 200。 這是一個使用 HTTPie 編輯 about_me 字段的範例請求： 1(venv) $ http PUT http://localhost:5000/api/users/2 &quot;about_me = 嗨，我是 Miguel&quot; API 身份驗證我在前一節中加入的 API 端點目前對任何客戶端都是開放的。顯然，它們需要僅對註冊使用者可用，為此我需要加入身份驗證和授權，或簡稱為 “AuthN” 和 “AuthZ”。這個想法是客戶端發送的請求提供某種身份識別，以便伺服器知道客戶端代表哪個使用者，並可以驗證該使用者是否允許執行 所請求的操作。 保護這些 API 端點最明顯的方式是使用 Flask-Login 的 @login_required 裝飾器，但這種方法對於 API 端點有一些問題。當裝飾器檢測到非認證使用者時，它將使用者重定向到 HTML 登錄頁面。在 API 中沒有 HTML 或登錄頁面的概念，如果客戶端發送的請求包含無效或缺少憑證，伺服器必須拒絕請求並返回 401 狀態碼。伺服器不能假設 API 客戶端是網頁瀏覽器，或者它可以處理重定向，或者它可以渲染和處理 HTML 登錄表單。當 API 客戶端收到 401 狀態碼時，它知道需要向使用者請求憑證，但如何做到這一點真的不是伺服器的事情。 使用者模型中的令牌對於 API 身份驗證的需求，我將使用令牌認證方案。當客戶端想要開始與 API 交互時，它需要請求一個臨時令牌，使用使用者名稱和密碼進行認證。然後客戶端可以發送 API 請求，傳遞令牌作為認證，只要令牌有效即可。一旦令牌過期，需要請求一個新的令牌。為了支持使用者令牌，我將擴展 User 模型： 12345678910111213141516171819202122232425262728293031323334## app/models.py: 支援使用者令牌。from datetime import timedeltaimport secretsclass User(PaginatedAPIMixin, UserMixin, db.Model): ## ... token: so.Mapped[Optional[str]] = so.mapped_column( sa.String(32), index=True, unique=True) token_expiration: so.Mapped[Optional[datetime]] ## ... def get_token(self, expires_in=3600): now = datetime.now(timezone.utc) if elseelf.token and self.token_expiration.replace( tzinfo=timezone.utc) &gt; now + timedelta(seconds=60): return self.token self.token = secrets.token_hex(16) self.token_expiration = now + timedelta(seconds=expires_in) db.session.add(self) return self.token def revoke_token(self): self.token_expiration = datetime.now(timezone.utc) - timedelta( seconds=1) @staticmethod def check_token(token): user = db.session.scalar(sa.select(User).where(User.token == token)) if user is None or user.token_expiration.replace( tzinfo=timezone.utc) &lt;datetime.now(timezone.utc): return None return user 有了這個變化，我為使用者模型加入了一個 token 屬性，並且因為我需要按它在資料庫中進行搜索，所以我使其唯一且索引。我還加入了 token_expiration 字段，它具有令牌到期的日期和時間。這樣令牌就不會長時間保持有效，這可能成為安全風險。 我建立了三個方法來處理這些令牌。get_token() 方法為使用者返回一個令牌。令牌使用 Python 標準庫中的 secrets.token_hex() 函數生成。token 字段長度為 32 個字符，所以我必須傳遞 16 給 token_hex()，以便生成的令牌有 16 個字節，當以十六進制渲染 時將使用 32 個字符。在建立新令牌之前，這個方法檢查當前分配的令牌在過期前是否至少還有一分鐘，如果是這樣，則返回現有令牌。 在處理令牌時，擁有一個策略立即撤銷令牌，而不僅僅依賴於過期日期，這是一個經常被忽視的安全最佳實踐。revoke_token() 方法使當前分配給使用者的令牌無效，僅僅通過將過期日期設置為當前時間之前的一秒鐘。 check_token() 方法是一個靜態方法，它接受一個令牌作為輸入，並返回這個令牌屬於的使用者作為響應。如果令牌無效或過期，方法返回 None。 因為我對資料庫進行了更改，我需要生成一個新的資料庫遷移，然後用它升級資料庫： 12(venv) $ flask db migrate -m &quot;user tokens&quot;(venv) $ flask db upgrade 令牌請求當你寫一個 API 時，你必須考慮你的客戶端並不總是連接到網頁應用的網頁瀏覽器。API 的真正力量來自於當智能手機應用或甚至基於瀏覽器的單頁應用可以訪問後端服務時。當這些專業客戶端需要訪問 API 服務時，它們從請求一個令牌開始，這是傳統網頁應用中登錄表單的對應物。 為了簡化客戶端和伺服器在使用令牌認證時的互動，我將使用一個叫做 Flask-HTTPAuth 的 Flask 擴展。Flask-HTTPAuth 通過 pip 安裝： 1(venv) $ pip install flask-httpauth Flask-HTTPAuth 支持幾種不同的認證機制，都是對 API 友好的。首先，我將使用 HTTP 基本認證，在這種情況下，客戶端在標準 Authorization HTTP 頭中發送使用者憑證。為了與 Flask-HTTPAuth 集成，應用需要提供兩個函數：一個定義檢查使用者提供的使用者名稱和密碼的邏輯，另一個在身份驗證失敗的情況下返回錯誤響應。這些函數通過裝飾器註冊到 Flask-HTTPAuth 中，然後在身份驗證流程中根據需要由擴展自動調用。你可以在下面看到實現： 123456789101112131415161718192021## app/api/auth.py: 基本認證支持。import sqlalchemy as safrom flask_httpauth import HTTPBasicAuthfrom app import dbfrom app.models import Userfrom app.api.errors import error_responsebasic_auth = HTTPBasicAuth()@basic_auth.verify_passworddef verify_password(username, password): user = db.session.scalar(sa.select(User).where(User.username == username)) if user and user.check_password(password): return user@basic_auth.error_handlerdef basic_auth_error(status): return error_response(status) Flask-HTTPAuth 中的 HTTPBasicAuth 類實現了基本認證流程。兩個必需的函數分別通過 verify_password 和 error_handler 裝飾器配置。 驗證函數接收客戶端提供的使用者名稱和密碼，如果憑證有效則返回經過認證的使用者，否則返回 None。為了檢查密碼，我依賴 User 類的 check_password() 方法，這也被 Flask-Login 在網頁應用的認證中使用。經過認證的使用者將作為 basic_auth.current_user() 可用，以便在 API 視圖函數中使用。 錯誤處理函數返回標準的錯誤響應，這是由 app/api/errors.py 中的 error_response() 函數生成的。status 參數是 HTTP 狀態碼，在無效身份驗證的情況下將是 401。401 錯誤在 HTTP 標準中定義為 “未授權” 錯誤。HTTP 客戶端知道當它們收到這個錯誤時，它們發送的請求需要重新發送並帶有有效的憑證。 現在我已經實現了基本認證支持，所以我可以加入令牌檢索路由，客戶端將在需要令牌時調用： 123456789101112## app/api/tokens.py: 生成使用者令牌。from app import dbfrom app.api import bpfrom app.api.auth import basic_auth@bp.route('/tokens', methods=['POST'])@basic_auth.login_requireddef get_token(): token = basic_auth.current_user().get_token() db.session.commit() return {'token': token} 這個視圖函數被 HTTPBasicAuth 實例的 @basic_auth.login_required 裝飾器裝飾，它將指示 Flask-HTTPAuth 驗證身份驗證（通過我上面定義的驗證函數）並只在提供的憑證有效時允許函數運行。這個視圖函數的實現依賴於使用者模型的 get_token() 方法來產生令牌。在生成令牌後發出資料庫提交以確保令牌及其過期時間被寫回資料庫。 如果你嘗試向令牌 API 路由發送 POST 請求，會發生以下情況： 1(venv) $ http POST http://localhost:5000/api/tokens HTTP 響應包括 401 狀態碼，和我在 basic_auth_error() 函數中定義的錯誤有效載荷。這是同一請求，這次包括基本認證憑證： 1(venv) $ http --auth &lt;username&gt;:&lt;password&gt; POST http://localhost:5000/api/tokens 現在狀態碼是 200，這是成功請求的程式碼，有效載荷包括使用者的新生成的令牌。請注意，當你發送這個請求時，你需要用自己的憑證替換 &lt;username&gt;:&lt;password&gt;，同你使用登錄表單的憑證一樣。使用者名稱和密碼需要用冒號作為分隔 符提供。 使用令牌保護 API 路由客戶端現在可以請求一個令牌來使用 API 端點，所以剩下的就是向這些端點加入令牌驗證。這是 Flask-HTTPAuth 也可以為我處理的事情。我需要建立基於 HTTPTokenAuth 類的第二個認證實例，並提供一個令牌驗證回調： 1234567891011121314151617## app/api/auth.py: 令牌認證支持。## ...from flask_httpauth import HTTPTokenAuth## ...token_auth = HTTPTokenAuth()## ...@token_auth.verify_tokendef verify_token(token): return User.check_token(token) if token else None@token_auth.error_handlerdef token_auth_error(status): return error_response(status) 使用令牌認證時，Flask-HTTPAuth 使用 verify_token 裝飾的函數，但除此之外，令牌認證的工作方式與基本認證相同。我的令牌驗證函數使用 User.check_token() 來定位擁有提供的令牌的使用者並返回它。如前所述，返回 None 將導致客戶端被拒絕並出現身份驗證錯誤。 要用令牌保護 API 路由，需要加入 @token_auth.login_required 裝飾器： 1234567891011121314151617181920212223242526272829303132333435## app/api/users.py: 用令牌認證保護使用者路由。from flask import abortfrom app.api.auth import token_auth@bp.route('/users/&lt;int:id&gt;', methods=['GET'])@token_auth.login_requireddef get_user(id): ## ...@bp.route('/users', methods=['GET'])@token_auth.login_requireddef get_users(): ## ...@bp.route('/users/&lt;int:id&gt;/followers', methods=['GET'])@token_auth.login_requireddef get_followers(id): ## ...@bp.route('/users/&lt;int:id&gt;/following', methods=['GET'])@token_auth.login_requireddef get_following(id): ## ...@bp.route('/users', methods=['POST'])def create_user(): ## ...@bp.route('/users/&lt;int:id&gt;', methods=['PUT'])@token_auth.login_requireddef update_user(id): if token_auth.current_user().id != id: abort(403) ## ... 請注意，除了 create_user() 之外，所有 API 視圖函數都加入了裝飾器，這顯然不能接受認證，因為將要請求令牌的使用者需要首先被建立。還要注意，修改使用者的 PUT 請求有一個額外的檢查，防止使用者嘗試修改另一個使用者的帳戶。如果我發現請求的使用者 id 與經過認證的使用者的 id 不匹配，那麼我將返回一個 403 錯誤響應，這表明客戶端沒有權限執行請求的操作。 如果你像之前所示發送任何這些端點的請求，你將得到 401 錯誤響應。為了獲得訪問權限，你需要加入 Authorization 頭部，帶有你從 /api/tokens 請求中收到的令牌。Flask-HTTPAuth 期望令牌作為 “bearer” 令牌發送，可以用 HTTPie 如下發送： 1(venv) $ http -A bearer --auth &lt;token&gt; GET http://localhost:5000/api/users/1 撤銷令牌我將要實現的最後一個與令牌相關的功能是令牌撤銷，你可以在下面看到： 12345678910## app/api/tokens.py: 撤銷令牌。from app.api.auth import token_auth@bp.route('/tokens', methods=['DELETE'])@token_auth.login_requireddef revoke_token(): token_auth.current_user().revoke_token() db.session.commit() return '', 204 客戶端可以發送 DELETE 請求到 /tokens URL 來使令牌無效。這個路由的認證是基於令牌的，事實上，在 Authorization 頭部發送的令牌就是被撤銷的那個。撤銷本身使用 User 類中的輔助方法，該方法重置令牌的過期日期。資料庫會話被提交，以便將這一變更寫入資料庫。這個請求的回應沒有主體，所以我可以返回一個空字符串。在返回語句中的第二個值將回應的狀態碼設置為 204，這是對於沒有回應主體的成功請求要使用的程式碼。 這是從 HTTPie 發送的一個範例令牌撤銷請求： 1(venv) $ http -A bearer --auth &lt;token&gt; DELETE http://localhost:5000/api/tokens 對 API 友好的錯誤訊息你還記得本章早些時候我要求你從瀏覽器發送一個無效使用者 URL 的 API 請求時發生了什麼嗎？伺服器返回了 404 錯誤，但這個錯誤被格式化為標準的 404 HTML 錯誤頁面。API 可能需要返回的許多錯誤可以在 API 藍圖中用 JSON 版本覆蓋，但有些由 Flask 處理的錯誤仍然通過全局為應用註冊的錯誤處理器處理，這些仍然返回 HTML。 HTTP 協定支援一種機制，稱為內容協商，客戶端和伺服器可以根據客戶端偏好協商回應的最佳格式。客戶端需要在請求中發送一個 Accept 頭部，指示格式偏好。然後伺服器查看列表，並使用客戶端提供的列表中它支援的最佳格式進行回應。 我想做的是修改全局應用錯誤處理器，以便它們使用內容協商根據客戶端偏好以 HTML 或 JSON 回應。這可以使用 Flask 的 request.accept_mimetypes 對象完成： 12345678910111213141516171819202122232425## app/errors/handlers.py: 錯誤回應的內容協商。from flask import render_template, requestfrom app import dbfrom app.errors import bpfrom app.api.errors import error_response as api_error_responsedef wants_json_response(): return request.accept_mimetypes['application/json'] &gt;= \\ request.accept_mimetypes['text/html']@bp.app_errorhandler(404)def not_found_error(error): if wants_json_response(): return api_error_response(404) return render_template('errors/404.html'), 404@bp.app_errorhandler(500)def internal_error(error): db.session.rollback() if wants_json_response(): return api_error_response(500) return render_template('errors/500.html'), 500 wants_json_response() 輔助函數比較了客戶端在其偏好格式列表中選擇的 JSON 或 HTML 的偏好。如果 JSON 的評級高於 HTML，那麼我返回一個 JSON 回應。否則我將返回基於模板的原始 HTML 回應。對於 JSON 回應，我將從 API 藍圖導入 error_response 輔助函數，但在這裡我將其重命名為 api_error_response()，以便清楚它的功能和來源。 最後的話恭喜你完成了 Flask Mega-Tutorial！我希望你現在已經做好準備，可以構建自己的網頁應用並使用你所學的知識作為基礎繼續你的學習之旅。祝你好運！","link":"/python/flask-mega-tutorial/chapter_23_application_programming_interfaces_apis.html"},{"title":"Chapter 2: Templates","text":"Posted by on Miguel Grinberg 在 Flask Mega-Tutorial 系列的第二部分，我將討論如何使用模板。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 完成第一章後，你應該有一個簡單但功能性的網頁應用程式，檔案結構如下： 123456microblog\\ venv\\ app\\ __init__.py routes.py microblog.py 要執行應用程式，你需要在終端會話中設置 FLASK_APP=microblog.py（或更好的方法是，加入一個含有此變數的 .flaskenv 檔案），然後執行 flask run。這會啟動一個帶有應用程式的網頁伺服器，你可以透過在網頁瀏覽器的地址欄輸入 http://localhost:5000/ URL 來打開它。 在本章中，你將繼續在同一應用程式上工作，特別是，你將學習如何生成更精緻的網頁，這些網頁具有複雜的結構和許多動態組件。如果到目前為止，應用程式或開發流程有任何不清楚的地方，請在繼續之前再次複習第一章。 本章的 GitHub 連結是：Browse、Zip、Diff。 什麼是模板？我希望我的微型部落格應用程式的首頁有一個歡迎使用者的標題。目前，我將忽略應用程式尚未有使用者概念的事實，因為這將在之後出現。相反，我將使用一個模擬使用者，我將其實作為一個 Python 字典，如下所示： 1user = {'username': 'Miguel'} 建立模擬物件是一種有用的技術，允許你專注於應用程式的一部分，而不必擔心尚未存在的系統其他部分。我想設計我的應用程式的首頁，我不想因為我還沒有使用者系統而分心，所以我就編造了一個使用者物件，這樣我就可以繼續前進。 應用程式中的視圖函式返回一個簡單的字串。我現在想做的是將返回的字串擴展成一個完整的 HTML 頁面，也許像這樣： 1234567891011121314151617## app/routes.py: 從視圖函式返回完整的 HTML 頁面from app import app@app.route('/')@app.route('/index')def index(): user = {'username': 'Miguel'} return '''&lt;html&gt; &lt;head&gt; &lt;title&gt; 首頁 - 微型部落格 &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, '''+ user['username'] +'''!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;''' 如果你不熟悉 HTML，我建議你閱讀維基百科上的 HTML 標記，以獲得一個簡短的介紹。 如上所示更新視圖函式，然後再次運行應用程式，看看它在瀏覽器中的外觀。 我希望你同意我，上面用來向瀏覽器傳遞 HTML 的解決方案並不好。想像當你加入來自使用者的部落格文章時，這個視圖函式中的程式碼將變得多麼複雜，而且這些文章會不斷變化。應用程式還會有更多與其他 URL 關聯的視圖函式，所以想像如果有一天我決定改變這個應用程式的布局，我必須更新每個視圖函式中的 HTML。顯然，這不是一個隨著應用程式增長而能夠擴展的選項。 如果你能將應用程式的邏輯與網頁的佈局或呈現分開，那麼事情將會更好組織，你不這麼認為嗎？你甚至可以聘請網頁設計師來建立一個很棒的網站，而你則用 Python 程式碼應用程式邏輯。 模板有助於實現呈現與業務邏輯之間的分離。在 Flask 中，模板是作為單獨的檔案編寫的，存儲在應用程式包內的 templates 資料夾中。確保你在 microblog 目錄中後，建立存儲模板的目錄： 1(venv) $ mkdir app/templates 下面你可以看到你的第一個模板，其功能類似 於上面 index() 視圖函式返回的 HTML 頁面。在 app/templates/index.html 中寫下這個檔案： 1234567891011## app/templates/index.html: 主頁模板&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;{{ title }} - 微型部落格 &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, {{ user.username }}!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 這是一個標準的簡短 HTML 頁面。這個頁面唯一有趣的是有一對用於動態內容的佔位符，包裹在 {{...}} 部分中。這些佔位符代表頁面的可變部分，只有在運行時才會知道。 現在頁面的呈現已經轉移到 HTML 模板上，視圖函式可以簡化為： 12345678910## app/routes.py: 使用 render_template() 函式from flask import render_templatefrom app import app@app.route('/')@app.route('/index')def index(): user = {'username': 'Miguel'} return render_template('index.html', title='首頁', user=user) 這看起來好多了，對吧？試試這個應用程式的新版本，看看模板如何工作。一旦你在瀏覽器中加載了頁面，你可能會想查看源 HTML 並將其與原始模板進行比較。 將模板轉換為完整 HTML 頁面的操作稱為渲染。為了渲染模板，我必須導入 Flask 框架附帶的一個函式，稱為 render_template()。這個函式接受一個模板檔案名稱和一個變數列表的模板參數，並返回相同的模板，但所有佔位符都被實際值替換。 render_template() 函式調用了與 Flask 框架捆綁的 Jinja 模板引擎。Jinja 會用 render_template() 調用中提供的參數替換 {{ ... }} 區塊。 條件語句在 Jinja 模板引擎中，你已經看到了如何在渲染過程中用實際值替換佔位符，但這只是 Jinja 在模板檔案中支援的許多強大操作之一。例如，模板還支援在 {% ... %} 區塊內給出的控制語句。接下來的 index.html 模板版本增加了一個條件語句： 123456789101112131415## app/templates/index.html: 模板中的條件語句&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; {% if title %} &lt;title&gt;{{ title }} - 微型部落格 &lt;/title&gt; {% else %} &lt;title&gt; 歡迎來到微型部落格！&lt;/title&gt; {% endif %} &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, {{ user.username }}!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 現在這個模板更聰明了。如果視圖函式忘記傳遞一個值給 title 佔位符變數，那麼模板將提供一個預設的標題，而不是顯示一個空的標題。你可以通過在視圖函式的 render_template() 調用中移除 title 參數來嘗試這個條件如何工作。 迴圈 (Conditional Statements)已登入的使用者可能希望在首頁上看到與他們有聯繫的使用者最近的貼文，所以我現在要做的是擴展應用程式以支援這一點。 再一次，我將依賴方便的模擬物件技巧來建立一些使用者和一些要展示的貼文： 1234567891011121314151617181920## app/routes.py: 視圖函式中的假貼文from flask import render_templatefrom app import app@app.route('/')@app.route('/index')def index(): user = {'username': 'Miguel'} posts = [ { 'author': {'username': 'John'}, 'body': 'Portland 的天氣真好！' }, { 'author': {'username': 'Susan'}, 'body': '復仇者聯盟電影真的很酷！' } ] return render_template('index.html', title='首頁', user=user, posts=posts) 為了表示使用者貼文，我使用了一個列表，其中每個元素都是一個有著作者和內容字段的字典。當我真正實現使用者和部落格貼文時，我將嘗試盡可能保留這些字段名稱，這樣我現在使用這些假物件來設計和測試首頁模板的所有工作，在我引入真正的使用者和貼文時仍然有效。 在模板方面，我需要解決一個新問題。貼文列表可以有任何數量的元素，這取決於視圖函式決定要在頁面上呈現多少貼文。模板不能對有多少貼文做任何假設，所以它需要準備好以一種通用的方式渲染視圖傳入的任何數量的貼文。 對於這種類型的問題，Jinja 提供了一個 for 控制結構： 123456789101112131415161718## app/templates/index.html: 模板中的 for 迴圈&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; {% if title %} &lt;title&gt;{{ title }} - 微型部落格 &lt;/title&gt; {% else %} &lt;title&gt; 歡迎來到微型部落格 &lt;/title&gt; {% endif %} &lt;/head&gt; &lt;body&gt; &lt;h1&gt; 嗨, {{ user.username }}!&lt;/h1&gt; {% for post in posts %} &lt;div&gt;&lt;p&gt;{{ post.author.username }} 說： &lt;b&gt;{{ post.body }}&lt;/b&gt;&lt;/p&gt;&lt;/div&gt; {% endfor %} &lt;/body&gt;&lt;/html&gt; 簡單吧？試試這個應用程式的新版本，並確保在貼文列表中加入更多內容以查看模板如何適應並始終呈現視圖函式傳送的所有貼文。 模板繼承如今，大多數網頁應用程式在頁面頂部都有一個導航欄，其中包含一些經常使用的連結，例如編輯個人資料、登入、登出等的連結。我可以很容易地通過加入更多 HTML 向 index.html 模板加入一個導航欄，但隨著應用程式的增長，我將需要在其他頁面中使用這個相同的導航欄。我真的不想在許多 HTML 模板中維護多個導航欄的副本，如果可能的話，最好不要重複自己。 Jinja 有一個模板繼承功能，專門解決這個問題。本質上，你可以做的是將所有模板共有的頁面佈局部分移動到一個基礎模板中，所有其他模板都從這個基礎模板衍生。 所以我現在 要做的是定一個名為 base.html 的基礎模板，其中包括一個簡單的導航欄和我之前實現的標題邏輯。你需要在 app/templates/base.html 檔案中編寫以下模板： 1234567891011121314151617## app/templates/base.html: 包含導航欄的基礎模板&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; {% if title %} &lt;title&gt;{{ title }} - 微型部落格 &lt;/title&gt; {% else %} &lt;title&gt; 歡迎來到微型部落格 &lt;/title&gt; {% endif %} &lt;/head&gt; &lt;body&gt; &lt;div&gt; 微型部落格： &lt;a href=&quot;/index&quot;&gt; 首頁 &lt;/a&gt;&lt;/div&gt; &lt;hr&gt; {% block content %}{% endblock %} &lt;/body&gt;&lt;/html&gt; 在這個模板中，我使用了 block 控制語句來定義衍生模板可以插入自己的地方。區塊被賦予了一個獨特的名稱，衍生模板可以在提供其內容時引用這個名稱。 有了基礎模板後，我現在可以通過讓 index.html 繼承 base.html 來簡化它： 12345678910## app/templates/index.html: 從基礎模板繼承{% extends &quot;base.html&quot; %}{% block content %} &lt;h1&gt; 嗨, {{ user.username }}!&lt;/h1&gt; {% for post in posts %} &lt;div&gt;&lt;p&gt;{{ post.author.username }} 說： &lt;b&gt;{{ post.body }}&lt;/b&gt;&lt;/p&gt;&lt;/div&gt; {% endfor %}{% endblock %} 由於 base.html 模板現在將負責一般頁面結構，我已從 index.html 中刪除了所有這些元素，只留下了內容部分。extends 語句建立了兩個模板之間的繼承連結，以便 Jinja 知道當要求它渲染 index.html 時，需要將它嵌入 base.html 中。兩個模板都有匹配名為 content 的 block 語句，這是 Jinja 知道如何將兩個模板組合成一個的方式。現在如果我需要為應用程式建立額外的頁面，我可以將它們作為從相同的 base.html 模板衍生的模板來建立，這就是我如何讓應用程式的所有頁面共享相同的外觀和感覺而不重複。","link":"/python/flask-mega-tutorial/chapter_2_templates.html"},{"title":"Chapter 3 Web Forms","text":"Posted by on Miguel Grinberg 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 在第 2 章中，我為應用程式的首頁建立了一個簡單的模板，並使用假物件作為尚未擁有的東西（如使用者和部落格貼文）的佔位符。在這一章中，我將處理這個應用程式中仍然存在的許多問題之一，特別是如何通過網頁表單接收使用者輸入。 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 網頁表單是任何網頁應用程式中最基本的構建塊之一。我將使用表單來允許使用者提交部落格貼文，以及用於登入應用程式。 在你繼續這一章之前，確保你已經安裝了上一章中的微型部落格應用程式，並且可以毫無錯誤地運行它。 本章的 GitHub 連結是：Browse Zip Diff Flask-WTF 簡介要處理這個應用程式中的網頁表單，我將使用 Flask-WTF 擴充功能，這是 WTForms 套件的一個薄包裝層，可以很好地將它與 Flask 整合。這是我向你介紹的第一個 Flask 擴充功能，但它不會是最後一個。擴充功能是 Flask 生態系統中非常重要的一部分，因為它們為 Flask 故意不提出意見的問題提供解決方案。 Flask 擴充功能是用 pip 安裝的普通 Python 套件。你可以繼續在你的虛擬環境中安裝 Flask-WTF： 1(venv) $ pip install flask-wtf 到目前為止，應用程式非常簡單，因此我不需要擔心其配置。但對於除了最簡單的應用程式以外，你會發現 Flask（以及你使用的可能的 Flask 擴充功能）提供了在如何做事情上的一些自由度，你需要做出一些決定，這些決定以配置變數列表的形式傳遞給框架。 有幾種格式可以讓應用程式指定配置選項。最基本的解決方案是將你的變數定義為 app.config 中的鍵，它使用字典風格來處理變數。例如，你可以這樣做： 123app = Flask(__name__)app.config['SECRET_KEY'] = 'you-will-never-guess'## ... 根據需要加入更多變數 雖然上述語法足以為 Flask 建立配置選項，但我喜歡強調關注點分離的原則，所以我不會把我的配置放在建立應用程式的同一個地方，而是使用一個稍微複雜一些的結構，讓我可以將我的配置保存在一個單獨的檔案中。 我非常喜歡的一個解決方案，因為它非常可擴展，是使用 Python 類別來存儲配置變數。為了保持事物的整齊有序，我將在一個單獨的 Python 模組中建立配置類別。下面你可以看到這個應用程式的新配置類別，存儲在頂層目錄中的 config.py 模組中。 123456## config.py: 密鑰配置import osclass Config: SECRET_KEY = os.environ.get('SECRET_KEY') or 'you-will-never-guess' 很簡單，對吧？配置設置被定義為 Config 類別內的類別變數。隨著應用程式需要更多配置項目，它們可以被加入到這個類別中，稍後如果我發現我需要有不止一套配置，我可以建立它的子類別。但現在不用擔心這個。 我加入的唯一配置項目 SECRET_KEY 在大多數 Flask 應用程式中都是重要的部分。Flask 和一些它的擴充功能使用密鑰的值作為加密鑰匙，用於生成簽名或令牌。Flask-WTF 擴充功能使用它來保護網頁表單免受一種名為跨站請求偽造（CSRF，發音為 “seasurf”）的惡意攻擊。正如其名所暗示的，密鑰應該保持秘密，因為用它生成的令牌和簽名的強度取決於應用程式的信任維護者之外沒有人知道它。 密鑰的值設置為一個有 兩個條款的表達式，由 or 運算符連接。第一個條款尋找一個環境變數的值，也叫做 SECRET_KEY。第二個條款，只是一個硬編碼的字串。這是一個你會經常看到我重複用於配置變數的模式。這個想法是，優先使用來自環境變數的值，但如果環境沒有定義該變數，則使用硬編碼的字串作為默認值。當你正在開發這個應用程式時，安全要求較低，所以你可以忽略這個設置，讓硬編碼的字串被使用。但當這個應用程式部署在生產伺服器上時，我將在環境中設置一個獨特且難以猜測的值，以便伺服器擁有一個沒有其他人知道的安全密鑰。 現在我有了一個配置檔案，我需要告訴 Flask 讀取它並應用它。這可以在 Flask 應用程式實例建立後使用 app.config.from_object() 方法完成： 123456789## app/__init__.py: Flask 配置from flask import Flaskfrom config import Configapp = Flask(__name__)app.config.from_object(Config)from app import routes 我導入 Config 類別的方式起初可能看起來令人困惑，但如果你看看如何從 flask 套件（小寫 “f”）導入 Flask 類別（大寫 “F”），你會注意到我對配置做的是同樣的事情。小寫的 “config” 是 Python 模組 config.py 的名稱，顯然大寫的 “C” 是實際的類別。 正如我上面提到的，配置項目可以用字典語法從 app.config 訪問。這裡你可以看到一個快速的 Python 解釋器會話，我檢查了密鑰的值： 123&gt;&gt;&gt; from microblog import app&gt;&gt;&gt; app.config['SECRET_KEY']'you-will-never-guess' 使用者登入表單Flask-WTF 擴充功能使用 Python 類別來表示網頁表單。表單類別只是將表單的字段定義為類別變數。 再次考慮到關注點分離，我將使用一個新的 app/forms.py 模組來存儲我的網頁表單類別。首先，讓我們定一個使用者登入表單，該表單要求使用者輸入使用者名和密碼。表單還將包括一個「記住我」複選框和一個提交按鈕： 1234567891011## app/forms.py: 登入表單from flask_wtf import FlaskFormfrom wtforms import StringField, PasswordField, BooleanField, SubmitFieldfrom wtforms.validators import DataRequiredclass LoginForm(FlaskForm): username = StringField('使用者名', validators=[DataRequired()]) password = PasswordField('密碼', validators=[DataRequired()]) remember_me = BooleanField('記住我') submit = SubmitField('登入') 大多數 Flask 擴充功能使用 flask_ 的命名慣例作為其頂層匯入符號。在這種情況下，Flask-WTF 的所有符號都位於 flask_wtf 下。這是從 app/forms.py 頂部導入 FlaskForm 基類的地方。 代表我用於此表單的字段類型的四個類別直接從 WTForms 套件導入，因為 Flask-WTF 擴充功能沒有提供自定義版本。對於每個字段，都在 LoginForm 類中建立了一個作為類別變數的物件。每個字段都給出了作為第一個參數的描述或標籤。 你在某些字段中看到的可選 validators 參數用於將驗證行為附加到字段。DataRequired 驗證器僅檢查字段是否未空白提交。還有許多更多的驗證器可用，其中一些將用於其他表單。 表單模板下一步是將表單加入到 HTML 模板中，以便在網頁上呈現。好消息是，LoginForm 類別中定義的字段知道如何將自己渲染為 HTML，因此這項任務相當簡單。以下是我將存儲在 app/templates/login.html 檔案中的登入模板： 1234567891011121314151617181920## app/templates/login.html: 登入表單模板{% extends &quot;base.html&quot; %}{% block content %} &lt;h1&gt; 登入 &lt;/h1&gt; &lt;form action=&quot;&quot;method=&quot;post&quot; novalidate&gt; {{form.hidden_tag() }} &lt;p&gt; {{form.username.label}}&lt;br&gt; {{form.username(size=32) }} &lt;/p&gt; &lt;p&gt; {{form.password.label}}&lt;br&gt; {{form.password(size=32) }} &lt;/p&gt; &lt;p&gt;{{ form.remember_me() }} {{ form.remember_me.label }}&lt;/p&gt; &lt;p&gt;{{ form.submit() }}&lt;/p&gt; &lt;/form&gt;{% endblock %} 對於這個模板，我重用了第 2 章中顯示的 base.html 模板，通過 extends 模板繼承語句。實際上，我將對所有模板這樣做，以確保包含頂部導航欄的一致佈局貫穿應用程式的所有頁面。 這個模板期望給予一個從 LoginForm 類實例化的 form 物件作為參數，你可以看到引用為 form。這個參數將由我還沒有編寫的登入視圖函式發送。 HTML 的 &lt;form&gt; 元素用作網頁表單的容器。表單的 action 屬性用於告訴瀏覽器在提交使用者在表單中輸入的訊息時應該使用的 URL。當 action 設置為空字串時，表單會提交到當前地址欄中的 URL，即在頁面上呈現表單的 URL。method 屬性指定提交表單到伺服器時應使用的 HTTP 請求方法。預設是通過 GET 請求發送，但在幾乎所有情況下，使用 POST 請求會提供更好的使用者體驗，因為這種類型的請求可以在請求的正文中提交表單數據，而 GET 請求則將表單字段加入到 URL 中，使瀏覽器地址欄變得雜亂。novalidate 屬性用於告訴網頁瀏覽器不對此表單中的字段進行驗證，這實際上將這項任務留給在伺服器中運行的 Flask 應用程式。使用 novalidate 是完全可選的，但對於這個第一個表單來說，設置它很重要，因為這將允許你稍後在本章中測試伺服器端驗證。 form.hidden_tag() 模板參數生成一個隱藏字段，包含用於防止 CSRF 攻擊的令牌。為了保護表單，你所需要做的就是包含這個隱藏字段並在 Flask 配置中定義 SECRET_KEY 變數。如果你處理好這兩件事，Flask-WTF 會為你完成其餘工作。 如果你以前編寫過 HTML 網頁表單，你可能會發現這個模板中沒有 HTML 字段很奇怪。這是因為表單物件中的字段知道如何將自己渲染為 HTML。我所需要做的就是在我想要字段標籤的地方包含 {{form..label }}，並在我想要字段的地方包含 {{ form.() }}。對於需要額外 HTML 屬性的字段，這些可以作為參數傳遞。這個模板中的 username 和 password 字段將大小作為參數加入到 &lt;input&gt; HTML 元素作為屬性。這就是你也可以將 CSS 類別或 ID 附加到表單字段的方式。 表單視圖在你能在瀏覽器中看到這個表單之前的最後一步是在應用程式中編寫一個新的視圖函式來渲染上一節中的模板。 那麼，讓我們編寫一個映射到 /login URL 的新視圖函式，建立一個表單，並將其傳遞給模板進行渲染。這個視圖函式也可以與前一個一起放在 app/routes.py 模組中： 123456789101112## app/routes.py: 登入視圖函式from flask import render_templatefrom app import appfrom app.forms import LoginForm## ...@app.route('/login')def login(): form = LoginForm() return render_template('login.html', title='登入', form=form) 這裡我做的是從 forms.py 中導入 LoginForm 類，實例化一個物件，並將其發送到模板中。 表單模板這裡所做的是從 forms.py 導入 LoginForm 類別，實例化一個物件並將其傳遞給模板。form=form 語法看起來可能有些奇怪，但它僅僅是將在上面一行建立的 form 物件（顯示在右側）傳遞給模板，模板中的名稱為 form（顯示在左側）。這就是所有需要做的，以便渲染表單字段。 為了方便訪問登入表單，基礎模板可以擴展 base.html 中的 &lt;div&gt; 元素，以在導航欄中包含一個連結： 1234567## app/templates/base.html: 導航欄中的登入連結&lt;div&gt; 微部落格： &lt;a href=&quot;/index&quot;&gt; 首頁 &lt;/a&gt; &lt;a href=&quot;/login&quot;&gt; 登入 &lt;/a&gt;&lt;/div&gt; 此時，你可以運行應用程式並在網頁瀏覽器中看到表單。應用程式運行時，在瀏覽器的地址欄中輸入 http://localhost:5000/，然後點擊頂部導航欄中的「登入」連結以查看新的登入表單。很酷，對吧？ 接收表單數據如果你嘗試按下提交按鈕，瀏覽器將顯示「方法不允許」的錯誤。這是因為上一節中的登入視圖函式到目前為止只完成了一半工作。它可以在網頁上顯示表單，但尚未具備處理使用者提交的數據的邏輯。這是 Flask-WTF 使工作變得非常簡單的另一個領域。這裡是更新後的視圖函式，接受並驗證使用者提交的數據： 123456789101112## app/routes.py: 接收登入憑證from flask import render_template, flash, redirect@app.route('/login', methods=['GET', 'POST'])def login(): form = LoginForm() if form.validate_on_submit(): flash('使用者 {} 的登入請求，記住我 ={}'.format( form.username.data, form.remember_me.data)) return redirect('/index') return render_template('login.html', title='登入', form=form) 這個版本中的第一個新內容是路由裝飾器中的 methods 參數。這告訴 Flask 此視圖函式接受 GET 和 POST 請求，覆蓋了默認僅接受 GET 請求的設置。HTTP 協議規定 GET 請求是那些向客戶端（在這種情況下是網頁瀏覽器）返回訊息的請求。到目前為止，應用程式中的所有請求都是這種類型的。POST 請求通常在瀏覽器向伺服器提交表單數據時使用（實際上也可以使用 GET 請求來執行此操作，但這不是推薦的做法）。瀏覽器之前顯示的「方法不允許」錯誤是因為瀏覽器試圖發送 POST 請求，而應用程式未配置為接受它。通過提供 methods 參數，你正在告訴 Flask 應該接受哪些請求方法。 form.validate_on_submit() 方法完成所有表單處理工作。當瀏覽器發送 GET 請求以接收帶有表單的網頁時，這個方法將返回 False，所以在這種情況下，函式將跳過 if 語句，直接渲染函式最後一行的模板。 當瀏覽器發送 POST 請求作為使用者按下提交按鈕的結果時，form.validate_on_submit() 將收集所有數據，運行附加到字段上的所有驗證器，如果一切都沒問題，它將返回 True，表示數據有效並可以由應用程式處理。但如果至少有一個字段驗證失敗，則函式將返回 False，這將導致表單被重新渲染回使用者，就像 GET 請求的情況一樣。稍後我將在驗證失敗時加入錯誤消息。 當 form.validate_on_submit() 返回 True 時，登入視圖函式調用了兩個從 Flask 導入的新函式。flash() 函式是向使用者顯示消息的一種有用方式。許多應用程式使用這種技術來讓使用者知道某些操作是否成功。在這種情況下，我將使用這種機制作為臨時解決方案，因為我還沒有所有必要的基礎設施來真正登錄使用者。目前我所能做的最好的事情就是顯示一條確 認應用程式已接收到憑證的消息。 登入視圖函式中使用的第二個新函式是 redirect()。這個函式指示客戶端網頁瀏覽器自動導航到作為參數給出的不同頁面。這個視圖函式使用它將使用者重定向到應用程式的首頁。 當你調用 flash() 函式時，Flask 會存儲消息，但閃現的消息不會神奇地出現在網頁中。應用程式的模板需要以適合網站佈局的方式渲染這些閃現消息。我將把這些消息加入到基礎模板中，以便所有模板繼承此功能。這是更新後的基礎模板： 1234567891011121314151617181920212223242526272829## app/templates/base.html: 基礎模板中的閃現消息&lt;html&gt; &lt;head&gt; {% if title %} &lt;title&gt;{{ title }} - 微部落格 &lt;/title&gt; {% else %} &lt;title&gt; 微部落格 &lt;/title&gt; {% endif %} &lt;/head&gt; &lt;body&gt; &lt;div&gt; 微部落格： &lt;a href=&quot;/index&quot;&gt; 首頁 &lt;/a&gt; &lt;a href=&quot;/login&quot;&gt; 登入 &lt;/a&gt; &lt;/div&gt; &lt;hr&gt; {% with messages = get_flashed_messages() %} {% if messages %} &lt;ul&gt; {% for message in messages %} &lt;li&gt;{{ message }}&lt;/li&gt; {% endfor %} &lt;/ul&gt; {% endif %} {% endwith %} {% block content %}{% endblock %} &lt;/body&gt;&lt;/html&gt; 這裡我使用 with 構造將調用 get_flashed_messages() 的結果分配給模板上下文中的 messages 變數。get_flashed_messages() 函式來自 Flask，返回之前使用 flash() 註冊的所有消息的列表。接下來的條件語句檢查 messages 是否有內容，如果有，則渲染一個 &lt;ul&gt; 元素，每個消息作為 &lt;li&gt; 列表項。這種渲染方式對於狀態消息來說看起來並不太好，但稍後將討論網頁應用程式的樣式。 這些閃現消息的一個有趣特性是，一旦它們通過 get_flashed_messages 函式被請求一次，它們就會從消息列表中被移除，因此在調用 flash() 函式後它們只會出現一次。 這是再次嘗試應用程式並測試表單如何工作的絕佳時機。請確保嘗試提交表單時使用者名或密碼字段為空，以查看 DataRequired 驗證器如何阻止提交過程。 改進字段驗證附加到表單字段的驗證器可防止接受無效數據到應用程式。應用程式處理無效表單輸入的方式是重新顯示表單，讓使用者進行必要的更正。 如果你嘗試提交無效數據，我相信你會注意到，儘管驗證機制工作得很好，但使用者並沒有收到有關表單出錯的任何指示，使用者只是簡單地再次收到表單。下一個任務是通過在每個驗證失敗的字段旁加入有意義的錯誤消息來改善使用者體驗。 事實上，表單驗證器已經生成了這些描述性錯誤消息，所以只缺少模板中的一些額外邏輯來渲染它們。 這是帶有使用者名和密碼字段中的驗證錯誤消息的登入模板： 1234567891011121314151617181920212223242526## app/templates/login.html: 登入表單模板中的驗證錯誤{% extends &quot;base.html&quot; %}{% block content %} &lt;h1&gt; 登入 &lt;/h1&gt; &lt;form action=&quot;&quot;method=&quot;post&quot; novalidate&gt; {{form.hidden_tag() }} &lt;p&gt; {{form.username.label}}&lt;br&gt; {{form.username(size=32) }}&lt;br&gt; {% for error in form.username.errors %} &lt;span style=&quot;color: red;&quot;&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt; {{form.password.label}}&lt;br&gt; {{form.password(size=32) }}&lt;br&gt; {% for error in form.password.errors %} &lt;span style=&quot;color: red;&quot;&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt;{{ form.remember_me() }} {{ form.remember_me.label }}&lt;/p&gt; &lt;p&gt;{{ form.submit() }}&lt;/p&gt; &lt;/form&gt;{% endblock %} 我唯一做的改變是在使用者名稱和密碼欄位後面新增了迴圈，這些迴圈會以紅色顯示驗證器加入的錯誤訊息。一般來說，任何附加了驗證器的欄位都會在表單.&lt;欄位名&gt;. 錯誤下新增由驗證產生的錯誤訊息。這會是一個列表，因為欄位可能附加了多個驗證器，並且可能有不止一個提供顯示給使用者的錯誤訊息。 如果你嘗試提交一個空的使用者名稱或密碼，你現在會得到一個漂亮的紅色錯誤訊息。 登入表單現在已經相當完整了，但在結束這章之前，我想討論在範本和重導中包含連結的正確方式。到目前為止，你已經看到幾個定義連結的實例。例如，這是目前基礎範本中的導航列： 12345&lt;div&gt; 微博客： &lt;a href=&quot;/index&quot;&gt; 首頁 &lt;/a&gt; &lt;a href=&quot;/login&quot;&gt; 登入 &lt;/a&gt;&lt;/div&gt; 登入檢視函式也定義了一個傳遞給 redirect() 函式的連結： 1234567@app.route('/login', methods=['GET', 'POST'])def login(): form = LoginForm() if form.validate_on_submit(): ## ... return redirect('/index') ## ... 直接在範本和源文件中寫入連結的一個問題是，如果有一天你決定重新組織你的連結，那麼你將不得不在整個應用程式中搜尋和替換這些連結。 為了更好地控制這些連結，Flask 提供了一個名為 url_for() 的函式，它使用其內部的 URL 到檢視函式的映射來產生 URL。例如，表達式 url_for(‘login’) 返回 /login，而 url_for(‘index’) 返回 ‘/index。url_for() 的參數是端點名稱，即檢視函式的名稱。 你可能會問，為什麼使用函式名稱而不是 URL 更好。事實是，URL 更有可能改變，而檢視函式名稱是完全內部的。一個次要原因是，如你稍後將學習到的，有些 URL 中有動態組件，所以手動產生這些 URL 需要連接多個元素，這既繁瑣又容易出錯。url_for() 函式還能以更優雅的語法產生這些複雜的 URL。 所以從現在起，每當我需要產生一個應用程式 URL 時，我將使用 url_for()。基礎範本中的導航列則變成： app/templates/base.html: 使用 url_for() 函式產生連結 12345&lt;div&gt; 微博客： &lt;a href=&quot;{{ url_for('index') }}&quot;&gt; 首頁 &lt;/a&gt; &lt;a href=&quot;{{ url_for('login') }}&quot;&gt; 登入 &lt;/a&gt;&lt;/div&gt; 這裡是更新後的 login() 檢視函式： app/routes.py: 使用 url_for() 函式產生連結 1234567891011from flask import render_template, flash, redirect, url_for## ...@app.route('/login', methods=['GET', 'POST'])def login(): form = LoginForm() if form.validate_on_submit(): ## ... return redirect(url_for('index')) ## ...","link":"/python/flask-mega-tutorial/chapter_3_web_forms.html"},{"title":"Chapter 4: Database","text":"Posted by on Miguel Grinberg 這章的主題極為重要。對於大多數應用程式來說，維護可有效檢索的持久數據是必要的，這正是資料庫的用途。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 本章的 GitHub 連結為：Browse Zip Diff Flask 中的資料庫如你所知，Flask 並不內建支援資料庫。這是 Flask 故意保持中立的眾多領域之一，這很好，因為你可以自由選擇最適合你應用程式的資料庫，而不是被迫適應某一種。 在 Python 中有許多優秀的資料庫選擇，很多都有支援 Flask 的擴充功能，使其更好地整合到應用程式中。這些資料庫大致可以分為兩大類：遵循關聯模型的，和不遵循的。後者通常被稱為 NoSQL，表示它們不實現流行的關聯查詢語言 SQL。雖然這兩組中都有優秀的資料庫產品，但我認為，對於有結構化數據（如使用者列表、部落格文章等）的應用程式來說，關聯資料庫更合適，而對於結構不太明確的數據，NoSQL 資料庫則更適合。這個應用程式，像大多數其他應用程式一樣，可以使用任何一種資料庫實現，但基於上述原因，我將選擇關聯資料庫。 在第 3 章中，我向你展示了第一個 Flask 擴充功能。在本章中，我將使用另外兩個。第一個是 Flask-SQLAlchemy，它提供了對流行的 SQLAlchemy 套件的 Flask 友好封裝，這是一個物件關聯映射器（ORM）。ORM 允許應用程式使用高階實體（如類別、物件和方法）而非表格和 SQL 來管理資料庫。ORM 的工作是將高階操作翻譯成資料庫命令。 SQLAlchemy 的好處是它不僅是一個 ORM，而且支援多種關聯資料庫。SQLAlchemy 支援許多資料庫引擎，包括流行的 MySQL、PostgreSQL 和 SQLite。這非常強大，因為你可以在簡單的 SQLite 資料庫上進行開發，這不需要伺服器，然後當應用程式部署到生產伺服器時，你可以選擇更強大的 MySQL 或 PostgreSQL 伺服器，而不必更改應用程式。 要在你的虛擬環境中安裝 Flask-SQLAlchemy，請確保先啟動它，然後執行： 1(venv) $ pip install flask-sqlalchemy 資料庫遷移我看過的大多數資料庫教程都涵蓋了資料庫的建立和使用，但沒有充分解決應用程式需求變化或增長時對現有資料庫進行更新的問題。這很難，因為關聯資料庫以結構化數據為中心，所以當結構改變時，資料庫中已有的數據需要遷移到修改後的結構。 本章我將介紹的第二個擴充功能是 Flask-Migrate，這其實是我自己建立的。這個擴充功能是 Alembic 的 Flask 封裝，Alembic 是 SQLAlchemy 的資料庫遷移框架。使用資料庫遷移在開始時會增加一些工作量，但這是為了將來能夠堅固地更改資料庫而付出的小代價。 安裝 Flask-Migrate 的過程與你之前看過的其他擴充功能類似： 1(venv) $ pip install flask-migrate Flask-SQLAlchemy 配置在開發期間，我將使用 SQLite 資料庫。對於開發小型應用程式（有時甚至不是很小的應用程式）來說，SQLite 資料庫是最方便的選擇，因為每個資料庫都存儲在磁碟上的單一檔案中，並且不需要運行像 MySQL 和 PostgreSQL 這樣的資料庫伺服器。 Flask-SQLAlchemy 需要在配置檔案中加入一個新的配置項： config.py：Flask-SQLAlchemy 配置 123456789import osbasedir = os.path.abspath(os.path.dirname(__file__))class Config(object): ## ... SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \\ 'sqlite:///'+ os.path.join(basedir,'app.db') Flask-SQLAlchemy 擴充功能從 SQLALCHEMY_DATABASE_URI 配置變數中取得應用程式的資料庫位置。如你在第 3 章回憶的，通常將配置從環境變數中設置是一個好做法，並在環境未定義該變數時提供一個回退值。在這個案例中，我從 DATABASE_URL 環境變數中取得資料庫 URL，如果沒有定義，我將配置一個名為 app.db 的資料庫，位於應用程式的主目錄中，存儲在 basedir 變數中。 資料庫將在應用程式中由資料庫實例代表。資料庫遷移引擎也將有一個實例。這些是需要在 app/init.py 檔案中在應用程式之後建立的物件： app/init.py：Flask-SQLAlchemy 和 Flask-Migrate 初始化 1234567891011from flask import Flaskfrom config import Configfrom flask_sqlalchemy import SQLAlchemyfrom flask_migrate import Migrateapp = Flask(__name__)app.config.from_object(Config)db = SQLAlchemy(app)migrate = Migrate(app, db)from app import routes, models 我對 init.py 檔案進行了三項更改。首先，我加入了一個代表資料庫的 db 物件。然後加入了 migrate，來代表資料庫遷移引擎。希望你在處理 Flask 擴充功能時看到一個模式。大多數擴充功能都是像這兩個一樣初始化的。在最後一項更改中，我在底部導入了一個名為 models 的新模組。這個模組將定義資料庫的結構。 資料庫模型將要存儲在資料庫中的數據將由一組通常稱為資料庫模型的類別來代表。SQLAlchemy 內部的 ORM 層將執行所需的轉換，將從這些類別建立的物件映射到適當資料庫表中的行。 讓我們從建立代表使用者的模型開始。使用 WWW SQL Designer 工具，我製作了以下圖表，來代表我們想在使用者表中使用的數據： id 欄位通常存在於所有模型中，並用作主鍵。資料庫中的每個使用者都將被分配一個唯一的 id 值，儲存在此欄位中。主鍵在大多數情況下都是由資料庫自動分配的，所以我只需要提供標記為主鍵的 id 欄位。 username、email 和 password_hash 欄位被定義為字串（或資料庫術語中的 VARCHAR），並指定了它們的最大長度，以便資料庫優化空間使用。雖然 username 和 email 欄位是不言自明的，但 password_hash 欄位值得關注。我想確保我正在構建的應用程式採用安全最佳實踐，出於這個原因，我不會以純文字形式儲存使用者密碼。存儲密碼的問題是，如果資料庫被破解，攻擊者將能夠訪問密碼，這對使用者來說可能是災難性的。我不是直接寫密碼，而是寫密碼雜湊，這大大提高了安全性。這將是另一章的主題，所以現在不用太擔心。 既然我知道我想要的使用者表，我就可以在新的 app/models.py 模組中將其翻譯成程式碼： app/models.py：使用者資料庫模型 123456789101112131415from typing import Optionalimport sqlalchemy as saimport sqlalchemy.orm as sofrom app import dbclass User(db.Model): id: so.Mapped[int] = so.mapped_column(primary_key=True) username: so.Mapped[str] = so.mapped_column(sa.String(64), index=True, unique=True) email: so.Mapped[str] = so.mapped_column(sa.String(120), index=True, unique=True) password_hash: so.Mapped[Optional[str]] = so.mapped_column(sa.String(256)) def __repr__(self): return '&lt;User {}&gt;'.format(self.username) 我從 SQLAlchemy 套件中匯入 sqlalchemy 和 sqlalchemy.orm 模組，這些模組提供了大多數與資料庫互動所需的元素。sqlalchemy 模組包含通用資料庫函式和類別，例如型態和查詢建構助手，而 sqlalchemy.orm 則提供了使用模型的支援。考慮到這兩個模組名稱很長，且需要經常引用，所以直接在匯入語句中定義 sa 和 so 的別名。還有從 Flask-SQLAlchemy 匯入 db 實例，以及從 Python 匯入 Optional 型態提示。 上面建立的 User 類別將代表儲存在資料庫中的使用者。該類別繼承自 db.Model，這是 Flask-SQLAlchemy 所有模型的基礎類別。User 模型定義了幾個作為類別變數的欄位。這些欄位將在對應的資料庫表格中被建立。 欄位使用 Python 型態提示指派型態，並用 SQLAlchemy 的 so.Mapped 泛型型態包裹。像是 so.Mapped[int] 或 so.Mapped[str] 這樣的型態聲明，不僅定義了欄位的型態，還使得值在資料庫術語中是必需的，或者不可為空。要定一個允許為空或可為空的欄位，也會加入 Python 的 Optional 輔助函式，正如 password_hash 所示。 在大多數情況下，定義表格欄位需要的不僅僅是欄位型態。SQLAlchemy 透過指派給每個欄位的 so.mapped_column() 函式呼叫提供這些額外配置。在上面的 id 欄位的情況，該欄位被配置為主鍵。對於字符串欄位，許多資料庫需要給定長度，因此也包含了這個配置。我還包括了其他可選參數，讓我可以指出哪些欄位是唯一的和已索引的，這對於保持資料庫的一致性和提高搜尋效率是重要的。 __repr__ 方法告訴 Python 如何列印這個類別的物件，這對於除錯很有用。你可以在下方的 Python 解釋器會話中看到 __repr__() 方法的實際應用： 1234&gt;&gt;&gt; from app.models import User&gt;&gt;&gt; u = User(username='susan', email='susan@example.com')&gt;&gt;&gt; u&lt;User susan&gt; 建立遷移儲存庫在前一節中建立的模型類別定義了這個應用的初始資料庫結構（或架構）。但隨著應用的持續發展，我可能需要對該結構進行更改，例如加入新項目，有時修改或移除項目。Alembic（Flask-Migrate 使用的遷移框架）將以不需要每次更改都重新建立資料庫的方式進行這些架構變更。 為了完成這看似困難的任務，Alembic 維護了一個遷移儲存庫，這是一個目錄，用於存儲其遷移腳本。每次對資料庫架構進行更改時，都會將一個遷移腳本加入到儲存庫中，並詳述更改的細節。要將遷移應用到資料庫，這些遷移腳本會按照它們建立的順序執行。 Flask-Migrate 通過 flask 命令暴露其指令。你已經看過 flask run，這是 Flask 原生的子命令。flask db 子命令是由 Flask-Migrate 加入的，用於管理與資料庫遷移相關的所有事物。那麼，讓我們透過執行 flask db init 為 microblog 建立遷移儲存庫： 123456789(venv) $ flask db init 建立目錄 /home/miguel/microblog/migrations ... 完成 建立目錄 /home/miguel/microblog/migrations/versions ... 完成 生成 /home/miguel/microblog/migrations/alembic.ini ... 完成 生成 /home/miguel/microblog/migrations/env.py ... 完成 生成 /home/miguel/microblog/migrations/README ... 完成 生成 /home/miguel/microblog/migrations/script.py.mako ... 完成 請在繼續之前編輯 '/home/miguel/microblog/migrations/alembic.ini' 中的配置 / 連接 / 日誌設定。 記得 flask 命令依賴於 FLASK_APP 環境變數來知道 Flask 應用的位置。對於這個應用，你希望將 FLASK_APP 設為 microblog.py 的值，正如第一章中討論的那樣。如果你在項目中包含了一個 .flaskenv 檔案，那麼 flask 命令的所有子命令都將自動訪問應用。 在你執行 flask db init 命令後，你會發現一個新的 migrations 目錄，裡面有一些檔案和一個 versions 子目錄。從現在開始，所有這些檔案都應被視為你的項目的一部分，特別是應該與你的應用程式碼一起加入到原始碼控制中。 第一個資料庫遷移有了遷移儲存庫後，就是時候建立第一個資料庫遷移，它將包括映射到 User 資料庫模型的 users 表格。建立資料庫遷移有兩種方式：手動或自動。為了自動生成遷移，Alembic 會比較資料庫模型定義的資料庫架構和資料庫中當前使用的實際資料庫架構。然後，它會將必要的更改填充到遷移腳本中，以使資料庫架構與應用模型匹配。在這種情況下，由於沒有之前的資料庫，自動遷移將把整個 User 模型加入到遷移腳本中。flask db migrate 子命令生成這些自動遷移： 1234567(venv) $ flask db migrate -m &quot;users table&quot;INFO [alembic.runtime.migration] Context impl SQLiteImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.autogenerate.compare] Detected added table 'user'INFO [alembic.autogenerate.compare] Detected added index 'ix_user_email' on '['email']'INFO [alembic.autogenerate.compare] Detected added index 'ix_user_username' on '['username']' 生成 /home/miguel/microblog/migrations/versions/e517276bb1c2_users_table.py ... 完成 命令的輸出讓你了解 Alembic 包含了哪些遷移。前兩行是資訊性的，通常可以忽略。然後它表示發現了一個 user 表格和兩個索引。然後告訴你它在哪裡寫了遷移腳本。e517276bb1c2 值是自動生成且唯一的遷移程式碼（對你來說會不同）。用 -m 選項給出的註釋是可選的，它只是為遷移加入了一個簡短的描述性文字。 生成的遷移腳本現在是你的項目的一部分，如果你正在使用 git 或其他原始碼控制工具，它需要作為一個額外的原始檔案與其他存儲在 migrations 目錄中的檔案一起整合。歡迎你檢查腳本，如果你好奇它的樣子。你會發現它有兩個函式 upgrade() 和 downgrade()。upgrade() 函式應用遷移，而 downgrade() 函式則移除它。這使得 Alembic 能夠將資料庫遷移到歷史中的任何點，甚至是更舊的版本，通過使用降級路徑。 flask db migrate 命令不會對資料庫進行任何更改，它只是生成遷移腳本。要將更改應用到資料庫，必須使用 flask db upgrade 命令。 1234(venv) $ flask db upgradeINFO [alembic.runtime.migration] Context impl SQLiteImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.runtime.migration] Running upgrade e517276bb1c2 -&gt; 780739b227a7, posts table 由於這個應用使用 SQLite，upgrade 命令將檢測到沒有資料庫並將其建立（在此命令完成後，你會注意到加入了一個名為 app.db 的檔案，那是 SQLite 資料庫）。在使用像是 MySQL 和 PostgreSQL 這樣的資料庫伺服器時，你必須在執行 upgrade 之前在資料庫伺服器中建立資料庫。 注意，Flask-SQLAlchemy 預設使用「蛇形命名法」來為資料庫表命名。對於上面的 User 模型，對應的資料庫表將被命名為 user。對於 AddressAndPhone 模型類別，表將被命名為 address_and_phone。如果你更喜歡選擇自己的表名，你可以在模型類別中加入一個名為 __tablename__ 的屬性，將其設置為你希望的名稱字符串。 資料庫升級與降級工作流程此時應用程式還處於起步階段，但討論接下來的資料庫遷移策略並無妨。假設你在開發機器上有你的應用程式副本，並且還部署了一份副本到線上使用的生產伺服器上。 假設在你的應用程式下一個版本中，你需要對模型進行更改，例如需要加入一個新表。沒有遷移的話，你需要弄清楚如何更改你的資料庫架構，無論是在你的開發機器還是再次在你的伺服器上，這可能會是大量的工作。 但有了資料庫遷移支援，當你修改了應用程式中的模型後，你生成一個新的遷移腳本（flask db migrate），你審查它以確保自動生成做了正確的事情，然後將更改應用於你的開發資料庫（flask db upgrade）。你將遷移腳本加入到原始碼控制中並提交它。 當你準備好將應用程式的新版本發布到你的生產伺服器時，你需要做的就是獲取你應用程式的更新版本，其中將包括新的遷移腳本，並運行 flask db upgrade。Alembic 將檢測到生產資料庫沒有更新到架構的最新修訂版本，並運行在上一個版本之後建立的所有新遷移腳本。 正如我之前提到的，你還有一個 flask db downgrade 命令，它可以撤銷上一次的遷移。雖然你在生產系統上不太可能需要這個選項，但在開發過程中你可能會發現它非常有用。你可能生成了一個遷移腳本並應用它，只是發現你所做的更改並不完全是你需要的。在這種情況下，你可以降級資料庫，刪除遷移腳本，然後生成一個新的來替換它。 資料庫關係關聯式資料庫擅長儲存資料項之間的關係。考慮一個使用者撰寫部落格文章的情況。使用者將在 users 表中擁有一個記錄，而文章將在 posts 表中擁有一個記錄。記錄誰寫了一篇給定文章的最有效方法是連接這兩個相關記錄。 一旦在使用者和文章之間建立了連接，資料庫就可以回答有關這個連接的查詢。最簡單的一個是當你有一篇部落格文章並需要知道是哪個使用者寫的。更複雜的查詢是這個的反向。如果你有一個使用者，你可能想知道這個使用者寫了所有的文章。SQLAlchemy 在這兩種類型的查詢中都有幫助。 讓我們擴展資料庫以儲存部落格文章，以查看關係實際操作。這是新的 posts 表的架構： posts 表將擁有所需的 id、文章的內容和時間戳。但除了這些預期的欄位外，我還加入了一個 user_id 欄位，它將文章與其作者連接起來。你已經看到所有使用者都有一個唯一的 id 主鍵。將部落格文章連接到其作者的方式是加入對使用者 id 的引用，這正是 user_id 欄位的用途。這個 user_id 欄位被稱為外鍵，因為它引用了另一個表的主鍵。上面的資料庫圖顯示了外鍵作為字段和它索引用的表的 id 欄位之間的連接。這種關係被稱為一對多，因為「一個」使用者寫了「多個」文章。 修改後的 app/models.py 如下所示： app/models.py：文章資料庫表和關係 1234567891011121314151617181920212223242526272829303132from datetime import datetime, timezonefrom typing import Optionalimport sqlalchemy as saimport sqlalchemy.orm as sofrom app import dbclass User(db.Model): id: so.Mapped[int] = so.mapped_column(primary_key=True) username: so.Mapped[str] = so.mapped_column(sa.String(64), index=True, unique=True) email: so.Mapped[str] = so.mapped_column(sa.String(120), index=True, unique=True) password_hash: so.Mapped[Optional[str]] = so.mapped_column(sa.String(256)) posts: so.WriteOnlyMapped['Post'] = so.relationship( back_populates='author') def __repr__(self): return '&lt;User {}&gt;'.format(self.username)class Post(db.Model): id: so.Mapped[int] = so.mapped_column(primary_key=True) body: so.Mapped[str] = so.mapped_column(sa.String(140)) timestamp: so.Mapped[datetime] = so.mapped_column( index=True, default=lambda: datetime.now(timezone.utc)) user_id: so.Mapped[int] = so.mapped_column(sa.ForeignKey(User.id), index=True) author: so.Mapped[User] = so.relationship(back_populates='posts') def __repr__(self): return '&lt;Post {}&gt;'.format(self.body) 新的 Post 類別將代表由使用者撰寫的部落格文章。timestamp 欄位使用 datetime 類型提示並配置為索引，這在你想要高效地按時間順序檢索文章時非常有用。我還加入了一個 default 參數，並傳遞了一個返回 UTC 時區當前時間的 lambda 函式。當你將函式作為默認值傳遞時，SQLAlchemy 將設置該欄位為該函式返回的值。通常，在伺服器應用程式中使用 UTC 日期和時間而不是你所在地的本地時間。這確保了無論使用者和伺服器位於何處，你都在使用統一的時間戳。 新的 Post 類別將代表使用者撰寫的部落格文章。timestamp 欄位使用 datetime 類型提示定義，並配置為索引，這在你想要有效地按時間順序檢索文章時非常有用。我還加入了一個預設引數，並傳遞了一個 lambda 函式，該函式返回 UTC 時區的當前時間。當你將函式作為預設值傳遞時，SQLAlchemy 會將欄位設置為該函式返回的值。一般來說，你會想在伺服器應用程式中使用 UTC 日期和時間，而不是你所在地的當地時間。這確保了你使用的時間戳記不論使用者和伺服器位於何處都是統一的。這些時間戳記將在顯示時轉換為使用者的當地時間。 user_id 欄位被初始化為 User.id 的外鍵，這意味著它參考了 users 表的 id 欄位中的值。由於並非所有資料庫都會自動為外鍵建立索引，因此明確加入了 index=True 選項，以便優化基於此欄位的搜尋。 User 類別有一個新的 posts 欄位，使用 so.relationship() 初始化。這不是一個實際的資料庫欄位，但是使用者和文章之間關係的高層次視圖，因此不在資料庫圖表中。同樣，Post 類別有一個也作為關係初始化的 author 欄位。這兩個屬性允許應用程式訪問連接的使用者和文章條目。 so.relationship() 的第一個引數是代表關係另一側的模型類別。這個引數可以作為字串提供，當類別在模組中後面定義時這是必要的。back_populates 引數參考另一側關係屬性的名稱，以便 SQLAlchemy 知道這些屬性指的是同一關係的兩側。 posts 關係屬性使用不同的類型定義。它不使用 so.Mapped，而是使用 so.WriteOnlyMapped，將 posts 定義為一個包含 Post 物件的集合類型。如果這些細節還不太清楚，不用擔心，我將在本文末尾展示這方面的例子。 由於我對應用程式模型進行了更新，需要生成一個新的資料庫遷移： 123456(venv) $ flask db migrate -m &quot;posts table&quot;INFO [alembic.runtime.migration] Context impl SQLiteImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.autogenerate.compare] Detected added table 'post'INFO [alembic.autogenerate.compare] Detected added index 'ix_post_timestamp' on '['timestamp']' Generating /home/miguel/microblog/migrations/versions/780739b227a7_posts_table.py ... done 而且遷移需要應用到資料庫： 1234(venv) $ flask db upgradeINFO [alembic.runtime.migration] Context impl SQLiteImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.runtime.migration] Running upgrade e517276bb1c2 -&gt; 780739b227a7, posts table 如果你將你的專案儲存在原始碼控制中，也記得將新的遷移腳本加入到其中。 與資料庫互動我讓你經歷了一個漫長的過程來定義資料庫，但我還沒有展示一切是如何工作的。由於應用程式還沒有任何資料庫邏輯，讓我們在 Python 直譯器中玩玩資料庫以熟悉它。在終端上執行 python 啟動 Python。在開始直譯器之前，確保你的虛擬環境已經啟動。 一旦進入 Python 提示符，讓我們導入應用程式、資料庫實例、模型和 SQLAlchemy 進入點： 123&gt;&gt;&gt; from app import app, db&gt;&gt;&gt; from app.models import User, Post&gt;&gt;&gt; import sqlalchemy as sa 下一步有點奇怪。為了讓 Flask 及其擴充功能可以訪問 Flask 應用程式而不必將 app 作為引數傳入每個函式，必須建立和推送應用程式上下文。應用程式上下文將在教程後面更詳細地介紹，所以現在，請在你的 Python shell 會話中輸入以下程式碼： 1&gt;&gt;&gt; app.app_context().push() 接下來，建立一個新使用者： 123&gt;&gt;&gt; u = User(username='john', email='john@example.com')&gt;&gt;&gt; db.session.add(u)&gt;&gt;&gt; db.session.commit() 對資料庫的更改是在資料庫會話的上下文中進行的，可以作為 db.session 訪問。會話中可以累積多個更改，一旦所有更改都被註冊，你可以發出單一的 db.session.commit()，將所有更改原子化寫入。如果在處理會話時出現任何錯誤，調用 db.session.rollback() 將中止會話並移除其中儲存的任何更改。重要的是要記住，只有在用 db.session.commit() 發出提交時，更改才會寫入資料庫。會話保證資料庫永遠不會處於不一致狀態。 你是否想知道所有這些資料庫操作是如何知道要使用哪個資料庫的？上面推送的應用程式上下文允許 Flask-SQLAlchemy 訪問 Flask 應用程式實例 app 而不必將其作為引數接收。擴充功能在 app.config 字典中尋找 SQLALCHEMY_DATABASE_URI 項，其中包含資料庫 URL。 讓我們加入另一個使用者： 123&gt;&gt;&gt; u = User(username='susan', email='susan@example.com')&gt;&gt;&gt; db.session.add(u)&gt;&gt;&gt; db.session.commit() 資料庫可以回答返回所有使用者的查詢： 1234&gt;&gt;&gt; query = sa.select(User)&gt;&gt;&gt; users = db.session.scalars(query).all()&gt;&gt;&gt; users[&lt;User john&gt;, &lt;User susan&gt;] 這個例子中的 query 變數被分配了一個基本查詢，選擇所有使用者。這是通過將模型類別傳遞給 SQLAlchemy sa.select() 查詢輔助函式實現的。你會發現大多數資料庫查詢都是從 sa.select() 呼叫開始的。 資料庫會話，在前文中用於定義和提交更動，也用於執行查詢。db.session.scalars() 方法執行資料庫查詢並回傳結果迭代器。調用結果物件的 all() 方法將結果轉換為普通列表。 在許多情況下，使用結果迭代器進行迴圈遍歷，而不是將其轉換為列表，會更有效率： 12345users = db.session.scalars(query)for u in users: print(u.id, u.username)1 john2 susan 注意，當這些使用者被新增時，id 欄位自動設為 1 和 2。這是因為 SQLAlchemy 配置整數主鍵欄位為自動遞增。 這裡是另一種執行查詢的方法。如果你知道某個使用者的 id，你可以如下檢索該使用者： 123u = db.session.get(User, 1)u&lt;User john&gt; 現在讓我們新增一篇部落格文章： 1234u = db.session.get(User, 1)p = Post(body='my first post!', author=u)db.session.add(p)db.session.commit() 我不需要為 timestamp 欄位設定值，因為這個欄位有預設值，你可以在模型定義中看到。那麼 user_id 欄位呢？回想一下我在 Post 類別中建立的 so.relationship，它為文章增加了一個 author 屬性。我使用這個 author 欄位而不是處理使用者 ID 來指派文章的作者。SQLAlchemy 在這方面很棒，因為它提供了高階的抽象，覆蓋了關係和外鍵。 為了完成這個會話，讓我們看幾個更多的資料庫查詢： 12345678910111213141516171819202122232425262728293031323334## 取得一位使用者所寫的所有文章u = db.session.get(User, 1)u&lt;User john&gt;query = u.posts.select()posts = db.session.scalars(query).all()posts[&lt;Post my first post!&gt;]## 同上，但對於沒有文章的使用者u = db.session.get(User, 2)u&lt;User susan&gt;query = u.posts.select()posts = db.session.scalars(query).all()posts[]## 為所有文章打印作者和內容query = sa.select(Post)posts = db.session.scalars(query)for p in posts: print(p.id, p.author.username, p.body)1 john my first post!## 取得所有使用者，按姓名反向字母順序query = sa.select(User).order_by(User.username.desc())db.session.scalars(query).all()[&lt;User susan&gt;, &lt;User john&gt;]## 取得所有姓名以 &quot;s&quot; 開頭的使用者query = sa.select(User).where(User.username.like('s%'))db.session.scalars(query).all()[&lt;User susan&gt;] 注意在上面前兩個例子中，如何使用使用者和文章之間的關係。回想一下，User 模型有一個 posts 關係屬性，這是用 WriteOnlyMapped 泛型型別配置的。這是一種特殊的關係型別，增加了一個 select() 方法，回傳相關項目的資料庫查詢。u.posts.select() 表達式負責生成連接使用者和其部落格文章的查詢。 最後一個查詢展示了如何使用條件篩選表格的內容。where() 子句用於建立篩 選器，只從所選實體中選取一部分行。在這個例子中，我使用 like() 運算子根據模式選擇使用者。 SQLAlchemy 文件是學習有關資料庫查詢的許多選項的最佳地方。 最後，退出 Python 殼並使用以下指令清除上面建立的測試使用者和文章，以便資料庫乾淨並準備好進入下一章： 12(venv) $ flask db downgrade base(venv) $ flask db upgrade 第一個指令告訴 Flask-Migrate 以相反順序應用資料庫遷移。當沒有給定目標時，降級命令會降級一個修訂。base 目標會導致所有遷移被降級，直到資料庫處於初始狀態，沒有表格。 升級命令以正向順序重新應用所有遷移。升級的預設目標是 head，這是最近遷移的捷徑。這個命令有效地恢復了上面降級的表格。由於資料庫遷移不保留資料庫中儲存的數據，降級然後升級的效果是快速清空所有表格。 殼上下文記得你在上一節開始時做了什麼，就在啟動 Python 解釋器後嗎？開始時你輸入了一些導入，然後推送了一個應用上下文： 1234from app import app, dbfrom app.models import User, Postimport sqlalchemy as saapp.app_context().push() 當你在應用上工作時，你會經常需要在 Python 殼中測試東西，所以每次都重複上述陳述會變得很繁瑣。這是解決這個問題的好時機。 flask shell 子命令是 flask 指令集中另一個非常有用的工具。shell 命令是 Flask 實現的第二個 “核心” 命令，繼 run 之後。這個命令的目的是在應用上下文中啟動 Python 解釋器。這是什麼意思？看下面的例子： 12345678910(venv) $ python&gt;&gt;&gt; appTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name 'app' is not defined&gt;&gt;&gt;(venv) $ flask shell&gt;&gt;&gt; app&lt;Flask 'app'&gt; 在一般的解釋器會話中，除非明確導入，否則不知道 app 符號，但在使用 flask shell 時，該命令會為你預導入應用實例並推送其應用上下文。flask shell 的好處不僅在於它預導入 app，而且你還可以配置 “殼上下文”，即預導入其他符號的列表。 microblog.py 中的以下函式建立了一個殼上下文，將資料庫實例和模型加入到殼會話中： 12345678import sqlalchemy as saimport sqlalchemy.orm as sofrom app import app, dbfrom app.models import User, Post@app.shell_context_processordef make_shell_context(): return {'db': db, 'User': User, 'Post': Post} 此程式碼使用 app.shell_context_processor 裝飾器來註冊函式為 shell 上下文函式。當執行 Flask 的 shell 指令時，會呼叫這個函式並將其返回的項目註冊到 shell 會話中。這個函式之所以返回一個字典而不是列表，是因為你需要為每個項目提供一個名稱，以便在 shell 中引用，這個名稱由字典的鍵來指定。 在你加入了 shell 上下文處理器函式之後，你可以在不必引入它們的情況下操作資料庫實體： 1234567(venv) $ flask shell&gt;&gt;&gt; db&lt;SQLAlchemy sqlite:////home/miguel/microblog/app.db&gt;&gt;&gt;&gt; User&lt;class 'app.models.User'&gt;&gt;&gt;&gt; Post&lt;class 'app.models.Post'&gt; 如果你嘗試上述操作並在嘗試訪問 sa、so、db、User 和 Post 時遇到 NameError 異常，那麼 make_shell_context() 函式可能沒有被註冊到 Flask。這最有可能的原因是你沒有在環境中設定 FLASK_APP=microblog.py。如果是這種情況，請回到第一章複習如何設定 FLASK_APP 環境變數。如果你經常忘記在開新的終端機視窗時設定這個變數，你可以考慮在你的專案中加入一個 .flaskenv 檔案，如該章節末尾所述。","link":"/python/flask-mega-tutorial/chapter_4_database.html"},{"title":"Chapter 5: User Logins","text":"Posted by on Miguel Grinberg 這是 Flask Mega-Tutorial 系列的第五部分，我將告訴你如何建立一個使用者登入子系統。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 第三章中，你學會了如何建立使用者登入表單，第四章中，你學會了如何與資料庫互動。本章將教你如何結合這兩章的主題，建立一個簡單的使用者登入系統。 本章的 GitHub 連結為：Browse Zip Diff 密碼雜湊 (Password Hashing)在第四章中，使用者模型被賦予了一個 password_hash 欄位，目前尚未使用。這個欄位的目的是保存使用者密碼的雜湊值，該值將用於在登錄過程中驗證使用者輸入的密碼。密碼雜湊是一個複雜的主題，應該交給安全專家處理，但有一些易於使用的庫可以實現所有邏輯，並可以簡單地從應用程式中調用。 其中一個實現密碼雜湊的套件是 Werkzeug，你可能在安裝 Flask 時看到它作為其核心依賴項之一的參考。由於它是一個依賴項，Werkzeug 已經安裝在你的虛擬環境中。以下的 Python shell 會話演示了如何使用這個套件來雜湊密碼： 1234&gt;&gt;&gt; from werkzeug.security import generate_password_hash&gt;&gt;&gt; hash = generate_password_hash('foobar')&gt;&gt;&gt; hash'scrypt:32768:8:1$DdbIPADqKg2nniws$4ab051ebb6767a...' 在這個範例中，密碼 foobar 通過一系列加密操作轉換為一個長的編碼字符串，這些操作沒有已知的反向操作，這意味著獲得雜湊密碼的人將無法使用它來恢復原始密碼。作為額外的措施，如果你多次對相同的密碼進行雜湊，你將獲得不同的結果，因為所有雜湊密碼都獲得不同的加密鹽，所以這使得無法通過查看它們的雜湊來識別兩個使用者是否具有相同的密碼。 驗證過程使用 Werkzeug 的第二個函式完成，如下所示： 12345&gt;&gt;&gt; from werkzeug.security import check_password_hash&gt;&gt;&gt; check_password_hash(hash, 'foobar')True&gt;&gt;&gt; check_password_hash(hash, 'barfoo')False 驗證函式接受先前生成的密碼雜湊以及使用者在登錄時輸入的密碼。如果使用者提供的密碼與雜湊匹配，函式將返回 True，否則返回 False。 整個密碼雜湊邏輯可以實現為使用者模型中的兩個新方法： 1234567891011121314app/models.py: 密碼雜湊和驗證from werkzeug.security import generate_password_hash, check_password_hash## ...class User(db.Model): ## ... def set_password(self, password): self.password_hash = generate_password_hash(password) def check_password(self, password): return check_password_hash(self.password_hash, password) 有了這兩個方法，使用者對象現在能夠執行安全的密碼驗證，無需存儲原始密碼。以下是這些新方法的範例用法： 123456&gt;&gt;&gt; u = User(username='susan', email='susan@example.com')&gt;&gt;&gt; u.set_password('mypassword')&gt;&gt;&gt; u.check_password('anotherpassword')False&gt;&gt;&gt; u.check_password('mypassword')True 介紹 Flask-Login在這一章中，我將向你介紹一個非常受歡迎的 Flask 擴充功能：Flask-Login。這個擴充功能管理著使用者的登入狀態，使得使用者可以登入應用程式並在不同頁面間導覽，同時應用程式會「記住」使用者的登入狀態。它還提供了「記住我」的功能，允許使用者即使關閉瀏覽器窗口後也能保持登入狀態。為了準備好這一章的內容，你可以先在你的虛擬環境中安裝 Flask-Login： 1(venv) $ pip install flask-login 就像其他擴充功能一樣，Flask-Login 需要在 app/init.py 中的應用程式實例建立後立即初始化。以下是這個擴充功能的初始化方式： app/init.py：Flask-Login 初始化 12345678## ...from flask_login import LoginManagerapp = Flask(__name__)## ...login = LoginManager(app)## ... 為 Flask-Login 準備使用者模型Flask-Login 擴充功能與應用程式的使用者模型協同工作，並期望在其中實現特定的屬性和方法。這種方式很好，因為只要這些必需的項目被加入到模型中，Flask-Login 就不會有其他要求，例如，它可以與基於任何資料庫系統的使用者模型合作。 以下列出了四個必需的項目： is_authenticated：一個屬性，如果使用者擁有有效的憑證則為 True，否則為 False。 is_active：一個屬性，如果使用者的帳戶是活躍的則為 True，否則為 False。 is_anonymous：一個屬性，對於普通使用者為 False，只對特殊的匿名使用者為 True。 get_id()：一個方法，返回使用者的唯一標識符，為一個字符串。 這四項我可以輕易實現，但由於實現相當通用，Flask-Login 提供了一個混入類（mixin class）叫 UserMixin，其中包含了適用於大多數使用者模型類的安全實現。以下是將混入類加入到模型的方式： app/models.py：Flask-Login 使用者混入類 12345## ...from flask_login import UserMixinclass User(UserMixin, db.Model): ## ... 使用者加載函式Flask-Login 透過在 Flask 的使用者會話中儲存其唯一標識符來追蹤已登入的使用者，這是指派給連接到應用程式的每位使用者的儲存空間。每當已登入的使用者導航到新頁面時，Flask-Login 會從會話中檢索使用者的 ID，然後將該使用者加載到內存中。 由於 Flask-Login 對資料庫一無所知，它需要應用程式的協助來加載使用者。出於這個原因，擴充功能期望應用程式將配置一個使用者加載函式，可以在給定 ID 的情況下呼叫來加載使用者。這個函式可以在 app/models.py 模組中加入： app/models.py: Flask-Login 使用者加載函式 123456from app import login## ...@login.user_loaderdef load_user(id): return db.session.get(User, int(id)) 使用者加載函式使用 @login.user_loader 裝飾器註冊到 Flask-Login。Flask-Login 傳遞給函式的 id 將是一個字串，所以使用數字 ID 的資料庫需要將字串轉換為整數，正如你在上面所見。 登入使用者讓我們重新審視登入視圖函式，您可能記得，它實作了一個假的登入，只發出了一個 flash() 訊息。現在應用程式可以存取使用者資料庫並知道如何產生及驗證密碼雜湊，這個視圖函式可以完成了。 app/routes.py：登入視圖函式邏輯 12345678910111213141516171819202122## ...from flask_login import current_user, login_userimport sqlalchemy as safrom app import dbfrom app.models import User## ...@app.route('/login', methods=['GET', 'POST'])def login(): if current_user.is_authenticated: return redirect(url_for('index')) form = LoginForm() if form.validate_on_submit(): user = db.session.scalar( sa.select(User).where(User.username == form.username.data)) if user is None or not user.check_password(form.password.data): flash('無效的使用者名稱或密碼') return redirect(url_for('login')) login_user(user, remember=form.remember_me.data) return redirect(url_for('index')) return render_template('login.html', title='登入', form=form) login() 函式的前兩行處理了一個奇怪的情況。想像您有一位已登入的使用者，而該使用者導航到應用程式的 /login 網址。顯然這是個錯誤，所以我想要阻止這種情況。current_user 變數來自 Flask-Login，在處理請求時的任何時間都可以用來獲取代表該請求客戶端的使用者物件。這個變數的值可以是資料庫中的使用者物件（透過我上面提供的使用者載入回呼由 Flask-Login 讀取），或者是特殊的匿名使用者物件（如果該使用者還未登入）。記得 Flask-Login 在使用者物件中要求的那些屬性嗎？其中之一就是 is_authenticated，這很方便用來檢查使用者是否已登入。當使用者已經登入時，我只是重導到首頁。 取代我之前使用的 flash() 呼叫，現在我可以真正地讓使用者登入。第一步是從資料庫載入使用者。使用者名稱隨表單提交而來，所以我可以用它來查詢資料庫以找到該使用者。為此我使用了 where() 子句，來找到具有給定使用者名稱的使用者。因為我知道只會有一個或零個結果，所以我透過呼叫 db.session.scalar() 來執行查詢，這將返回存在的使用者物件，或者如果不存在則返回 None。在第四章您已經看到，當您呼叫 all() 方法時，查詢執行並且您獲得符合該查詢的所有結果的列表。first() 方法是另一種常用的執行查詢的方式，當您只需要一個結果時。 如果我獲得了提供的使用者名稱的匹配，我接下來可以檢查隨表單一起來的密碼是否有效。這是通過調用我上面定義的 check_password() 方法來完成的。這將取用與使用者存儲的密碼雜湊並確定表單中輸入的密碼是否與雜湊匹配。所以現在我有兩個可能的錯誤條 件：使用者名稱可以無效，或者密碼對於該使用者來說可能不正確。在這些情況中的任何一種，我都會發出訊息，並重導回登入提示，以便使用者可以再次嘗試。 如果使用者名稱和密碼都正確，那麼我就調用 Flask-Login 的 login_user() 函式。這個函式將註冊使用者為已登入，這意味著任何未來使用者導航到的頁面都將將 current_user 變數設置為該使用者。 為了完成登入過程，我只是將新登入的使用者重導到首頁。 讓使用者登出我知道我還需要為使用者提供從應用程式登出的選項。這可以透過 Flask-Login 的 logout_user() 函式來完成。這裡是登出視圖函式： 12345678910111213141516171819202122232425app/routes.py: 登出視圖函式## ...from flask_login import logout_user## ...@app.route('/logout')def logout(): logout_user() return redirect(url_for('index'))要讓使用者看到這個連結，我可以讓導航列上的登入連結在使用者登入後自動切換成登出連結。這可以透過在 base.html 模板中使用條件判斷來達成：app/templates/base.html: 條件判斷的登入和登出連結 &lt;div&gt; 微網誌： &lt;a href=&quot;{{ url_for('index') }}&quot;&gt; 首頁 &lt;/a&gt; {% if current_user.is_anonymous %} &lt;a href=&quot;{{ url_for('login') }}&quot;&gt; 登入 &lt;/a&gt; {% else %} &lt;a href=&quot;{{ url_for('logout') }}&quot;&gt; 登出 &lt;/a&gt; {% endif %} &lt;/div&gt;is_anonymous 屬性是 Flask-Login 透過 UserMixin 類別新增給使用者物件的其中一個屬性。current_user.is_anonymous 表達式只有在使用者未登入時才會是 True。 要求使用者登入Flask-Login 提供了一個非常實用的功能，強制使用者在查看應用程式的某些頁面前必須登入。如果一個未登入的使用者嘗試查看受保護的頁面，Flask-Login 會自動將使用者重定向到登入表單，並且只有在登入程式完成後才重定向回使用者想要查看的頁面。 要實現此功能，Flask-Login 需要知道處理登入的視圖函式是哪一個。這可以在 app/init.py 中加入： 123## ...login = LoginManager(app)login.login_view = 'login' 上面的’login’ 值是登入視圖的函式（或端點）名稱。換句話說，就是你會在 url_for() 呼叫中使用的名稱來獲取 URL。 Flask-Login 保護視圖函式免受匿名使用者訪問的方式是使用一個叫做 @login_required 的裝飾器。當你在 Flask 的 @app.route 裝飾器下面的視圖函式中加入這個裝飾器時，該函式變得受保護，不會允許未經認證的使用者訪問。以下是如何將裝飾器應用於應用程式的 index 視圖函式： app/routes.py: @login_required 裝飾器 1234567from flask_login import login_required@app.route('/')@app.route('/index')@login_requireddef index(): ## ... 接下來是實現從成功登入後重定向回使用者想要訪問的頁面。當一個未登入的使用者訪問用 @login_required 裝飾器保護的視圖函式時，裝飾器會重定向到登入頁面，但它會在這個重定向中包含一些額外資訊，以便應用程式可以隨後返回原始頁面。例如，如果使用者導航到 /index，@login_required 裝飾器會攔截請求，並回應重定向到 /login，但它會向這個 URL 加入一個查詢字串參數，使完整的重定向 URL 為 /login?next=/index。next 查詢字串參數設置為原始 URL，因此應用程式可以使用它在登入後重定向回來。 以下是一段程式碼片段，顯示如何讀取和處理 next 查詢字串參數。更改在 login_user() 呼叫下面的四行中。 app/routes.py: 重定向到 “next” 頁面 123456789101112131415161718from flask import requestfrom urllib.parse import urlsplit@app.route('/login', methods=['GET', 'POST'])def login(): ## ... if form.validate_on_submit(): user = db.session.scalar( sa.select(User).where(User.username == form.username.data)) if user is None or not user.check_password(form.password.data): flash('Invalid username or password') return redirect(url_for('login')) login_user(user, remember=form.remember_me.data) next_page = request.args.get('next') if not next_page or urlsplit(next_page).netloc != '': next_page = url_for('index') return redirect(next_page) ## ... 在呼叫 Flask-Login 的 login_user() 函式登入使用者後，立即獲取 next 查詢字串參數的值。Flask 提供了一個 request 變數，其中包含客戶端隨 請求發送的所有資訊。特別是，request.args 屬性以友好的字典格式暴露了查詢字串的內容。實際上，需要考慮三種可能的情況來確定成功登入後重定向到哪裡： 如果登入 URL 沒有 next 參數，則使用者將被重定向到 index 頁面。 如果登入 URL 包含一個設置為相對路徑的 next 參數（或換句話說，一個沒有域部分的 URL），則使用者將被重定向到該 URL。 如果登入 URL 包含一個設置為包含域名的完整 URL 的 next 參數，則將忽略此 URL，使用者將被重定向到 index 頁面。 第一種和第二種情況是不言自明的。第三種情況是為了使應用程式更安全而設置的。攻擊者可以在 next 參數中插入一個惡意網站的 URL，所以應用程式只在 URL 是相對的時候重定向，這確保了重定向保持在與應用程式相同的網站內。為了確定 URL 是絕對還是相對的，我用 Python 的 urlsplit() 函式解析它，然後檢查 netloc 組件是否設置。 在模板中顯示已登入的使用者還記得在第二章，我建立了一個假使用者來幫助我設計應用程式的首頁，那時候使用者子系統還沒有建立嗎？現在，應用程式有了真正的使用者，所以我可以移除假使用者，開始使用真實使用者了。現在可以在 index.html 模板中使用 Flask-Login 的 current_user 替代假使用者： app/templates/index.html: 傳遞當前使用者到模板 12345678{% extends &quot;base.html&quot; %}{% block content %} &lt;h1&gt; 嗨, {{ current_user.username }}!&lt;/h1&gt; {% for post in posts %} &lt;div&gt;&lt;p&gt;{{ post.author.username }} 說: &lt;b&gt;{{ post.body }}&lt;/b&gt;&lt;/p&gt;&lt;/div&gt; {% endfor %}{% endblock %} 我可以在視圖函式中移除使用者模板參數： app/routes.py: 不再傳遞使用者到模板 123456@app.route('/')@app.route('/index')@login_requireddef index(): ## ... return render_template(&quot;index.html&quot;, title='首頁', posts=posts) 這是測試登入和登出功能的好時機。由於還沒有使用者註冊功能，加入使用者到資料庫的唯一方法是通過 Python shell，所以運行 flask shell 並輸入以下指令來註冊一個使用者： 1234&gt;&gt;&gt; u = User(username='susan', email='susan@example.com')&gt;&gt;&gt; u.set_password('cat')&gt;&gt;&gt; db.session.add(u)&gt;&gt;&gt; db.session.commit() 如果你現在啟動應用程式並訪問應用程式的 / 或 /index URL，你將立即被重定向到登入頁面，使用你加入到資料庫的使用者憑證登入後，你將返回到原始頁面，在那裡你會看到個性化的問候和模擬博客帖子。如果你然後點擊頂部導航欄中的登出連結，你將作為匿名使用者被送回索引頁面，並立即被 Flask-Login 重定向到登入頁面。 使用者註冊本章最後要構建的功能是註冊表單，以便使用者能透過網頁表單進行註冊。讓我們從在 app/forms.py 中建立網頁表單類別開始： 123456789101112131415161718192021222324252627282930app/forms.py: User registration formfrom flask_wtf import FlaskFormfrom wtforms import StringField, PasswordField, BooleanField, SubmitFieldfrom wtforms.validators import ValidationError, DataRequired, Email, EqualToimport sqlalchemy as safrom app import dbfrom app.models import User## ...class RegistrationForm(FlaskForm): username = StringField('Username', validators=[DataRequired()]) email = StringField('Email', validators=[DataRequired(), Email()]) password = PasswordField('Password', validators=[DataRequired()]) password2 = PasswordField( 'Repeat Password', validators=[DataRequired(), EqualTo('password')]) submit = SubmitField('Register') def validate_username(self, username): user = db.session.scalar(sa.select(User).where( User.username == username.data)) if user is not None: raise ValidationError('Please use a different username.') def validate_email(self, email): user = db.session.scalar(sa.select(User).where( User.email == email.data)) if user is not None: raise ValidationError('Please use a different email address.') 在這個新表單中有幾個與驗證相關的有趣之處。首先，對於電子郵件欄位，我在 DataRequired 後增加了另一個驗證器，名為 Email。這是 WTForms 內建的另一個驗證器，將確保使用者在此欄位中輸入的內容符合電子郵件地址的結構。 WTForms 的 Email() 驗證器需要安裝一個外部依賴： 1(venv) $ pip install email-validator 由於這是一個註冊表單，通常會要求使用者輸入兩次密碼，以減少打字錯誤的風險。出於這個原因，我有 password 和 password2 兩個欄位。第二個密碼欄位使用了另一個內建的驗證器，名為 EqualTo，它將確保其值與第一個密碼欄位的值相同。 當你加入任何符合 validate_ 模式的方法時，WTForms 將這些視為自訂驗證器，並在內建驗證器之外調用它們。我為此類加入了兩個這樣的方法，用於使用者名稱和電子郵件欄位。在這種情況下，我想確保使用者輸入的使用者名稱和電子郵件地址尚未在資料庫中，因此這兩個方法發出資料庫查詢，期望沒有結果。如果存在結果，則通過引發 ValidationError 類型的異常來觸發驗證錯誤。異常中作為參數的訊息將是顯示在欄位旁供使用者查看的訊息。 注意這兩個驗證查詢是如何發出的。這些查詢永遠不會找到多於一個結果，所以我不是用 db.session.scalars() 運行它們，而是用 db.session.scalar() 以單數形式，如果沒有結果，則返回 None，否則返回第一個結果。 為了在網頁上顯示這個表單，我需要有一個 HTML 模板，我將把它儲存在 app/templates/register.html 檔案中。這個模板的構建與登入表單的模板類似： app/templates/register.html: 註冊模板 123456789101112131415161718192021222324252627282930313233343536373839{% extends &quot;base.html&quot; %}{% block content %} &lt;h1&gt;Register&lt;/h1&gt; &lt;form action=&quot;&quot;method=&quot;post&quot;&gt; {{form.hidden_tag() }} &lt;p&gt; {{form.username.label}}&lt;br&gt; {{form.username(size=32) }}&lt;br&gt; {% for error in form.username.errors %} &lt;span style=&quot;color: red;&quot;&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt; {{form.email.label}}&lt;br&gt; {{form.email(size=64) }}&lt;br&gt; {% for error in form.email.errors %} &lt;span style=&quot;color: red;&quot;&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt; {{form.password.label}}&lt;br&gt; {{ form.password(size=32) }}&lt;br&gt; {% for error in form.password.errors %} &lt;span style=&quot;color: red;&quot;&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt; {{form.password2.label}}&lt;br&gt; {{form.password2(size=32) }}&lt;br&gt; {% for error in form.password2.errors %} &lt;span style=&quot;color: red;&quot;&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt;{{ form.submit() }}&lt;/p&gt; &lt;/form&gt;{% endblock %} 登入表單模板需要一個連結，將新使用者發送到註冊表單，就在表單下方： app/templates/login.html: 連結到註冊頁面 1&lt;p&gt; 新使用者？ &lt;a href=&quot;{{ url_for('register') }}&quot;&gt; 點擊註冊！&lt;/a&gt;&lt;/p&gt; 最後，我需要寫一個視圖函式來處理 app/routes.py 中的使用者註冊： app/routes.py: 使用者註冊視圖函式 123456789101112131415161718from app import dbfrom app.forms import RegistrationForm## ...@app.route('/register', methods=['GET', 'POST'])def register(): if current_user.is_authenticated: return redirect(url_for('index')) form = RegistrationForm() if form.validate_on_submit(): user = User(username=form.username.data, email=form.email.data) user.set_password(form.password.data) db.session.add(user) db.session.commit() flash('恭喜，你現在是一名註冊使用者！') return redirect(url_for('login')) return render_template('register.html', title='Register', form=form) 這個視圖函式也應該大致自解。我首先確保調用此路由的使用者沒有登錄。表單的處理方式與登錄表單相同。在 if validate_on_submit() 條件內部完成的邏輯是使用提供的使用者名稱、電子郵件和密碼建立一個新使用者，將其寫入資料庫，然後重定向到登入提示，以便使用者可以登入。 有了這些變更，使用者應該能夠在此應用程式上建立帳戶，並且登入和登出。一定要嘗試我在註冊表單中加入的所有驗證功能，以更好地了解它們的運作方式。我將在未來的章節中重新訪問使用者驗證子系統，以加入額外的功能，如允許使用者重置密碼（如果忘記）。但現在，這已足以繼續構建應用程式的其他領域。","link":"/python/flask-mega-tutorial/chapter_5_user_logins.html"},{"title":"Chapter 6：個人資料頁面與頭像","text":"Posted by on Miguel Grinberg 這是 Flask Mega-Tutorial 系列的第六篇文章，在這篇文章中，我將告訴你如何建立使用者個人資料頁面。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 這一章節將專門介紹如何向應用程式加入使用者個人資料頁面。使用者個人資料頁面是展示使用者資訊的頁面，通常包含使用者自己輸入的資訊。我將向你展示如何為所有使用者動態生成個人資料頁面，然後我會加入一個小型個人資料編輯器，供使用者輸入他們的資訊。 這一章的 GitHub 連結是：Browse Zip Diff 使用者個人資料頁面要建立一個使用者個人資料頁面，我們來加入一個 /user/&lt;username&gt; 路由到應用程式中。 app/routes.py: 使用者個人資料視圖函式 123456789@app.route('/user/&lt;username&gt;')@login_requireddef user(username): user = db.first_or_404(sa.select(User).where(User.username == username)) posts = [ {'author': user, 'body': '測試貼文 #1'}, {'author': user, 'body': '測試貼文 #2'} ] return render_template('user.html', user=user, posts=posts) 我用來宣告這個視圖函式的 @app.route 裝飾器看起來與之前的有些不同。在這種情況下，它有一個動態組件，即被 &lt; 和 &gt; 包圍的 &lt;username&gt; URL 組件。當路由有一個動態組件時，Flask 會接受該 URL 部分的任何文字，並將實際的文字作為參數調用視圖函式。例如，如果客戶端瀏覽器請求 URL /user/susan，視圖函式將被調用，參數 username 設為 'susan'。這個視圖函式只對登入的使用者開放，所以我加入了來自 Flask-Login 的 @login_required 裝飾器。 這個視圖函式的實現相當簡單。我首先嘗試使用使用者名稱進行查詢來從資料庫加載使用者。你之前已經看到，資料庫查詢可以使用 db.session.scalars() 執行，如果你想獲得所有結果，或者使用 db.session.scalar() 如果你只想獲得第一個結果或者在沒有結果時獲得 None。在這個視圖函式中，我使用了 Flask-SQLAlchemy 提供的 scalar() 的一種變體 db.first_or_404()，當有結果時它像 scalar() 一樣工作，但在沒有結果的情況下，它會自動向客戶端發送一個 404 錯誤。通過這種方式執行查詢，我節省 了檢查查詢是否返回了一個使用者的步驟，因為當資料庫中不存在該使用者名稱時，函式將不會返回，而是會引發一個 404 異常。 如果資料庫查詢沒有觸發 404 錯誤，則表示找到了具有給定使用者名稱的使用者。接下來我為這個使用者初始化了一個假的貼文列表，並渲染一個新的 user.html 模板，向其傳遞使用者物件和貼文列表。 user.html 模板如下所示： app/templates/user.html: 使用者個人資料模板 1234567891011{% extends &quot;base.html&quot; %}{% block content %} &lt;h1&gt; 使用者: {{ user.username }}&lt;/h1&gt; &lt;hr&gt; {% for post in posts %} &lt;p&gt; {{post.author.username}} 說：&lt;b&gt;{{ post.body }}&lt;/b&gt; &lt;/p&gt; {% endfor %}{% endblock %} 個人資料頁面現在完成了，但網站上任何地方都不存在指向它的連結。為了讓使用者更容易檢查他們自己的個人資料，我將在頂部導航欄中加入一個連結： app/templates/base.html: 使用者個人資料模板 12345678910&lt;div&gt; Microblog: &lt;a href=&quot;{{ url_for('index') }}&quot;&gt; 首頁 &lt;/a&gt; {% if current_user.is_anonymous %} &lt;a href=&quot;{{ url_for('login') }}&quot;&gt; 登入 &lt;/a&gt; {% else %} &lt;a href=&quot;{{ url_for('user', username=current_user.username) }}&quot;&gt; 個人資料 &lt;/a&gt; &lt;a href=&quot;{{ url_for('logout') }}&quot;&gt; 登出 &lt;/a&gt; {% endif %}&lt;/div&gt; 這裡唯一有趣的變化是使用 url_for() 函式來生成指向個人資料頁面的連結。由於使用者個人資料視圖函式接受一個動態參數，url_for() 函式將該 URL 部分的值作為關鍵字參數接收。因為這是指向登入使用者個人資料的連結，我可以使用 Flask-Login 的 current_user 來生成正確的 URL。 現在嘗試運行應用程式。點擊頂部的個人資料連結應該會帶你到你自己的使用者頁面。目前沒有連結可以帶你到其他使用者的個人資料頁面，但如果你想訪問這些頁面，你可以在瀏覽器的地址欄中手動輸入 URL。例如，如果你在應用程式上註冊了一個名為 “john” 的使用者，你可以通過輸入 http://localhost:5000/user/john 在地址欄中查看相應的使用者個人資料。 大頭貼 Avatars我相信你會同意，我剛剛建立的個人資料頁面還蠻單調的。為了讓它們更有趣一些，我打算新增使用者大頭貼，但為了避免在伺服器上處理可能龐大的上傳圖片集，我打算使用 Gravatar 服務為所有使用者提供圖片。 Gravatar 服務非常簡單好用。要為特定使用者請求圖片，必須使用格式為 https://www.gravatar.com/avatar/&lt;hash&gt; 的網址，其中 &lt;hash&gt; 是使用者電子郵件地址的 MD5 雜湊。下面你可以看到如何為電子郵件為 john@example.com 的使用者獲得 Gravatar 網址： 123&gt;&gt;&gt; from hashlib import md5&gt;&gt;&gt; 'https://www.gravatar.com/avatar/' + md5(b'john@example.com').hexdigest()'https://www.gravatar.com/avatar/d4c74594d841139328695756648b6bd6' 如果你想看一個實際的例子，我的 Gravatar 網址是： https://www.gravatar.com/avatar/729e26a2a2c7ff24a71958d4aa4e5f35 在瀏覽器的地址欄輸入這個網址，Gravatar 返回的會是這樣的： 預設情況下，返回的圖片大小是 80x80 像素，但可以通過在網址的查詢字串中增加 s 參數來請求不同的大小。例如，要獲得我自己的大頭貼為 128x128 像素的圖片，網址是： 另一個可以傳給 Gravatar 作為查詢字串參數的有趣參數是 d，它決定了 Gravatar 為那些沒有在服務上註冊大頭貼的使用者提供什麼圖片。我最喜歡的叫做 “identicon”，它返回一個對於每個電子郵件都不同的漂亮幾何設計。例如： Identicon Gravatar 請注意，一些隱私網頁瀏覽器擴充功能，如 Ghostery，會阻擋 Gravatar 圖片，因為它們認為 Automattic（Gravatar 服務的擁有者）可以根據他們為你的大頭貼所獲得的請求，判斷你訪問了哪些網站。如果你在瀏覽器中看不到大頭貼，請考慮問題可能是由於你在瀏覽器中安裝的擴充功能所導致。 由於大頭貼與使用者相關，將生成大頭貼網址的邏輯新增到使用者模型中是有意義的。 app/models.py: 使用者大頭貼網址 12345678910from hashlib import md5# ...class User(UserMixin, db.Model): # ... def avatar(self, size): digest = md5(self.email.lower().encode('utf-8')).hexdigest() return f'https://www.gravatar.com/avatar/{digest}?d=identicon&amp;s={size}' User 類別的新 avatar() 方法返回使用者大頭貼圖片的網址，按請求的像素大小縮放。對於沒有註冊大頭貼的使用者，將生成一個 “identicon” 圖片。為了生成 MD5 雜湊，我首先將電子郵件轉換為小寫，因為 Gravatar 服務需要這樣做。然後，因為 Python 中的 MD5 支援是在位元組上而不是在字串上工作，我在傳遞給雜湊函式之前將字串編碼為位元組。 如果你有興趣了解 Gravatar 服務提供的其他選項，請訪問他們的文件網站。 下一步是將大頭貼圖片插入到使用者個人資料模板中： app/templates/user.html: 模板中的使用者大頭貼 12345678910111213141516{% extends &quot;base.html&quot; %}{% block content %} &lt;table&gt; &lt;tr valign=&quot;top&quot;&gt; &lt;td&gt;&lt;img src=&quot;{{ user.avatar(128) }}&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;h1 &gt; 使用者: {{ user.username }}&lt;/h1&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;hr&gt; {% for post in posts %} &lt;p&gt; {{post.author.username}} 說: &lt;b&gt;{{ post.body }}&lt;/b&gt; &lt;/p&gt; {% endfor %}{% endblock %} 讓 User 類別負責返回大頭貼網址的好處是，如果有一天我決定不想要 Gravatar 的大頭貼，我只需重寫 avatar() 方法以返回不同的網址，所有的模板就會自動開始顯示新的大頭貼。 我現在在使用者個人資料頁面的頂部有一個漂亮的大大頭貼，但真的沒有理由就此止步。我在底部有一些使用者的貼文，每個貼文也可以有一個小大頭貼。當然，對於使用者個人資料頁面，所有貼文將擁有相同的大頭貼，但後來我可以在主頁面上實施相同的功能，然後每個貼文都將用作者的大頭貼裝飾，那會看起來非常漂亮。 要為個別貼文顯示大頭貼，我只需要在模板中再做一個小改變： app/templates/user.html: 貼文中的使用者大頭貼 12345678910111213141516171819{% extends &quot;base.html&quot; %}{% block content %} &lt;table&gt; &lt;tr valign=&quot;top&quot;&gt; &lt;td&gt;&lt;img src=&quot;{{ user.avatar(128) }}&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;h1 &gt; 使用者: {{ user.username }}&lt;/h1&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;hr&gt; {% for post in posts %} &lt;table&gt; &lt;tr valign=&quot;top&quot;&gt; &lt;td&gt;&lt;img src=&quot;{{ post.author.avatar(36) }}&quot;&gt;&lt;/td&gt; &lt;td&gt;{{ post.author.username }} 說:&lt;br&gt;{{ post.body }}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; {% endfor %}{% endblock %} 使用 Jinja 子模板我設計了使用者檔案頁面，以顯示使用者撰寫的文章和他們的頭像。現在，我想要索引頁面也以類似的佈局顯示文章。我可以複製 / 貼上處理文章呈現的範本部分，但這並不理想，因為如果我稍後決定對這個佈局進行更改，我就必須記得更新這兩個範本。 因此，我將建立一個只渲染一篇文章的子範本，然後從 user.html 和 index.html 範本中引用它。首先，我可以建立只包含單個文章 HTML 標記的子範本。我將這個範本命名為 app/templates/_post.html。下劃線前綴只是一種命名慣例，幫助我識別哪些範本檔案是子範本。 app/templates/_post.html：文章子範本 123456&lt;table&gt; &lt;tr valign=&quot;top&quot;&gt; &lt;td&gt;&lt;img src=&quot;{{ post.author.avatar(36) }}&quot;&gt;&lt;/td&gt; &lt;td&gt;{{ post.author.username }} 說：&lt;br&gt;{{ post.body }}&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 要從 user.html 範本調用這個子範本，我使用 Jinja 的 include 語句： app/templates/user.html：文章中的使用者頭像 1234567891011121314{% extends &quot;base.html&quot; %}{% block content %} &lt;table&gt; &lt;tr valign=&quot;top&quot;&gt; &lt;td&gt;&lt;img src=&quot;{{ user.avatar(128) }}&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;h1 &gt; 使用者：{{ user.username }}&lt;/h1&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;hr&gt; {% for post in posts %} {% include '_post.html' %} {% endfor %}{% endblock %} 目前應用程式的索引頁面還沒有完全制定，所以我還不會在那裡加入這個功能。 更有趣的使用者檔案新的使用者檔案頁面存在的一個問題是，它們並沒有真正展示太多內容。使用者喜歡在這些頁面上談論一些關於他們自己的事情，所以我將允許他們寫一些關於自己的內容顯示在這裡。我還將追踪每個使用者最後訪問網站的時間，並在他們的檔案頁面上顯示。 為了支援所有這些額外的資訊，我需要做的第一件事就是在資料庫中的使用者表擴展兩個新欄位： app/models.py：使用者模型中的新欄位 12345class User(UserMixin, db.Model): # ... about_me: so.Mapped[Optional[str]] = so.mapped_column(sa.String(140)) last_seen: so.Mapped[Optional[datetime]] = so.mapped_column( default=lambda: datetime.now(timezone.utc)) 每次資料庫被修改時，都需要生成資料庫遷移。在第 4 章中，我向你展示了如何設定應用程式來追踪資料庫更改，通過遷移腳本。現在我有兩個新欄位想要加入到資料庫，所以第一步是生成遷移腳本： 12345678(venv) $ flask db migrate -m &quot;new fields in user model&quot;INFO [alembic.runtime.migration] Context impl SQLiteImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.autogenerate.compare] Detected added column 'user.about_me'INFO [alembic.autogenerate.compare] Detected added column 'user.last_seen' Generating migrations/versions/37f06a334dbf_new_fields_in_user_model.py ... done 遷移命令的輸出看起來不錯，因為它顯示出 User 類中的兩個新欄位被檢測到了。現在我可以將這個更改應用到資料庫： 1234(venv) $ flask db upgradeINFO [alembic.runtime.migration] Context impl SQLiteImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.runtime.migration] Running upgrade 780739b227a7 -&gt; 37f06a334dbf, new fields in user model 我希望你意識到使用遷移框架是多麼有用。資料庫中的任何使用者仍然在那裡，遷移框架將遷移腳本中的更改精確應用，而不會破壞任何資料。 對於下一步，我將在使用者檔案範本中加入這兩個新欄位： app/templates/user.html：在使用者檔案範本中顯示使用者資訊 123456789101112131415{% extends &quot;base.html&quot; %}{% block content %} &lt;table&gt; &lt;tr valign=&quot;top&quot;&gt; &lt;td&gt;&lt;img src=&quot;{{ user.avatar(128) }}&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;h1&gt; 使用者：{{ user.username }}&lt;/h1&gt; {% if user.about_me %}&lt;p&gt;{{ user.about_me }}&lt;/p&gt;{% endif %} {% if user.last_seen %}&lt;p &gt; 最後出現於：{{ user.last_seen }}&lt;/p&gt;{% endif %} &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; ...{% endblock %} 注意我使用 Jinja 的條件語句來包裝這兩個欄位，因為我只想在它們設定的情況下才顯示它們。此時，這兩個新欄位對於所有使用者來說都是空的，所以你還不會看到這些欄位。 記錄使用者的最後訪問時間讓我們從 last_seen 欄位開始，這是兩者中較為簡單的一個。我想做的是在給定使用者發送請求給伺服器時，將當前時間寫入這個欄位。 在每個可能從瀏覽器請求的視圖函式中加入登入以設定此欄位顯然是不切實際的，但在視圖函式被派送之前執行一些通用邏輯是 web 應用程式中如此常見的任務，以至於 Flask 將其作為原生功能提供。看看解決方案： app/routes.py：記錄最後訪問時間 1234567from datetime import datetime, timezone@app.before_requestdef before_request(): if current_user.is_authenticated: current_user.last_seen = datetime.now(timezone.utc) db.session.commit() 在 Flask 中，@before_request 裝飾器用來註冊函式，讓它在視圖函式之前執行。這非常有用，因為我可以在應用程式的任何視圖函式之前執行程式碼，且只需寫在一個地方。這個實作簡單檢查 current_user 是否已登入，若是，則將 last_seen 欄位設為目前時間。我之前提到過，伺服器應用程式需要在一致的時間單位下運作，標準做法是使用 UTC 時區。使用系統的本地時間並不是個好主意，因為這樣資料庫中的時間將依你的地點而異。 最後一步是提交資料庫階段，以便將上述變更寫入資料庫。如果你好奇為什麼在提交之前沒有 db.session.add()，請考慮當你引用 current_user 時，Flask-Login 會呼叫使用者載入回呼函式，這會執行一個資料庫查詢，並將目標使用者放入資料庫階段。所以你可以在這個函式中再次加入使用者，但這不是必要的，因為它已經在那裡了。 如果你在進行這項更改後查看你的個人資料頁面，你會看到 “最後上線於” 一行，時間與目前時間非常接近。如果你離開個人資料頁面然後再返回，你會看到時間不斷更新。 我將這些時間戳記儲存在 UTC 時區，這使得個人資料頁面上顯示的時間也是 UTC。除此之外，時間的格式並不是你所期望的，因為它實際上是 Python datetime 物件的內部表示。目前，我不打算擔心這兩個問題，因為我會在後續章節中討論處理網頁應用程式中的日期和時間。 個人資料編輯器我還需要為使用者提供一個表單，讓他們可以輸入一些關於自己的資訊。表單將允許使用者更改他們的使用者名，並寫一些關於他們自己的內容，儲存在新的 about_me 欄位中。讓我們開始寫一個表單類別： app/forms.py：個人資料編輯器表單 123456789from wtforms import TextAreaFieldfrom wtforms.validators import Length# ...class EditProfileForm(FlaskForm): username = StringField('Username', validators=[DataRequired()]) about_me = TextAreaField('About me', validators=[Length(min=0, max=140)]) submit = SubmitField('Submit') 我在這個表單中使用了一種新的欄位類型和一個新的驗證器。對於 “關於” 欄位，我使用 TextAreaField，這是一個多行框，使用者可以在其中輸入文字。為了驗證這個欄位，我使用 Length，確保輸入的文字在 0 到 140 字元之間，這是我為資料庫中對應欄位分配的空間。 下面顯示了渲染此表單的範本： app/templates/edit_profile.html：個人資料編輯器表單 1234567891011121314151617181920212223{% extends &quot;base.html&quot; %}{% block content %} &lt;h1&gt;Edit Profile&lt;/h1&gt; &lt;form action=&quot;&quot;method=&quot;post&quot;&gt; {{form.hidden_tag() }} &lt;p&gt; {{form.username.label}}&lt;br&gt; {{form.username(size=32) }}&lt;br&gt; {% for error in form.username.errors %} &lt;span style=&quot;color: red;&quot;&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt; {{form.about_me.label}}&lt;br&gt; {{form.about_me(cols=50, rows=4) }}&lt;br&gt; {% for error in form.about_me.errors %} &lt;span style=&quot;color: red;&quot;&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt;{{ form.submit() }}&lt;/p&gt; &lt;/form&gt;{% endblock %} 最後，這是將一切綁在一起的視圖函式： app/routes.py：編輯個人資料視圖函式 1234567891011121314151617from app.forms import EditProfileForm@app.route('/edit_profile', methods=['GET', 'POST'])@login_requireddef edit_profile(): form = EditProfileForm() if form.validate_on_submit(): current_user.username = form.username.data current_user.about_me = form.about_me.data db.session.commit() flash('Your changes have been saved.') return redirect(url_for('edit_profile')) elif request.method == 'GET': form.username.data = current_user.username form.about_me.data = current_user.about_me return render_template('edit_profile.html', title='Edit Profile', form=form) 這個視圖函式以略微不同的方式處理表單。如果 validate_on_submit() 返回 True，我會將表單中的資料複製到使用者物件中，然後將物件寫入資料庫。但當 validate_on_submit() 返回 False 時，可能是由於兩個不同的原因。首先，可能是因為瀏覽器剛剛發送了一個 GET 請求，我需要通過提供表單範本的初始版本來回應。當瀏覽器發送帶有表單資料的 POST 請求，但該資料中有些東西無效時，也會發生這種情況。對於這個表單，我需要分別處理這兩種情況。當表單第一次被 GET 請求請求時，我想用資料庫中儲存的資料預填欄位，所以我需要做的恰恰相反，將使用者欄位中儲存的資料移動到表單中，這將確保這些表單欄位擁有使用者目前儲存的資料。但在驗證錯誤的情況下，我不想向表單欄位寫入任何內容，因為它們已經被 WTForms 填充。為了區分這兩種情況，我檢查 request.method，它將是初始請求的 GET，和未通過驗證的提交的 POST。 為了讓使用者更容易進入個人資料編輯頁面，我可以在他們的個人資料頁面中加入一個連結： app/templates/user.html：編輯個人資料連結 123{% if user == current_user %}&lt;p&gt;&lt;a href=&quot;{{ url_for('edit_profile') }}&quot;&gt; 編輯你的個人資料 &lt;/a&gt;&lt;/p&gt;{% endif %} 請留意我使用的巧妙條件，以確保在查看自己的個人資料時出現編輯連結，但在查看其他人的個人資料時則不會出現。","link":"/python/flask-mega-tutorial/chapter_6_profile_page_and_avatars.html"},{"title":"Chapter 7: Error Handling","text":"Posted by on Miguel Grinberg 這是 Flask Mega-Tutorial系列的第七部分，在這裡我要告訴你如何在 Flask 程式中處理錯誤。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 在這一章中，我暫時停止為我的微網誌應用程式寫程式新功能，轉而討論幾種處理錯誤的策略，這些錯誤不可避免地出現在每個軟體專案中。為了說明這個話題，我故意在第六章加入的程式碼中留下了一個錯誤。在你繼續閱讀之前，看看你能不能找到它！ 這一章的 GitHub 連結是：瀏覽、Zip、Diff。 Flask 中的錯誤處理當 Flask 應用程式發生錯誤時會發生什麼？最好的方式是親身體驗。啟動應用程式，確保你至少註冊了兩個使用者。作為其中一個使用者登入，打開個人資料頁面並點擊「編輯」連結。在個人資料編輯器中，嘗試將使用者名稱更改為另一個已經註冊的使用者名稱，然後砰！這將帶來一個可怕的「內部伺服器錯誤」頁面： 如果你查看運行應用程式的終端會話，你會看到錯誤的堆疊追蹤。堆疊追蹤在除錯錯誤時極為有用，因為它們顯示了該堆疊中的呼叫序列，一直到產生錯誤的那一行： 1234567（[2023-04-28 23:59:42,300] ERROR in app: Exception on /edit_profile [POST]追蹤（最近一次呼叫最後）： File &quot;venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py&quot;, line 1963, in _exec_single_context self.dialect.do_execute( File &quot;venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py&quot;, line 918, in do_execute cursor.execute(statement, parameters)sqlite3.IntegrityError: UNIQUE constraint failed: user.username 堆疊追蹤幫助你確定什麼是錯誤。應用程式允許使用者更改使用者名稱，但它沒有驗證新選擇的使用者名稱是否與系統中已有的其他使用者衝突。錯誤來自 SQLAlchemy，它試圖將新的使用者名稱寫入資料庫，但資料庫因使用者名稱列被定義為 unique=True 選項而拒絕它。 重要的是要注意，呈現給使用者的錯誤頁面並未提供有關錯誤的太多訊息，這很好。我絕對不希望使用者知道崩潰是由資料庫錯誤引起的，或者我使用了什麼資料庫，或者我的資料庫中有哪些表和欄位名稱。所有這些訊息都應該保持內部。 但還有一些事情遠非理想。我有一個非常醜陋且不符合應用程式佈局的錯誤頁面。我也有重要的應用程式堆疊追蹤被傾倒在一個我需要不斷監視的終端上，以確保我不會錯過任何錯誤。當然，我還有一個錯誤需要修復。我將解決所有這些問題，但首先，讓我們談談 Flask 的除錯模式。 除錯模式 Debug Mode你在上面看到的錯誤處理方式非常適合在生產伺服器上運行的系統。如果出現錯誤，使用者會得到一個模糊的錯誤頁面（儘管我會使這個錯誤頁面更友好），而錯誤的重要細節則在伺服器進程輸出或日誌檔案中。 但當你在開發你的應用程式時，你可以啟用除錯模式，這是 Flask 在瀏覽器上直接輸出一個非常不錯的除錯器的模式。要啟動除錯模式，停止應用程式，然後設置以下環境變數： 1(venv) $ export FLASK_DEBUG=1 如果你在 Microsoft Windows 上，記得使用 set 而不是 export。 設置了 FLASK_DEBUG 之後，重啟伺服器。你的終端輸出將會與你習慣看到的略有不同： (venv) $ flask run Serving Flask app ‘microblog.py’ (lazy loading) Environment: development 除錯模式：開啟 Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) Restarting with stat 除錯器啟動！ 除錯器 PIN：118-204-854現在再次讓應用程式崩潰，以便在你的瀏覽器中看到互動式除錯器： 除錯器允許你展開每個堆疊框架並查看相應的原始碼。你還可以在任何框架上打開一個 Python 提示，並執行任何有效的 Python 表達式，例如檢查變數的值。 非常重要的一點是，你永遠不要在生產伺服器上以除錯模式運行 Flask 應用程式。除錯器允許使用者在伺服器上遠程執行程式碼，所以它可以是想要滲透你的應用程式或伺服器的惡意使用者的意外禮物。作為額外的安全措施，瀏覽器中運行的除錯器啟動時是鎖定的，首次使用時它會要求輸入 PIN，你可以在 flask run 命令的輸出中看到。 既然我談到了除錯模式，我應該提到啟用除錯模式時的第二個重要功能，那就是重新加載器。這是一個非常有用的開發功能，當源檔案被修改時，它會自動重新啟動應用程式。如果你在除錯模式下運行 flask run，那麼你可以在應用程式上工作，每次你保存檔案時，應用程式都會重新 當我談到偵錯模式時，我應該提到開啟偵錯模式時啟動的第二個重要功能，那就是重載器。這是一個非常實用的開發功能，當源檔案被修改時，它會自動重啟應用程式。如果你在偵錯模式下執行 flask run，你就可以開始編寫你的應用程式，每當你儲存一個檔案時，應用程式就會重啟來加載新的程式碼。 自訂錯誤頁面Flask 提供了一種機制，讓應用程式可以安裝自己的錯誤頁面，這樣你的使用者就不必看到平淡無奇的預設頁面。舉例來說，我們來定義 HTTP 錯誤 404 和 500 的自訂錯誤頁面，這是兩個最常見的錯誤。定義其他錯誤的頁面的方式也是一樣的。 要聲明一個自訂錯誤處理器，使用 @errorhandler 裝飾器。我將把我的錯誤處理器放在一個新的 app/errors.py 模組中。 app/errors.py：自訂錯誤處理器 1234567891011from flask import render_templatefrom app import app, db@app.errorhandler(404)def not_found_error(error): return render_template('404.html'), 404@app.errorhandler(500)def internal_error(error): db.session.rollback() return render_template('500.html'), 500 錯誤函式的工作方式與視圖函式非常相似。對於這兩個錯誤，我返回了各自模板的內容。請注意，這兩個函式在模板之後都返回了一個第二個值，這是錯誤程式碼號碼。對於我迄今為止建立的所有視圖函式，我不需要加入第二個返回值，因為預設的 200（表示成功響應的狀態碼）是我想要的。但在這種情況下，這些是錯誤頁面，所以我希望響應的狀態碼能反映這一點。 500 錯誤的錯誤處理器可能會在數據庫錯誤後被調用，這實際上就是上面提到的使用者名重複的情況。為了確保任何失敗的數據庫會話不會干擾由模板觸發的任何數據庫訪問，我發出了一個會話回滾。這會將會話重置為乾淨的狀態。 這是 404 錯誤的模板： app/templates/404.html：未找到錯誤模板 123456{% extends &quot;base.html&quot; %}{% block content %} &lt;h1&gt;File Not Found&lt;/h1&gt; &lt;p&gt;&lt;a href=&quot;{{ url_for('index') }}&quot;&gt;Back&lt;/a&gt;&lt;/p&gt;{% endblock %} 這是 500 錯誤的模板： app/templates/500.html：內部伺服器錯誤模板 123456789{% extends &quot;base.html&quot; %}{% block content %} &lt;h1&gt;An unexpected error has occurred&lt;/h1&gt; &lt;p&gt;The administrator has been notified. Sorry for the inconvenience!&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;{{ url_for('index') }}&quot;&gt;Back&lt;/a&gt;&lt;/p&gt;{% endblock %} 這兩個模板都繼承自 base.html 模板，這樣錯誤頁面就與應用程式的正常頁面具有相同的外觀和感覺。 要讓這些錯誤處理器在 Flask 中註冊，我需要在應用程式實例建立後導入新的 app/errors.py 模組： app/init.py：導入錯誤處理器 123## ...from app import routes, models, errors 如果你在終端機會話中設置 FLASK_DEBUG=0（或刪除 FLASK_DEBUG 變數），然後再次觸發重複使用者名錯誤，你將會看到一個稍微更友好的錯誤頁面。 通過電子郵件發送錯誤Flask 默認的錯誤處理的另一個問題是沒有通知。任何錯誤的堆棧跟踪都會打印到終端機，這意味著需要監控伺服器進程的輸出來發現錯誤。當你在開發過程中運行應用程式時，這完全沒問題，但一旦應用程式部署在生產伺服器上，沒有人會去看伺服器的輸出，所以需要一個更強大的解決方案。 我認為對於錯誤採取主動的態度非常重要。如果生產版本的應用程式出現錯誤，我希望立刻知道。所以我的第一個解決方案將是配置 Flask 在錯誤發生後立即通過電子郵件發送給我，電子郵件正文中包含錯誤的堆棧跟踪。 第一步是將電子郵件伺服器詳情加入到配置檔中： config.py：電子郵件配置 12345678class Config(object): ## ... MAIL_SERVER = os.environ.get('MAIL_SERVER') MAIL_PORT = int(os.environ.get('MAIL_PORT') or 25) MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS') is not None MAIL_USERNAME = os.environ.get('MAIL_USERNAME') MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD') ADMINS = ['your-email@example.com'] 電子郵件的配置變數包括伺服器和端口、啟用加密連線的布林標誌，以及可選的使用者名和密碼。這五個配置變數都是從它們的環境變數對應項中獲取的。如果環境中沒有設置電子郵件伺服器，則我將以此為標誌，認為需要禁用發送錯誤郵件的功能。電子郵件伺服器端口也可以在環境變數中給出，但如果沒有設置，則使用標準端口 25。電子郵件伺服器憑證默認不使用，但如果需要，可以提供。ADMINS 配置變數是將接收錯誤報告的電子郵件地址列表，因此你自己的電子郵件地址應該在該列表中。 Flask 使用 Python 的日誌套件來寫日誌，這個套件已經能夠透過電子郵件發送日誌。為了讓錯誤發生時可以發送郵件，我需要做的就是將 SMTPHandler 實例加入到 Flask 的 logger 物件，也就是 app.logger： 123456789101112131415161718192021222324## app/__init__.py：透過電子郵件記錄錯誤import loggingfrom logging.handlers import SMTPHandler## ...if not app.debug: if app.config['MAIL_SERVER']: auth = None if app.config['MAIL_USERNAME'] or app.config['MAIL_PASSWORD']: auth = (app.config['MAIL_USERNAME'], app.config['MAIL_PASSWORD']) secure = None if app.config['MAIL_USE_TLS']: secure = () mail_handler = SMTPHandler( mailhost=(app.config['MAIL_SERVER'], app.config['MAIL_PORT']), fromaddr='no-reply@' + app.config['MAIL_SERVER'], toaddrs=app.config['ADMINS'], subject='Microblog Failure', credentials=auth, secure=secure) mail_handler.setLevel(logging.ERROR) app.logger.addHandler(mail_handler)from app import routes, models, errors 正如你看到的，我只在應用程式非除錯模式運行時啟用電子郵件 logger，也就是當 app.debug 為 True，同時郵件伺服器在配置中存在時。 設定電子郵件 logger 有點繁瑣，因為要處理許多郵件伺服器中存在的可選安全選項。但本質上，上面的程式碼建立了一個 SMTPHandler 實例，設定它的級別只報告錯誤而不是警告、資訊或除錯訊息，最後將其附加到 Flask 的 app.logger 物件。 測試這個功能有兩種方法。最簡單的一種是使用 SMTP 除錯伺服器。這是一個假的電子郵件伺服器，它接受郵件，但不發送，而是將它們印到控制台。要運行這個伺服器，打開第二個終端會話，啟動虛擬環境，然後安裝 aiosmtpd 套件： 1(venv) $ pip install aiosmtpd 然後運行以下命令啟動除錯郵件伺服器： 1(venv) $ aiosmtpd -n -c aiosmtpd.handlers.Debugging -l localhost:8025 這個命令尚未打印任何東西，但會等待客戶端連接。讓除錯 SMTP 伺服器運行，然後返回到你的第一個終端，如下配置你的郵件伺服器： 12export MAIL_SERVER=localhostMAIL_PORT=8025 像往常一樣，如果你使用 Microsoft Windows，請使用 set 而不是 export。確保 FLASK_DEBUG 變數設為 0 或根本沒設定，因為應用程式在除錯模式下不會發送郵件。運行應用程式並再次觸發 SQLAlchemy 錯誤，看看運行假電子郵件伺服器的終端會話如何顯示帶有錯誤完整堆疊追蹤的電子郵件。 測試這個功能的第二種方法是配置一個真實的電子郵件伺服器。下面是使用你的 Gmail 帳戶的郵件伺服器配置： 12345export MAIL_SERVER=smtp.googlemail.comexport MAIL_PORT=587export MAIL_USE_TLS=1export MAIL_USERNAME=&lt;your-gmail-username&gt;export MAIL_PASSWORD=&lt;your-gmail-password&gt; 如果你使用 Microsoft Windows，請記得在上述每個語句中使用 set 而不是 export。 你的 Gmail 帳戶中的安全功能可能會阻止應用程式透過它發送郵件，除非你明確允許「較不安全的應用程式」訪問你的 Gmail 帳戶。你可以在這裡閱讀有關此事，如果你擔心帳戶的安全，可以建立一個專門用於測試郵件的次要帳戶，或者可以暫時啟用較不安全的應用程式來運行此測試，然後恢復到預設設定。 另一種選擇是使用專門的電子郵件服務，如 SendGrid，它允許你在一個免費帳戶上每天發送最多 100 封郵件。 記錄到檔案通過電子郵件接收錯誤很好，但有時這還不夠。有些失敗條件不會以 Python 異常結束，也不是大問題，但它們可能仍然足夠有趣，值得保存以供除錯。出於這個原因，我還將為應用程式維護一個日誌檔。 要啟用基於檔案的日誌，需要將另一個處理器，這次是 RotatingFileHandler 類型的，附加到應用程式 logger，類似於電子郵件處理器。 12345678910111213141516171819202122## app/__init__.py：記錄到檔案## ...from logging.handlers import RotatingFileHandlerimport os## ...if not app.debug: ## ... if not os.path.exists('logs'): os.mkdir('logs') file_handler = RotatingFileHandler('logs/microblog.log', maxBytes=10240, backupCount=10) file_handler.setFormatter(logging.Formatter( '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]')) file_handler.setLevel(logging.INFO) app.logger.addHandler(file_handler) app.logger.setLevel(logging.INFO) app.logger.info('Microblog startup') 我正在 logs 目錄中建立名為 microblog.log 的 log 檔案，如果該目錄不存在，我會建立它。 RotatingFileHandler 類別很好用，因為它可以旋轉 logs，確保當應用程式長時間運行時，log 檔案不會變得太大。在這個案例中，我限制 log 檔案的大小為 10KB，並保留最後十個 log 檔案作為備份。 logging.Formatter 類別提供了自訂格式化的 log 訊息。因為這些訊息要寫入檔案，我希望它們包含盡可能多的資訊。所以我使用一種包括時間戳記、log 等級、訊息以及 log 條目來源的檔案和行號的格式。 為了使 logging 更有用，我還將應用程式 logger 和檔案 logger 處理器的 log 等級降低到 INFO 類別。如果你不熟悉 log 類別，它們按嚴重程度遞增的順序是 DEBUG、INFO、WARNING、ERROR`` 和 CRITICAL`。 作為 log 檔案第一個有趣的用途，伺服器每次啟動時都會向 logs 寫入一行。當這個應用程式在生產伺服器上運行時，這些 log 條目將告訴你伺服器何時重新啟動。 修復重複使用者名稱的 Bug我利用使用者名稱重複的 bug 太久了。現在我已經告訴你如何準備應用程式來處理這些類型的錯誤，我可以繼續修復它。 回想一下，RegistrationForm 已經實現了對使用者名稱的驗證，但編輯表單的要求略有不同。在註冊時，我需要確保表單中輸入的使用者名稱不存在於資料庫中。在編輯個人資料表單上，我必須做同樣的檢查，但有一個例外。如果使用者保留了原始使用者名稱，則應該允許通過驗證，因為該使用者名稱已經分配給該使用者。以下是我如何為這個表單實施使用者名稱驗證的： 12345678910111213141516171819## app/forms.py：在編輯個人資料表單中驗證使用者名稱class EditProfileForm(FlaskForm): username = StringField('Username', validators=[DataRequired()]) about_me = TextAreaField('About me', validators=[Length(min=0, max=140)]) submit = SubmitField('Submit') def __init__(self, original_username, *args, **kwargs): super().__init__(*args, **kwargs) self.original_username = original_username def validate_username(self, username): if username.data != self.original_username: user = db.session.scalar(sa.select(User).where( User.username == self.username.data)) if user is not None: raise ValidationError('Please use a different username.') 實作方式是在自訂的驗證方法中，但有一個重載的建構式接受原始使用者名稱作為參數。這個使用者名稱被保存為實例變數，在 validate_username() 方法中進行檢查。如果表單中輸入的使用者名稱與原始使用者名稱相同，則無需檢查資料庫是否有重複。 為了使用這個新的驗證方法，我需要在檢視函式中加入原始使用者名稱參數，建立表單物件時： 1234567## app/routes.py：在編輯個人資料表單中驗證使用者名稱@app.route('/edit_profile', methods=['GET', 'POST'])@login_requireddef edit_profile(): form = EditProfileForm(current_user.username) ## ... 現在 bug 已經修復，大多數情況下都能防止編輯個人資料表單中的重複。這不是一個完美的解決方案，因為當兩個或多個程式同時訪問資料庫時可能不起作用。在這種情況下，競爭狀態可能導致驗證通過，但稍後當嘗試重命名時，資料庫已經被另一個程式更改，無法重命名使用者。這在伺服器進程很多的非常繁忙的應用程式中除外，所以現在我不擔心這個問題。 此時，你可以再次嘗試重現錯誤，看看新的表單驗證方法如何防止它。 永久啟動調試模式Flask 的調試模式非常有用，你可能希望默認開啟它。這可以通過將 FLASK_DEBUG 環境變數加入到 .flaskenv 檔案中來完成。 1234## .flaskenv：Flask 命令的環境變數FLASK_APP=microblog.pyFLASK_DEBUG=1 有了這個更改，當你使用 flask run 命令啟動伺服器時，將啟動調試模式。","link":"/python/flask-mega-tutorial/chapter_7_error_handling.html"},{"title":"Chapter 9: Pagination","text":"Posted by on Miguel Grinberg 這是 Flask Mega-Tutorial 系列的第九部分，在本章中，我將告訴你如何對資料庫條目的列表進行分頁。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 在第八章中，我進行了一些資料庫變更，這對支持社交網絡中非常流行的「追蹤者」模式是必要的。有了這個功能後，我準備移除我在開始時設置的最後一塊臨時搭建，即假貼文。在本章中，應用程式將開始接受來自使用者的部落格貼文，並且在首頁和個人資料頁面以分頁列表的形式呈現它們。 本章的 GitHub 連結為：Browse Zip Diff 提交部落格貼文首頁需要有一個表單，使用者可以在其中輸入新的貼文。首先我建立一個表單類別： app/forms.py: 部落格提交表單。 1234class PostForm(FlaskForm): post = TextAreaField('說點什麼', validators=[ DataRequired(), Length(min=1, max=140)]) submit = SubmitField('提交') 接下來，我可以將這個表單加入到應用程式主頁面的模板中： app/templates/index.html: 首頁模板中的貼文提交表單 123456789101112131415161718192021{% extends &quot;base.html&quot; %}{% block content %} &lt;h1&gt; 嗨，{{ current_user.username }}！&lt;/h1&gt; &lt;form action=&quot;&quot;method=&quot;post&quot;&gt; {{form.hidden_tag() }} &lt;p&gt; {{form.post.label}}&lt;br&gt; {{form.post(cols=32, rows=4) }}&lt;br&gt; {% for error in form.post.errors %} &lt;span style=&quot;color: red;&quot;&gt;[{{ error }}]&lt;/span&gt; {% endfor %} &lt;/p&gt; &lt;p&gt;{{ form.submit() }}&lt;/p&gt; &lt;/form&gt; {% for post in posts %} &lt;p&gt; {{post.author.username}} 說： &lt;b&gt;{{ post.body }}&lt;/b&gt; &lt;/p&gt; {% endfor %}{% endblock %} 這個模板中的更動與之前處理的表單類似。最後一部分是在視圖函數中加入表單的建立和處理： app/routes.py: 首頁視圖函數中的貼文提交表單。 1234567891011121314151617181920212223242526from app.forms import PostFormfrom app.models import Post@app.route('/', methods=['GET', 'POST'])@app.route('/index', methods=['GET', 'POST'])@login_requireddef index(): form = PostForm() if form.validate_on_submit(): post = Post(body=form.post.data, author=current_user) db.session.add(post) db.session.commit() flash('你的貼文現在已發布！') return redirect(url_for('index')) posts = [ { 'author': {'username': 'John'}, 'body': '波特蘭的天氣真好！' }, { 'author': {'username': 'Susan'}, 'body': '《復仇者聯盟》電影太酷了！' } ] return render_template(&quot;index.html&quot;, title='首頁', form=form, posts=posts) 讓我們一一回顧這個視圖函數的變更： 我現在引入了 Post 和 PostForm 類別。 我接受在與首頁視圖函數相關的兩個路由中的 POST 請求，除了 GET 請求， 因為這個視圖函數現在將接收表單數據。3. 表單處理邏輯將一個新的 Post 紀錄插入到資料庫中。4. 模板收到表單物件作為附加參數，這樣它就可以將其渲染到頁面上。 在繼續之前，我想提及一些與網頁表單處理相關的重要事項。請注意，在我處理表單數據後，我通過發送重定向到首頁來結束請求。我本可以輕易地跳過重定向，讓函數繼續進行到模板渲染部分，因為這已經是首頁視圖函數。 那麼，為什麼要發送重定向到相同頁面？因為這是一個標準做法，總是以重定向回應由網頁表單提交產生的 POST 請求。這有助於緩解網頁瀏覽器中刷新命令實現方式的一個煩惱。當你按下刷新鍵時，網頁瀏覽器只是重新發送上一個請求。如果最後的請求是帶有表單提交的 POST 請求，那麼刷新將會重新提交表單。由於這是意料之外的，瀏覽器會要求使用者確認重複提交，但大多數使用者不會理解瀏覽器在詢問什麼。如果 POST 請求以重定向回應，則瀏覽器被指示發送 GET 請求以獲取重定向中指示的頁面，所以現在最後的請求不再是 POST 請求，而刷新命令的工作方式更加可預測。 這個簡單的技巧被稱為 Post/Redirect/Get 模式。它避免了當使用者在提交網頁表單後不慎刷新頁面時，插入重複貼文的情況。 顯示部落格貼文如果你還記得，我建立了一些假的部落格貼文，這些貼文我已經在首頁顯示了很長時間。這些假對象是在 index 視圖函數中明確建立的，作為一個簡單的 Python 列表： 12345678910posts = [ { 'author': {'username': 'John'}, 'body': '波特蘭的天氣真好！' }, { 'author': {'username': 'Susan'}, 'body': '《復仇者聯盟》電影太酷了！' }] 但現在我有了 User 模型中的 following_posts() 方法，它返回一個查詢，用於獲取給定使用者想要看到的貼文。所以現在我可以用真實的貼文替換假貼文： app/routes.py: 在首頁顯示真實貼文。 12345678@app.route('/', methods=['GET', 'POST'])@app.route('/index', methods=['GET', 'POST'])@login_requireddef index(): ## ... posts = db.session.scalars(current_user.following_posts()).all() return render_template(&quot;index.html&quot;, title='首頁', form=form, posts=posts) User 類別的 following_posts 方法返回一個已配置的 SQLAlchemy 查詢物件，用於從資料庫中獲取使用者感興趣的貼文。在執行此查詢並對結果物件調用 all() 後，posts 變數最終包含了所有結果的列表。所以我最終得到的結構非常類似於我一直使用的假貼文。這麼接近以至於模板甚至不需要更改。 使尋找追蹤使用者更容易正如你所注意到的，應用程式在讓使用者尋找其他使用者進行追蹤方面做得不是很好。實際上，根本沒有辦法看到還有哪些其他使用者。我將通過一些簡單的更改來解決這個問題。 我將建立一個新頁面，我將其稱為「探索」頁面。這個頁面的運作方式類似於首頁，但不僅僅顯示追蹤使用者的貼文，還將顯示來自所有使用者的全球貼文流。這是新的探索視圖函數： app/routes.py: 探索視圖函數。 123456@app.route('/explore')@login_requireddef explore(): query = sa.select(Post).order_by(Post.timestamp.desc()) posts = db.session.scalars(query).all() return render_template('index.html', title='探索', posts=posts) 你注意到這個視圖函數中有些奇怪的事情了嗎？render_template() 調用引用了 index.html 模板，我在應用程式的主頁面中使用它。由於這個頁面將與主頁非常相似，我決定重用模板。但與主頁的一個區別是，在探索頁面中我不想有撰寫部落格貼文的表單，所以在這個視圖函數中，我沒有在 render_template() 調用中包括 form 參數。 為了防止 index.html 模板在嘗試渲染不存在的 網頁表單時崩潰，我將加入一個條件，僅在視圖函數傳遞表單時渲染表單： app/templates/index.html: 使部落格貼文提交表單可選。 1234567891011{% extends &quot;base.html&quot; %}{% block content %} &lt;h1&gt; 嗨，{{ current_user.username }}！&lt;/h1&gt; {% if form %} &lt;form action=&quot;&quot;method=&quot;post&quot;&gt; ... &lt;/form&gt; {% endif %} ...{% endblock %} 我還將在導航欄中加入一個連結到這個新頁面，就在首頁連結之後： app/templates/base.html: 導航欄中的探索頁面連結。 1&lt;a href=&quot;{{ url_for('explore') }}&quot;&gt; 探索 &lt;/a&gt; 記得我在第六章介紹的 _post.html 子模板，用於在使用者個人資料頁面渲染部落格貼文嗎？這是一個小模板，從使用者個人資料頁面模板中包含，並在單獨的文件中編寫，這樣它也可以從其他模板中使用。我現在將對它進行一個小改進，那就是將部落格貼文作者的使用者名顯示為可點擊的連結： app/templates/_post.html: 在部落格貼文中顯示作者連結。 1234567891011&lt;table&gt; &lt;tr valign=&quot;top&quot;&gt; &lt;td&gt;&lt;img src=&quot;{{ post.author.avatar(36) }}&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;{{ url_for('user', username=post.author.username) }}&quot;&gt; {{post.author.username}} &lt;/a&gt; 說：&lt;br&gt;{{ post.body }} &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 我現在可以使用這個子模板在首頁和探索頁面渲染部落格貼文： app/templates/index.html: 使用部落格貼文子模板。 12345...{% for post in posts %} {% include '_post.html' %}{% endfor %}... 子模板期望存在一個名為 post 的變數，這正是 index 模板中的循環變數的名稱，所以這樣做非常完美。 通過這些小改動，應用程式的可用性大大提升。現在使用者可以訪問探索頁面閱讀來自未知使用者的部落格貼文，並根據這些貼文找到新的使用者進行追蹤，這可以通過簡單地點擊使用者名來訪問個人資料頁面來完成。很棒，對吧？ 此時，我建議你再次嘗試應用程式，以便體驗這些最新的使用者界面改進。你可能還想建立一些不同的使用者，並以他們的身份撰寫貼文，這樣系統就有來自多個使用者的多樣化內容。 部落格貼文的分頁應用程式看起來比以往更好，但在首頁顯示所有追蹤的貼文將很快成為一個問題。想像一下，如果一個使用者追蹤了一千篇貼文，甚至一百萬篇？你可以想像，管理這麼大的貼文列表會非常慢且低效。 為了解決這個問題，我打算對貼文列表進行分頁。這意味著我最初只會一次顯示有限數量的貼文，並包括向前和向後導航的連結，以瀏覽完整的貼文列表。Flask-SQLAlchemy 通過 db.paginate() 函數原生支持分頁，這個函數的工作方式類似於 db.session.scalars()，但內建了分頁功能。例如，如果我想獲取使用者的前二十篇追蹤貼文，我可以這樣做： 12&gt;&gt;&gt; query = sa.select(Post).order_by(Post.timestamp.desc())&gt;&gt;&gt; posts = db.paginate(query, page=1, per_page=20, error_out=False).items paginate 函數可以在任何查詢上調用。它接受幾個參數，其中以下三個最為重要： page：頁碼，從 1 開始 per_page：每頁的項目數 error_out：錯誤標誌。如果為 True，當請求範圍外的頁面時，將自動向客戶端返回 404 錯誤。如果為 False，對於範圍外的頁面將返回空列表。 從 db.paginate() 返回的值是一個 Pagination 對象。這個對象的 items 屬性包含了請求頁面中的項目列表。Pagination 對象中還有其他有用的東西，我稍後會討論。 現在讓我們思考一下我如何在 index() 視圖函數中實現分頁。我可以從在應用程式中加入一個配置項開始，以確定每頁將顯示多少項目。 config.py: 每頁貼文配置。 123class Config(object): ## ... POSTS_PER_PAGE = 3 在配置文件中擁有這些可以改變行為的應用程式範圍 “旋鈕” 是個好主意，因為這樣我可以去一個地方進行調整。在最終的應用程式中，我當然會使用比每頁三個項目更大的數字，但對於測試來說，使用小數字是有用的。 接下來，我需要決定如何將頁碼納入應用程式的 URL 中。一種相當普遍的方式是使用查詢字串參數來指定一個可選的頁碼，如果沒有給出，則默認為第 1 頁。這裡有一些範例 URL，展示了我將如何實現這一點： 第 1 頁，隱式：http://localhost:5000/index 第 1 頁，顯式：http://localhost:5000/index?page=1 第 3 頁：http://localhost:5000/index?page=3 要訪問查詢字串中給出的參數，我可以使用 Flask 的 request.args 物件。你已經在第 5 章中看到過這一點，當時我實現了來自 Flask-Login 的使用者登錄 URL，有時會包括一個 next 查詢字串參數。 下面你可以看到我如何向首頁和探索視圖函數中加入分頁： app/routes.py: 跟隨者關聯表 12345678910111213141516171819@app.route('/', methods=['GET', 'POST'])@app.route('/index', methods=['GET', 'POST'])@login_requireddef index(): ## ... page = request.args.get('page', 1, type=int) posts = db.paginate(current_user.following_posts(), page=page, per_page=app.config['POSTS_PER_PAGE'], error_out=False) return render_template('index.html', title='首頁', form=form, posts=posts.items)@app.route('/explore')@login_requireddef explore(): page = request.args.get('page', 1, type=int) query = sa.select(Post).order_by(Post.timestamp.desc()) posts = db.paginate(query, page=page, per_page=app.config['POSTS_PER_PAGE'], error_out=False) return render_template(&quot;index.html&quot;, title='探索', posts=posts.items) 這些更改使得這兩個路由決定要顯示的頁碼，要麼從 page 查詢字串參數，要麼從默認值 1，然後使用 paginate() 方法僅檢索所需頁面的結果。確定頁面大小的 POSTS_PER_PAGE 配置項目通過 app.config 物件訪問。 注意這些更改有多麼簡短，並且每次更改時受影響的程式碼量很小。我嘗試寫應用程式的每一部分，而不對其他部分的工作方式做任何假設，這使我能夠寫出模組化且健壯的應用程式，這些應用程式更容易擴展和測試，並且不太可能失敗或有錯誤。 繼續並嘗試分頁支持。首先確保你已經寫了超過三篇部落格貼文。在探索頁面上更容易看到這一點，它顯示了來自所有使用者的貼文。現在你只會看到最近的三篇貼文。如果你想看下一個三篇，請在瀏覽器的地址欄中輸入 http://localhost:5000/explore?page=2。 頁面導航 Page Navigation下一個更改是在部落格貼文列表底部加入連結，讓使用者可以導航到下一頁或 / 和上一頁。記得我提到過 paginate() 調用的返回值是來自 Flask-SQLAlchemy 的 Pagination 類的對象嗎？到目前為止，我已經使用了這個對象的 items 屬性，其中包含了為選定頁面檢索的項目列表。但這個對象還有一些其他屬性，在構建分頁連結時非常有用： has_next：如果當前頁面後面至少還有一頁，則為 True has_prev：如果當前頁面前面至少還有一頁，則為 True next_num：下一頁的頁碼 prev_num：上一頁的頁碼 使用這四個元素，我可以生成下一頁和上一頁的連結，並將它們傳遞給模板進行呈現： app/routes.py: Next and previous page links. 123456789101112131415161718192021222324252627282930@app.route('/', methods=['GET', 'POST'])@app.route('/index', methods=['GET', 'POST'])@login_requireddef index(): ## ... page = request.args.get('page', 1, type=int) posts = db.paginate(current_user.following_posts(), page=page, per_page=app.config['POSTS_PER_PAGE'], error_out=False) next_url = url_for('index', page=posts.next_num) \\ if posts.has_next else None prev_url = url_for('index', page=posts.prev_num) \\ if posts.has_prev else None return render_template('index.html', title='Home', form=form, posts=posts.items, next_url=next_url, prev_url=prev_url) @app.route('/explore') @login_required def explore(): page = request.args.get('page', 1, type=int) query = sa.select(Post).order_by(Post.timestamp.desc()) posts = db.paginate(query, page=page, per_page=app.config['POSTS_PER_PAGE'], error_out=False) next_url = url_for('explore', page=posts.next_num) \\ if posts.has_next else None prev_url = url_for('explore', page=posts.prev_num) \\ if posts.has_prev else None return render_template(&quot;index.html&quot;, title='Explore', posts=posts.items, next_url=next_url, prev_url=prev_url) 這兩個視圖函數中的 next_url 和 prev_url`` 將被設置為 Flask 的 url_for()函數返回的 URL，但僅在該方向有頁面可前往時才會設置。如果當前頁面位於貼文集合的端點之一，則 Pagination 物件的has_next或has_prev` 屬性將為 False，此時該方向的連結將設置為 None。 url_for() 函數的一個有趣方面是，你可以向它加入任何關鍵字參數，如果這些參數的名稱不是路由定義的 URL 的一部分，那麼 Flask 將它們作為查詢參數包含在內。 分頁連結被設置到 index.html 模板中，現在讓我們在頁面上的貼文列表下方渲染它們： app/templates/index.html: 在模板上渲染分頁連結。 1234567891011...{% for post in posts %} {% include '_post.html' %}{% endfor %}{% if prev_url %}&lt;a href=&quot;{{ prev_url}}&quot;&gt; 較新的貼文 &lt;/a&gt;{% endif %}{% if next_url %}&lt;a href=&quot;{{ next_url}}&quot;&gt; 較舊的貼文 &lt;/a&gt;{% endif %}... 這項更改在首頁和探索頁面的貼文列表下方新增了兩個連結。第一個連結標記為「較新的貼文」，指向前一頁（請記住我按最新排序顯示貼文，所以第一頁是最新內容的頁面）。第二個連結標記為「較舊的貼文」，指向下一頁貼文。如果這兩個連結中的任何一個為 None，則它會通過條件從頁面上省略。 使用者個人資料頁面的分頁對首頁的更改目前足夠了。然而，使用者個人資料頁面上也有一個貼文列表，僅顯示該個人資料擁有者的貼文。為了保持一致性，應該將使用者個人資料頁面更改為與首頁的分頁風格相匹配。 我首先更新使用者個人資料視圖函數，該函數仍然包含一個假貼文物件列表。 app/routes.py: 使用者個人資料視圖函數中的分頁。 12345678910111213141516@app.route('/user/&lt;username&gt;')@login_requireddef user(username): user = db.first_or_404(sa.select(User).where(User.username == username)) page = request.args.get('page', 1, type=int) query = user.posts.select().order_by(Post.timestamp.desc()) posts = db.paginate(query, page=page, per_page=app.config['POSTS_PER_PAGE'], error_out=False) next_url = url_for('user', username=user.username, page=posts.next_num) \\ if posts.has_next else None prev_url = url_for('user', username=user.username, page=posts.prev_num) \\ if posts.has_prev else None form = EmptyForm() return render_template('user.html', user=user, posts=posts.items, next_url=next_url, prev_url=prev_url, form=form) 為了從使用者那裡獲取貼文列表，我利用了 user.posts 關係被定義為僅寫關係的事實，這意味 著該屬性具有返回相關物件查詢的 select() 方法。我取這個查詢並加入 order_by() 子句，以便首先獲得最新的貼文，然後像我對首頁和探索頁面中的貼文那樣進行分頁。請注意，此頁面中由 url_for() 函數生成的分頁連結需要額外的 username 參數，因為它們指回使用者個人資料頁面，該頁面的 URL 中有這個使用者名作為動態組件。 最後，user.html 模板的更改與我在首頁所做的相同： app/templates/user.html: 使用者個人資料模板中的分頁連結。 12345678910...{% for post in posts %} {% include '_post.html' %}{% endfor %}{% if prev_url %}&lt;a href=&quot;{{ prev_url}}&quot;&gt; 較新的貼文 &lt;/a&gt;{% endif %}{% if next_url %}&lt;a href=&quot;{{ next_url}}&quot;&gt; 較舊的貼文 &lt;/a&gt;{% endif %} 在你完成對分頁功能的實驗後，你可以將 POSTS_PER_PAGE 配置項設置為一個更合理的值： config.py: 每頁貼文配置。 123class Config(object): ## ... POSTS_PER_PAGE = 25","link":"/python/flask-mega-tutorial/chapter_9_pagination.html"},{"title":"Chapter 8 : Followers","text":"Posted by on Miguel Grinberg 在這一章中，我將進一步開發應用程式的資料庫。我希望應用程式的使用者能夠輕鬆選擇他們想要追蹤的其他使用者。因此，我將擴充資料庫以追蹤誰追蹤了誰，這比你想像的還要複雜。 目錄 Chapter 1: Hello, World! Chapter 2: Templates Chapter 3: Web Forms Chapter 4: Database Chapter 5: User Logins Chapter 6: Profile Page and Avatars Chapter 7: Error Handling Chapter 8: Followers Chapter 9: Pagination Chapter 10: Email Support Chapter 11: Facelift Chapter 12: Dates and Times Chapter 13: I18n and L10n Chapter 14: Ajax Chapter 15: A Better Application Structure Chapter 16: Full-Text Search Chapter 17: Deployment on Linux Chapter 19: Deployment on Docker Containers Chapter 20: Some JavaScript Magic Chapter 21: User Notifications Chapter 22: Background Jobs Chapter 23: Application Programming Interfaces （APIs） 你正在閱讀 Flask Mega-Tutorial 的 2024 年版本。完整的課程也可以在 Amazon 以電子書和平裝書的形式訂購。感謝你的支持！如果你正在尋找 2018 年版本的課程，你可以在這裡找到它。 本章的 GitHub 連結有：Browse Zip Diff 重新探討資料庫關係我上面提到，我想要維護每個使用者的「被追蹤者」和「追蹤者」名單。不幸的是，關聯式資料庫並沒有我可以用於這些名單的列表類型，只有包含記錄和這些記錄之間關係的表格。 資料庫有一個代表使用者的表格，所需要的是找出可以模型化追蹤者 / 被追蹤者連結的適當關係類型。這是回顧基本資料庫關係類型的好時機： 一對多我在第四章中已經使用了一對多關係。這是這種關係的圖示： 由這種關係連結的兩個實體是使用者和帖子。我說一個使用者有許多帖子，一個帖子有一個使用者（或作者）。這種關係在資料庫中通過在「多」方使用外鍵來表示。在上面的關係中，外鍵是加入到帖子表的 user_id 欄位。這個欄位將每個帖子連結到使用者表中其作者的記錄。 很明顯，user_id 欄位提供了對給定帖子作者的直接訪問，但反過來呢？為了使關係有用，我應該能夠獲取由給定使用者撰寫的帖子列表。帖子表中的 user_id 欄位也足以回答這個問題，因為這一列被賦予了索引，以便於像「檢索所有 user_id 為 X 的帖子」這樣的有效查詢。 多對多多對多關係稍微複雜一些。例如，考慮一個有學生和老師的資料庫。我可以說一個學生有許多老師，一個老師有許多學生。這就像是從兩端重疊的兩個一對多關係。 對於這種類型的關係，我應該能夠查詢資料庫並獲得教導給定學生的老師名單，以及老師班上的學生名單。在關聯式資料庫中實際上不容易表示這一點，因為不能通過向現有表加入外鍵來完成。 表示多對多關係需要使用一個稱為關聯表的輔助表。以下是學生和老師範例的資料庫外觀： 儘管一開始可能不明顯，但具有兩個外鍵的關聯表能夠有效回答有關關係的所有查詢。 多對一與一對一多對一關係類似於一對多關係。區別在於這種關係是從「多」方來看的。 一對一關係是一對多的特例。表示方式類似，但在資料庫中加入了一個約束，以防止「多」方有多於一個連結。雖然在某些情況下這種類型的關係很有用，但它不像其他類型那麼常見。 表示追蹤者查看所有關係類型的摘要，很容易確定追蹤追蹤者的適當數據模型是多對多關係，因為一個使用者追蹤許多使用者，並且一個使用者有許多追蹤者。但這裡有一個轉折。在學生和老師的例子中，我有兩個通過多對多關係相關的實體。但在追蹤者的情況下，我有使用者追蹤其他使用者，所以只有使用者。那麼多對多關係的第二個實體是什麼？ 關係的第二個實體也是使用者。一個類別的實例與同一類別的其他實例相連的關係稱為自我參照關係，這正是我在這裡擁有的。 這是追蹤追蹤者的自我參照多對多關係圖： 追蹤者表是這種關係的關聯表。該表中的外鍵都指向使用者表中的條目，因為它將使用者與使用者連接。該表中的每條記錄代表一個追蹤者使用者和一個被追蹤者使用者之間的一個連結。像學生和老師的例子一樣，像這樣的設置允許資料庫回答我將需要的有關被追蹤者和追蹤者的所有問題。相當整齊。 資料庫模型表示讓我們首先將追蹤者加入到資料庫。這是追蹤者關聯表。確保將其加入在 models.py 中的 User 模型上方，以便稍後模型可以參考它。 app/models.py: 追蹤者關聯表 12345678followers = sa.Table( 'followers', db.metadata, sa.Column('follower_id', sa.Integer, sa.ForeignKey('user.id'), primary_key=True), sa.Column('followed_id', sa.Integer, sa.ForeignKey('user.id'), primary_key=True)) 這是我在上面圖表中的關聯表的直接翻譯。請注意，我並未像對 users 和 posts 表那樣宣告這個表為一個模型。由於這是一個輔助表，除了外鍵之外沒有其他數據，我沒有建立相關的模型類別。 sa.Table 類別直接代表一個資料庫表格。表名作為第一個參數。第二個參數是元數據 (metadata)，是 SQLAlchemy 儲存資料庫中所有表格資訊的地方。在使用 Flask-SQLAlchemy 時，可以透過 db.metadata 獲得元數據實例。這個表的欄位是由 sa.Column 的實例初始化，包括欄位名、類型和選項。對於這個表，外鍵中沒有獨特的值可作為它們自己的主鍵，但外鍵的配對是唯一的。因此，兩個欄位都標記為主鍵。這稱為複合主鍵。 在 users 表中定義兩個多對多關係屬性： app/models.py：多對多 followers 關係 12345678910class User(UserMixin, db.Model): # ... following: so.WriteOnlyMapped['User'] = so.relationship( secondary=followers, primaryjoin=(followers.c.follower_id == id), secondaryjoin=(followers.c.followed_id == id), back_populates='followers') followers: so.WriteOnlyMapped['User'] = so.relationship( secondary=followers, primaryjoin=(followers.c.followed_id == id), secondaryjoin=(followers.c.follower_id == id), back_populates='following') 這個關係的設定不是那麼簡單。就像我對 posts 一對多關係所做的那樣，我使用 so.relationship 函式在模型類別中定義關係。但由於這個關係在兩邊都使用相同的模型，所以兩個關係屬性是一起定義的。 這個關係將 User 實例連結到其他 User 實例，作為約定，我們說這種關係中的左側使用者正在關注右側的使用者。我從左側使用者的角度定義名為 following 的關係，因為當我從左側查詢這個關係時，會得到左側使用者正在關注的使用者列表。相反地，followers 關係從右側開始，找出所有關注給定使用者的使用者。 兩個關係都使用 so.WriteOnlyMapped 類型定義，就像 posts 關係一樣。讓我們逐一檢查 so.relationship() 調用的參數： secondary 配置用於此關係的關聯表，我在這個類別上方定義了它。 primaryjoin 表示連接實體到關聯表的條件。在 following 關係中，使用者必須與關聯表的 follower_id 屬性匹配，所以條件反映了這一點。followers.c.follower_id 表達式引用關聯表的 follower_id 欄位。在 followers 關係中，角色是相反的，所以使用者必須與 followed_id 欄位匹配。 secondaryjoin 表示連接關聯表到關係另一邊使用者的條件。在 following 關係中，使用者必須與 followed_id 欄位匹配，而在 followers 關係中，使用者必須與 follower_id 欄位匹配。 如果這很難理解，不用擔心。我將在一會兒向你展示如何處理這些查詢，然後一切都會變得更清晰。 在新的資料庫遷移中記錄更改12345678910(venv) $ flask db migrate -m &quot;followers&quot;INFO [alembic.runtime.migration] Context impl SQLiteImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.autogenerate.compare] Detected added table 'followers' Generating /home/miguel/microblog/migrations/versions/ae346256b650_followers.py ... done(venv) $ flask db upgradeINFO [alembic.runtime.migration] Context impl SQLiteImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.runtime.migration] Running upgrade 37f06a334dbf -&gt; ae346256b650, followers 加入和移除「關注」感謝 SQLAlchemy ORM，使用者關注另一使用者可以在資料庫中記錄，並像操作列表那樣操作 following 和 followers 關係。例如，如果我有兩個存儲在 user1 和 user2 變數中的使用者，我可以使用這個簡單的語句讓第一個關注第二個： 1user1.following.add(user2) 要停止關注使用者，我可以這樣做： 1user1.following.remove(user2) 儘管加入和移除關注者相當簡單，我想在我的程式碼中推廣可重用性，所以我不打算在程式碼中隨意加入「adds」和「removes」。相反，我將在 User 模型中實現「關注」和「取消關注」功能作為方法。最好將應用邏輯從視圖函式移動到模型或其他輔助類別或模組中，因為你稍後會在本章看到，這樣做使單元測試變得更容易。 以下是在使用者模型中處理關注關係的更改： app/models.py：加入和移除關注者 123456789101112131415161718192021222324class User(UserMixin, db.Model): #... def follow(self, user): if not self.is_following(user): self.following.add(user) def unfollow(self, user): if self.is_following(user): self.following.remove(user) def is_following(self, user): query = self.following.select().where(User.id == user.id) return db.session.scalar(query) is not None def followers_count(self): query = sa.select(sa.func.count()).select_from( self.followers.select().subquery()) return db.session.scalar(query) def following_count(self): query = sa.select(sa.func.count()).select_from( self.following.select().subquery()) return db.session.scalar(query) 追隨與取消追隨的方法follow() 和 unfollow() 方法使用了我之前展示的 add() 和 remove() 方法，這些方法屬於只寫關係物件。但在操作關係之前，它們會先使用 is_following() 輔助方法，以確保所請求的動作是合理的。例如，如果我要求 user1 追隨 user2，但事實上這種追隨關係在資料庫中已經存在，我就不想加入重複的資料。取消追隨的邏輯也是一樣的。 確認是否已追隨is_following() 方法會對追隨關係進行查詢，看看特定使用者是否已經包含在其中。所有只寫關係都有一個 select() 方法，它構建一個查詢，返回關係中的所有元素。在這種情況下，我不需要請求所有元素，我只是在尋找一個特定的使用者，所以我可以用 where() 子句限制查詢。 追隨者和追隨數量的方法followers_count() 和 following_count() 方法返回使用者的追隨者和追隨數量。這需要一種不同類型的查詢，其結果不是返回，而是只返回它們的數量。這些查詢的 sa.select() 子句指定了 SQLAlchemy 中的 sa.func.count() 函式，表示我想獲得函式的結果。然後加入了 select_from() 子句，以及需要計數的查詢。每當一個查詢作為更大查詢的一部分時，SQLAlchemy 要求將內部查詢通過調用 subquery() 方法轉換為子查詢。 獲取已追隨使用者的貼文資料庫中對追隨者的支援幾乎完成，但我實際上還缺少一個重要功能。在應用程式的首頁，我將顯示所有被登入使用者追隨的人所撰寫的部落格文章，所以我需要制定一個資料庫查詢，以返回這些文章。 最明顯的解決方案是使用一個返回已追隨使用者列表的查詢，這會是 user.following.select()。執行這個查詢後，我可以進行另一個查詢，以獲得每個返回使用者的文章。一旦我有了所有文章，我可以將它們合併成一個單一列表，並按日期排序。聽起來不錯？其實不然。 這種方法有幾個問題。如果一個使用者追隨了一千人呢？我需要執行一千個資料庫查詢，才能收集所有文章。然後我還需要在內存中合併和排序這一千個列表。作為次要問題，考慮到應用程式的首頁最終會實現分頁，所以它不會顯示所有可用文章，只顯示最初的幾篇，並提供一個鏈 接以獲取更多（如果需要）。如果我要按日期顯示文章，除非我首先獲得所有文章並對它們進行排序，否則我怎麼知道哪些文章是所有已追隨使用者中最近的呢？這實際上是一個糟糕的解決方案，不具備擴展性。 要避免合併和排序部落格文章是不可能的，但在應用程式中這樣做會導致非常低效的過程。關係型資料庫擅長這類工作。資料庫有索引，使其能夠以比我在我的側面可能做到的更有效的方式執行查詢和排序。所以我真正想要的是提出一個單一的資料庫查詢，定義我想獲得的資訊，然後讓資料庫以最有效的方式提取出這些資訊。 下面你可以看到這個查詢： app/models.py: 追隨的文章查詢 123456789101112class User(UserMixin, db.Model): #... def following_posts(self): Author = so.aliased(User) Follower = so.aliased(User) return ( sa.select(Post) .join(Post.author.of_type(Author)) .join(Author.followers.of_type(Follower)) .where(Follower.id == self.id) .order_by(Post.timestamp.desc()) ) 這是我在這個應用程式中使用過的最複雜的查詢。我將逐一解析這個查詢。暫時忽略兩個 so.aliased() 調用，當你看這個查詢的結構時，會注意到它由兩個 join() 子句、where() 和 order_by() 四個主要部分定義： 12345sa.select(Post) .join(...) .join(...) .where(...) .order_by(...) Joins要了解連接操作是什麼，讓我們看一個例子。假設我有一個 User 表，內容如下： id username 1 john 2 susan 3 mary 4 david 為了簡化問題，我沒有顯示使用者模型中的所有欄位，只顯示對這個查詢重要的部分。 假設追隨者關聯表說，使用者 john 追隨使用者 susan 和 david，使用者 susan 追隨 mary，使用者 mary 追隨 david。代表上述的資料是這樣的： follower_id followed_id 1 2 1 4 2 3 3 4 最後，posts 表包含來自每個使用者的一篇文章： id text user_id 1 post from susan 2 2 post from mary 3 3 post from david 4 4 post from john 1 這個表也省略了一些不是討論部分的欄位。 這是查詢的第一部分，包括第一個 join() 子句，現在暫時去掉 of_type(Author)，我稍後會解釋： 12sa.select(Post) .join(Post.author) 查詢中的選擇部分查詢的 select() 部分定義了需要獲取的實體，在這個案例中是貼文。接下來我要做的是將貼文資料表中的條目與 Post.author 關係進行連接。 連接（Join）是一種資料庫操作，它根據給定的條件結合兩個資料表中的行。組合後的資料表是一個臨時的資料表，在資料庫中並不存在，但在查詢過程中可以使用。當 join() 子句以一個關係作為參數時，SQLAlchemy 會結合關係的左右兩側的行。 以我上面定義的範例資料為例，對 Post.author 關係進行連接操作的結果是： post.id post.text post.user_id user.id user.username 1 post from susan 2 2 susan 2 post from mary 3 3 mary 3 post from david 4 4 david 4 post from john 1 1 john 你可能會注意到，在連接的資料表中 post.user_id 和 user.id 欄位的值總是相同的。因為我要求在 Post.author 關係上進行連接，這個關係將貼文連結到其作者，所以 SQLAlchemy 知道它需要將貼文資料表中的行與使用者資料表中的行相匹配。 實際上，上述連接所做的是建立一個擴展表，提供對貼文以及每個貼文的作者資訊的訪問。 不幸的是，現在事情變得更複雜了，因為接下來我需要再次連接上面的組合表，以加入追隨者。一旦我有了一個組合表，每行都有一個追隨者和他們所追隨的貼文以及該貼文的作者，然後我就可以輕鬆過濾出任何特定使用者應該看到的貼文。 這麼複雜的一個原因是，對於這個查詢，我們需要以兩種身份處理使用者。在上面的連接中，使用者是貼文的作者，但在第二次連接中，我需要將使用者視為其他使用者的追隨者。為了能夠清楚地告訴 SQLAlchemy 如何連接所有這些資料表，我需要有一種方法來獨立地作為作者和追隨者引用使用者。so.aliased() 的呼叫被用來建立兩個我可以在查詢中使用的 User 模型的參考。 因此，這個查詢中的第一次連接，它關注於將貼文與其作者結合起來，可以寫成如下： 123Author = so.aliased(User)sa.select(Post) .join(Post.author.of_type(Author)) 這裡 of_type(Author) 限定符在連接關係上告訴 SQLAlchemy，在查詢的其餘部分我將使用 Author 別名來引用關係的右側實體。 現在讓我們看看查詢中的第二次連接12345Author = so.aliased(User)Follower = so.aliased(User)sa.select(Post) .join(Post.author.of_type(Author)) .join(Author.followers.of_type(Follower)) 對於第二次連接，我希望 SQLAlchemy 在 Author.followers 關係上進行連接，其中 Author 是上面定義的 User 的別名。這是一個多對多關係，因此追隨者關聯資料表必須隱含地成為連接的一部分。由於這個新連接，加入到組合資料表中的使用者將使用 Follower 別名。 User.followers 關係在關聯資料表中的左側有追隨的使用者，由 followed_id 外鍵定義，右側有他們的追隨者，由 follower_id 外鍵定義。使用上面的範例追隨者關聯資料表，結合了貼文、它們的作者和它們的追隨者的資料表是： post.id post.text post.user_id author.id author.username follower.id follower.username 1 post from susan 2 2 susan 1 john 2 post from mary 3 3 mary 2 susan 3 post from david 4 4 david 1 john 3 post from david 4 4 david 3 mary 關於這次連接的結果有幾點有趣的事情要提到。首先，現在資料表中的每一行都有作為作者的使用者和作為追隨者的使用者，所以必須使用別名以避免混淆。 在這個連接的資料表中，post.id == 3 的貼文出現了兩次。你能告訴為什麼嗎？這篇貼文的作者是 david，user.id == 4。在追隨者關聯資料表中查找這個使用者，followed_id 外鍵下有 1 和 3 兩個使用者的條目，這意味著 david 被 john 和 mary 所追隨。由於這兩個使用者都必須與 david 寫的這篇貼文連接，所以連接操作建立了兩行，每行都有一個連接的使用者。 還有一篇貼文根本沒有出現。這是 post.id == 4，由 john 寫的。根據追隨者關聯資料表，沒有人追隨這個使用者，所以沒有追隨者可以與之匹配，因此連接將這篇貼文從結果中刪除。 過濾器 Filtersjoin 操作讓我獲得一個列表，列出所有被某個使用者關注的貼文，這比我實際想要的數據多了很多。我只對這個列表的一個子集感興趣，也就是只被一個使用者關注的貼文，所以我需要移除我不需要的所有條目，我可以用 where() 子句來做到這點。 這裡是查詢的過濾部分： 1.where(Follower.id == self.id) 由於這個查詢在 User 類別的方法中，self.id 表達式指的是我感興趣的使用者的 ID。where() 呼叫選擇了加入表中將這個使用者作為關注者的項目。記得，在這個查詢中的 Follower 是對 User 的別名，這是必須的，讓 SQLAlchemy 知道兩個使用者中哪一個是過濾條件的基礎。 假設我感興趣的使用者是 john，他的 ID 欄位設為 1。這是過濾後聯接表的樣子： post.id post.text post.user_id author.id author.username follower.id follower.username 1 post from susan 2 2 susan 1 john 3 post from david 4 4 david 1 john 這些正是我想要的貼文！ 記得這個查詢是在 Post 類別上發出的，所以即使我最後得到了一個更大的表，這個表是作為這個查詢的一部分由數據庫建立的，結果將是這個臨時表中包含的貼文，不包括加入操作加入的額外欄位。 排序 Sorting過程的最後一步是對結果進行排序。查詢中做到這一點的部分是： 1.order_by(Post.timestamp.desc()) 這裡我說的是我想按照貼文的 timestamp 欄位以降序排序結果。按照這種排序，第一個結果將是最新的博客貼文。 結合自己的和關注的貼文我在 followed_posts() 函式中使用的查詢非常有用，但有一個限制。人們期望在他們關注的使用者時間線上看到自己的貼文，而上面定義的查詢並不包括使用者自己的貼文。 有兩種可能的方式來擴展這個查詢，以包括使用者自己的貼文。最直接的方式是保留查詢原樣，但確保所有使用者都關注自己。如果你是自己的關注者，那麼上面顯示的查詢將找到你自己的貼文以及你關注的所有人的貼文。這種方法的缺點是它會影響關注者計數。所有關注者計數將被增加一個，所以在顯示之前必須進行調整。 另一種做法是擴展查詢邏輯，讓結果來自於關注的貼文或使用者自己的。 經過考慮兩種選擇後，我決定採用第二種。下面你可以看到 following_posts() 方法在包括使用者自己的貼文通過聯合後的樣子： app/models.py: 包括使用者自己的貼文的關注貼文查詢。 1234567891011121314def following_posts(self): Author = so.aliased(User) Follower = so.aliased(User) return ( sa.select(Post) .join(Post.author.of_type(Author)) .join(Author.followers.of_type(Follower), isouter=True) .where(sa.or_( Follower.id == self.id, Author.id == self.id, )) .group_by(Post) .order_by(Post.timestamp.desc()) ) 這個查詢的結構現在如下： 123456sa.select(Post) .join(...) .join(..., isouter=True) .where(sa.or_(..., ...)) .group_by(...) .order_by(...) Outer JOIN (外部連結)第二個 join 現在是一個外部連接。你還記得上一節中提到的由 john 寫的貼文嗎？當第二個 join 被計算時，這篇貼文被丟棄了，因為這個使用者沒有關注者。為了能夠包括使用者自己的貼文，首先需要將 join 更改為保留在 join 右側沒有匹配項目的貼文。之前節中使用的連接稱為內部連接，只保留左側有右側匹配條目的條目。isouter=True 選項告訴 SQLAlchemy 使用左外部連接，它保留左側沒有匹配項目的條目。 使用左外部連接時，聯接表是： post.id post.text post.user_id author.id author.username follower.id follower.username 1 post from susan 2 2 susan 1 john 2 post from mary 3 3 mary 2 susan 3 post from david 4 4 david 1 john 3 post from david 4 4 david 3 mary 4 post from john 1 1 john null null 外部連接確保了聯接表至少包含貼文表中的每一個貼文的一次發生。 複合過濾器 Compound Filters聯接表（joined table）現在有了所有的貼文，所以我可以擴展 where() 子句，包括來自關注使用者的貼文以及自己的貼文。SQLAlchemy 提供了 sa.or_()、sa.and_() 和 sa.not_() 輔助工具來建立複合條件。在這種情況下，我需要使用 sa.or_() 來指定我有兩種選擇來選擇貼文。 讓我們來回顧更新後的過濾器： 1234.where(sa.or_( Follower.id == self.id, Author.id == self.id,)) 在這裡，我再次利用別名，若無別名，便無法描述我想做的事。這個條件所表述的是，我想要獲得那些使用者是追隨者，或使用者是作者的貼文。 以 john 為例，篩選後的表格如下： post.id post.text post.user_id author.id author.username follower.id follower.username 1 susan 的貼文 2 2 susan 1 john 3 david 的貼文 4 4 david 1 john 4 john 的貼文 1 1 john null null 這很完美，因為這個列表包含了兩個被追隨的貼文以及使用者自己的貼文。 分組 Grouping不用 john，我們來試試以 david 進行篩選： post.id post.text post.user_id author.id author.username follower.id follower.username 3 david 的貼文 4 4 david 1 john 3 david 的貼文 4 4 david 3 mary 這個使用者沒有追隨任何人，所以唯一的結果來自於使用者自己發布的貼文。但這裡有個複雜情況，這個使用者只寫了一篇貼文，但因為連接 (join) 的要求，這篇貼文被複製了，而篩選並未排除重複的項目。 在連接的表格上發生重複實際上非常普遍。如果你看完整的連接表，你也會發現 john 作為追隨者出現了兩次。因為這些連接包含了多對多的關係，所以兩邊都可能因為資料庫匹配兩邊的實體而出現重複。 為了在最終結果列表中消除重複，可以在查詢中加入一個 group_by() 子句。這個子句會在篩選完成後檢視結果，並消除提供參數的任何重複。對於這個查詢，我想確保沒有重複的貼文，所以我將 Post 作為參數傳遞，SQLAlchemy 將會將其解釋為模型的所有屬性。 測試 User 模型的單元測試雖然我不認為我建構的追隨者實現是一個 “複雜” 功能，但我認為它並非瑣碎。當我編寫非瑣碎的程式碼時，我的關注點是確保這段程式碼在未來，當我在應用程式的不同部分進行修改時，仍將繼續工作。確保您已經寫的程式碼在未來仍然有效的最佳方式是建立一套自動化測試，每當進行更改時，您可以重新運行這些測試。 Python 包含一個非常實用的 unittest 套件，使編寫和執行單元測試變得容易。讓我們為 User 類中現有的方法在 tests.py 模組中編寫一些單元測試： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101## tests.pyimport osos.environ['DATABASE_URL'] = 'sqlite://'from datetime import datetime, timezone, timedeltaimport unittestfrom app import app, dbfrom app.models import User, Postclass UserModelCase(unittest.TestCase): def setUp(self): self.app_context = app.app_context() self.app_context.push() db.create_all() def tearDown(self): db.session.remove() db.drop_all() self.app_context.pop() def test_password_hashing(self): u = User(username='susan', email='susan@example.com') u.set_password('cat') self.assertFalse(u.check_password('dog')) self.assertTrue(u.check_password('cat')) def test_avatar(self): u = User(username='john', email='john@example.com') self.assertEqual(u.avatar(128), ('https://www.gravatar.com/avatar/' 'd4c74594d841139328695756648b6bd6' '?d=identicon&amp;s=128')) def test_follow(self): u1 = User(username='john', email='john@example.com') u2 = User(username='susan', email='susan@example.com') db.session.add(u1) db.session.add(u2) db.session.commit() following = db.session.scalars(u1.following.select()).all() followers = db.session.scalars(u2.followers.select()).all() self.assertEqual(following, []) self.assertEqual(followers, []) u1.follow(u2) db.session.commit() self.assertTrue(u1.is_following(u2)) self.assertEqual(u1.following_count(), 1) self.assertEqual(u2.followers_count(), 1) u1_following = db.session.scalars(u1.following.select()).all() u2_followers = db.session.scalars(u2.followers.select()).all() self.assertEqual(u1_following[0].username, 'susan') self.assertEqual(u2_followers[0].username, 'john') u1.unfollow(u2) db.session.commit() self.assertFalse(u1.is_following(u2)) self.assertEqual(u1.following_count(), 0) self.assertEqual(u2.followers_count(), 0) def test_follow_posts(self): ## create four users u1 = User(username='john', email='john@example.com') u2 = User(username='susan', email='susan@example.com') u3 = User(username='mary', email='mary@example.com') u4 = User(username='david', email='david@example.com') db.session.add_all([u1, u2, u3, u4]) ## create four posts now = datetime.now(timezone.utc) p1 = Post(body=&quot;post from john&quot;, author=u1, timestamp=now + timedelta(seconds=1)) p2 = Post(body=&quot;post from susan&quot;, author=u2, timestamp=now + timedelta(seconds=4)) p3 = Post(body=&quot;post from mary&quot;, author=u3, timestamp=now + timedelta(seconds=3)) p4 = Post(body=&quot;post from david&quot;, author=u4, timestamp=now + timedelta(seconds=2)) db.session.add_all([p1, p2, p3, p4]) db.session.commit() ## setup the followers u1.follow(u2) ## john follows susan u1.follow(u4) ## john follows david u2.follow(u3) ## susan follows mary u3.follow(u4) ## mary follows david db.session.commit() ## check the following posts of each user f1 = db.session.scalars(u1.following_posts()).all() f2 = db.session.scalars(u2.following_posts()).all() f3 = db.session.scalars(u3.following_posts()).all() f4 = db.session.scalars(u4.following_posts()).all() self.assertEqual(f1, [p2, p4, p1]) self.assertEqual(f2, [p2, p3]) self.assertEqual(f3, [p3, p4]) self.assertEqual(f4, [p4])if __name__ == '__main__': unittest.main(verbosity=2) 新增使用者模型的測試我新增了四個測試來檢驗使用者模型中的密碼哈希、使用者頭像和追隨者功能。setUp() 和 tearDown() 方法是單元測試框架在每個測試之前和之後分別執行的特殊方法。 我實施了一個小技巧，以防止單元測試使用我用於開發的常規數據庫。通過將 DATABASE_URL 環境變數設置為 sqlite://，我改變了應用配置，使 SQLAlchemy 在測試期間使用內存中的 SQLite 數據庫。這很重要，因為我不希望測試對我正在使用的數據庫進行更改。 setUp() 方法則建立一個應用上下文並推送它。這確保了 Flask 應用實例及其配置數據對 Flask 擴展可訪問。如果這一點此刻對您來說還不是很清晰，不用擔心，因為這將在稍後詳細介紹。 db.create_all() 調用建立了所有數據庫表。這是從頭開始快速建立數據庫的一種方式，非常適合測試。對於開發和生產使用，我已經向您展示了如何通過數據庫遷移建立數據庫表。 您可以使用以下命令運行整個測試套件： 1234567891011(venv) $ python tests.py[2023-11-19 14:51:07,578] INFO in __init__: Microblog startuptest_avatar (__main__.UserModelCase.test_avatar) ... oktest_follow (__main__.UserModelCase.test_follow) ... oktest_follow_posts (__main__.UserModelCase.test_follow_posts) ... oktest_password_hashing (__main__.UserModelCase.test_password_hashing) ... ok--Ran 4 tests in 0.259sOK 從現在開始，每次對應用進行更改時，您都可以重新運行測試，以確保正在測試的功能未受影響。此外，每次為應用加入新功能時，都應為其編寫單元測試。 將追隨者功能整合到應用中數據庫和模型中的追隨者支持現在已經完成，但我還沒有將這些功能納入應用，所以我現在要加入它。 因為關注和取消關注操作會導致應用中的變更，所以我將把它們實現為 POST 請求，這些請求會因為提交網頁表單而從網頁瀏覽器觸發。將這些路由實現為 GET 請求會更容易，但那樣它們可能會在 CSRF 攻擊中被利用。由於 GET 請求更難以防止 CSRF，它們應該只用於不引入 狀態變更的操作。將它們作為表單提交的結果來實現更好，因為這樣可以向表單中加入 CSRF 令牌。 但是，當使用者只需要點擊「關注」或「取消關注」而不提交任何數據時，如何從網頁表單觸發關注或取消關注操作？為了實現這一點，表單將是空的。表單中唯一的元素將是 CSRF 令牌，它被實現為一個隱藏字段，由 Flask-WTF 自動加入，以及一個提交按鈕，使用者需要點擊它來觸發操作。由於這兩個操作幾乎相同，我將為兩者使用相同的表單。我將這個表單稱為 EmptyForm。 app/forms.py：關注和取消關注的空表單。 12class EmptyForm(FlaskForm): submit = SubmitField('提交') 讓我們在應用中加入兩個新路由來關注和取消關注使用者： app/routes.py：關注和取消關注路由。 12345678910111213141516171819202122232425262728293031323334353637383940414243from app.forms import EmptyForm## ...@app.route('/follow/&lt;username&gt;', methods=['POST'])@login_requireddef follow(username): form = EmptyForm() if form.validate_on_submit(): user = db.session.scalar( sa.select(User).where(User.username == username)) if user is None: flash(f'User {username} not found.') return redirect(url_for('index')) if user == current_user: flash('You cannot follow yourself!') return redirect(url_for('user', username=username)) current_user.follow(user) db.session.commit() flash(f'You are following {username}!') return redirect(url_for('user', username=username)) else: return redirect(url_for('index'))@app.route('/unfollow/&lt;username&gt;', methods=['POST'])@login_requireddef unfollow(username): form = EmptyForm() if form.validate_on_submit(): user = db.session.scalar( sa.select(User).where(User.username == username)) if user is None: flash(f'User {username} not found.') return redirect(url_for('index')) if user == current_user: flash('You cannot unfollow yourself!') return redirect(url_for('user', username=username)) current_user.unfollow(user) db.session.commit() flash(f'You are not following {username}.') return redirect(url_for('user', username=username)) else: return redirect(url_for('index')) 這些路由中的表單處理更簡單，因為我們只需要實現提交部分。與登錄和編輯個人資料表單等其他表單不同，這兩個表單沒有自己的頁面，表單將由 user() 路由渲染並顯示在使用者的個人資料頁面上。validate_on_submit() 調用失敗的唯一原因是 CSRF 令牌丟失或無效，所以在這種情況下，我只是將應用重定向回首頁。 如果表單驗證通過，我會在實際執行關注或取消關注操作之前進行一些錯誤檢查。這是為了預防意外問題，並在出現問題時嘗試向使用者提供有用的訊息。 為了渲染關注或取消關注按鈕，我需要實例化一個 EmptyForm 對象並將其傳遞給 user.html 模板。因為這兩個操作是互斥的，我可以傳遞這個通用表單的單一實例給模板： app/routes.py: 追蹤與取消追蹤路由。 123456@app.route('/user/&lt;username&gt;')@login_requireddef user(username): ## ... form = EmptyForm() return render_template('user.html', user=user, posts=posts, form=form) 我現在可以在每個使用者的個人資料頁面中加入追蹤或取消追蹤表單： app/templates/user.html: 使用者個人資料頁面中的追蹤和取消追蹤連結。 1234567891011121314151617181920212223...&lt;h1&gt; 使用者：{{ user.username }}&lt;/h1&gt;{% if user.about_me %}&lt;p&gt;{{ user.about_me }}&lt;/p&gt;{% endif %}{% if user.last_seen %}&lt;p &gt; 最後上線時間：{{ user.last_seen }}&lt;/p&gt;{% endif %}&lt;p&gt;{{ user.followers_count() }} 位追蹤者，追蹤中 {{ user.following_count() }} 位。&lt;/p&gt;{% if user == current_user %}&lt;p&gt;&lt;a href=&quot;{{ url_for('edit_profile') }}&quot;&gt; 編輯你的個人資料 &lt;/a&gt;&lt;/p&gt;{% elif not current_user.is_following(user) %}&lt;p&gt; &lt;form action=&quot;{{ url_for('follow', username=user.username) }}&quot; method=&quot;post&quot;&gt; {{form.hidden_tag() }} {{form.submit(value='追蹤') }} &lt;/form&gt;&lt;/p&gt;{% else %}&lt;p&gt; &lt;form action=&quot;{{ url_for('unfollow', username=user.username) }}&quot; method=&quot;post&quot;&gt; {{form.hidden_tag() }} {{form.submit(value='取消追蹤') }} &lt;/form&gt;&lt;/p&gt;{% endif %}... 對於使用者個人資料模板的更動，在最後上線時間下方增加了一行，顯示該使用者有多少追蹤者和正在追蹤的使用者。而當你查看自己的個人資料時，原本有「編輯」連結的那一行現在可以有三種可能的連結： 如果使用者正在查看自己的個人資料，「編輯」連結如先前所示。 如果使用者正在查看一個目前未追蹤的使用者，則顯示「追蹤」表單。 如果使用者正在查看一個目前已追蹤的使用者，則顯示「取消追蹤」表單。 為了重複使用 EmptyForm() 實例於追蹤和取消追蹤表單，我在渲染提交按鈕時傳遞一個 value 參數。在提交按鈕中，value 屬性定義了標籤，所以透過這個技巧，我可以根據我需要呈現給使用者的動作，改變提交按鈕中的文字。 此時你可以運行應用程式，建立一些使用者，並嘗試追蹤和取消追蹤使用者。你需要記住的唯一一件事是輸入你想要追蹤或取消追蹤的使用者的個人資料頁面 URL，因為目前無法查看使用者列表。例如，如果你想追蹤一個使用者名為 susan 的使用者，你 需要在瀏覽器的地址欄輸入 http://localhost:5000/user/susan 來訪問該使用者的個人資料頁面。確保你查看了追蹤和被追蹤的使用者數量如何隨著你發出追蹤或取消追蹤而變化。 我應該在應用程式的首頁顯示被追蹤的貼文列表，但我還沒有完成所有部分，因為在目前版本的應用程式中，使用者無法撰寫部落格貼文。所以我將延遲這個變更，直到該功能就緒。","link":"/python/flask-mega-tutorial/chapter_8_followers.html"}],"posts":[{"title":"饅頭計畫 #0 學員心得 (1) Moojing","text":"第零屆的學員只有一個人，這位同學寫了系列文章文章記錄了學習軌跡。 前端工程師後端之旅(1) — 原來30天可以走這麼遠. 一個月可以做很多事：可以讀一本書、可以出國旅遊、可以養成一個你想要的好習慣，我用… | by Moojing | Medium前端工程師後端之旅(2) — 從畫面拆解，到整理User Story前端工程師後端之旅(3) — 路由設計以及Slug SEO優化前端工程師後端之旅(4) — 前端體驗優化前端工程師後端之旅(5) — 資料庫關係設計前端工程師後端之旅(6) — 利用爬蟲取得網站原始商品資料前端工程師後端之旅(7) — 直上穹頂的最後一哩路：部署[Javascript] 製作 Base on Cookie 的購物車[Javascript] 初探Regex 正規表達式[javasrcipt] Summernote 所見即所得編輯器達成圖片上傳","link":"/2019/02/06/mc0-01-moojing/"},{"title":"饅頭計畫 #1 學員心得 (2) GK","text":"Q: 怎麼稱呼？A: GK Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 前端工程師 Q: 你覺得饅頭計畫對你有幫助嘛？A: 非常有幫助，讚！ Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 不好意思說自己是人人稱羨的工程師，只好自稱混水摸魚，但其實還是稍微認真的在工作著，也逐漸朝系統分析的領域、後端領域與資料庫的領域學習。我覺得最大的好處就是有人督促學習，監督進度，不然自己真的很容易懶散。感謝 Luka！ Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 逼迫的部分 Q: 有沒有你很想學，但是沒有學到的東西？A: 沒有特別想學什麼，都是順著路走 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 我寫了一篇轉職心得，其中有提到一點點饅頭計畫https://gkfat.github.io/gk-blog/2019/10/15/road-to-front-end Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-02-gk/"},{"title":"饅頭計畫 #1 學員心得 (1) Joanne","text":"Q: 怎麼稱呼？A: Joanne Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 全端，但專案框架都雷同 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 還記得加入饅頭計畫沒多久，同時也在準備實習面試(目前已畢業轉正)，當時的我coding能力其實並不好，許多基本觀念、技術也都很不熟悉，所以對於即將開始實習這件事，感到非常緊張和擔心，擔心自己能力不足也擔心自己沒辦法好好表現，所以也曾經請教過Luka，該如何提升自己的能力呢 ? 甚至到底該如何學習「物件導向」? 而請教完也相對比較有概念，知道如果要把「物件導向」的相關書籍從頭啃到尾，實在有點痛苦，做中學才能真正理解何謂物件導向。而其實也相當感謝Luka願意無私的分享自己的技術，講解了許多基本觀念和分享開發過程中會接觸到的工具，你的課程很棒~真的有幫助到我~~~ XD 即使在後期因為工作繁忙比較少參與課程，但還是非常謝謝Luka ʕ•ᴥ•ʔ Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 覺得Luka做事很積極哈哈哈，非常的棒啊啊啊啊，當我準備怠惰時，看到Luka下班後還開直播教學，立馬從沙發跳起 (沒資格軟爛)。hahaha Q: 有沒有你很想學，但是沒有學到的東西？A: 資料庫正規化設計及資料庫效能優化 很需要加強… AWS (工作上有接觸到一些，已購入課程，目標今年考到證照!!!) Ruby、Ruby On Rails 網路架構這塊…超弱 QQ 什麼封包什麼router switch，因為我是IT部門，這塊早晚還是必須學起來 強大的邏輯，有了清晰又強大的邏輯力，遇到問題就可以馬上知道問題點及解決方法 (:::з」∠) Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 非常期待饅頭計畫第二彈 ! Luka加油~! Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-01-joanne/"},{"title":"饅頭計畫 #1 學員心得 (3) Genie","text":"Q: 怎麼稱呼？A: Genie Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: \b否，我沒有變轉職成功 Q: 你目前的職業是？A: 還在學習中，目標今年轉職成功 Q: 你覺得饅頭計畫對你有幫助嘛？A: 還好，so so Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 暫無。 不過主要是我自己的原因啦，的確沒有花太多的時間與精力在饅頭計畫上，也沒有與 Luka 保持聯繫，討論學習中所遇到的狀況與進度。 如果有機會再參加一次的話，應該會嘗試有沒有其他作法，把時間管理以及與進度追蹤做好，以這樣的狀態來參加饅頭計畫應該比較有意義 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 沒有將每支影片都看完，不過Luka的教學架構做的很具體，所以透過影片的標題的關鍵字，可以知道要成為網站工程師需要了解以及學習的技能有哪些;然後就是 Luka 是個很願意分享的人，剛開始有 slack 私訊以及發 PR 說明自己目前的學習狀況，Luka 會認真地分析以及指出要怎麼加強，在自學的路上有個有經驗的人可以指引方向很重要 Q: 有沒有你很想學，但是沒有學到的東西？A: 想知道後端方面所需要學習的知識與技能，以及如何與前端配合 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 參與 Luka 饅頭計畫後，覺得 Luka 是個用很用心的態度在做事的 mentor，這個計劃的發心以及構想很不錯，而且真的有人透過饅頭計畫轉職成功，其實蠻替這些人感到高興的，另一方面透過這次的經驗，發現自己在學習上屬於較被動型的，有些學習的策略是需要調整的，教練，我好想變強啊。 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-03-genie/"},{"title":"饅頭計畫 #1 學員心得 (4) TsungYu","text":"Q: 怎麼稱呼？A: 宗裕 Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 偏向雲端工程師 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可 A: 我覺得這個計畫對我最大的影響是讓我在學習的過程中，學會自己去找問題解答，有幾次因為 Mentor 的提點，才有辦法找出解法。過程雖然挫折，但我相信這是成為一位 Engineer 必須具備的能力，畢竟很多時候，不可能會有人手把手帶著自己(別人也沒有義務)。 另外覺得很不錯的地方在於 Mentor 鼓勵學員將自己的學習記錄成文章，在撰寫的過程中，其實也是在檢視自己對於該技術的認知程度到多少。而更多時候是，記錄下來的東西是幫助到未來的自己！經常在 Coding 時會回過頭來看筆記，每次看著看著，就會想哪裏沒寫好，或是還有哪些可以補充，我想這也是一種成長。 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: Luka 的引導方式有別於一般Mentor，遇到問題的時候，不會急著給答案，而是給解決問題的方向，要學員嘗試自己去找解法，讓學員養成試著自己除錯的習慣。 Q: 有沒有你很想學，但是沒有學到的東西？A: 後端工程師的一些必備知識，e.g. 網路、資料庫、資安等等 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 謝謝 Luka! 若不是饅頭計畫，我可能沒辦法即時修正自己的學習方法，從發散式的學習到收斂至主要目標，切分成一個個的學習步驟。 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 我才不要勒","link":"/2020/09/06/mc1-04-tsung-yu/"},{"title":"饅頭計畫 #1 學員心得 (6) Shirley","text":"Q: 怎麼稱呼？A: shirley Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: \b否，我沒有變轉職成功 Q: 你目前的職業是？A: UI設計師，會接觸到一些切版 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 因課程教學不到一半，自己先去找到工作了 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 暸解到前端，基本學習 Q: 有沒有你很想學，但是沒有學到的東西？A: 目前沒有 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？\bA: 抱歉，這題我 pass Q: 有沒有什麼話想對 Luka 說？A: 謝謝你，給我們學習的機會，讓我們收穫很多。辛苦你，準備很多題材～ 你題材很棒 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 我才不要勒","link":"/2020/09/06/mc1-06-shirley/"},{"title":"饅頭計畫 #1 學員心得 (5) Leah","text":"Q: 怎麼稱呼？A: Leah Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 前端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 非常有幫助，讚！ Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A:初期找工作時明確知道準備方向，也因為有Luka開Asana的票，隨時盯自己的進度，比較不會自己一個人準備就沒自信、鬆懈。之後跟其他學院加入群組，還有一次實體分享會，在裡面看到其他人的分享，也督促自己成為工程師之後還是要持續進修 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 願意分享經驗，提供明確的建議，很大方提供Udemy讓我當免費仔XD Q: 有沒有你很想學，但是沒有學到的東西？A: Docket k8s 這些新潮的雲端部署的概念 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！而且我已經寫好了 Q: 有沒有什麼話想對 Luka 說？A: 在年初的激勵之下，拖了半年，我終於勇敢換工作了！換到一家比較有成長性的公司，不過是還沒滿試用期的菜雞 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-05-leah/"},{"title":"饅頭計畫 #1 學員心得 (8) Windy","text":"Q: 怎麼稱呼？A: windy Q: 你在參加饅頭計畫前是否已經是工程師？A: 是，我是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 前端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 觀念上有幫助 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 教學的方法 是適合我的 Q: 有沒有你很想學，但是沒有學到的東西？A: 目前的觀念還是很弱 我應該還是會主要在繼續把觀念搞好 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: \b抱歉，這題我 pass Q: 有沒有什麼話想對 Luka 說？A: 謝謝你願意花時間， 幫助想轉職或者觀念不好的人 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 我才不要勒","link":"/2020/09/06/mc1-08-windy/"},{"title":"饅頭計畫 #1 學員心得 (7) Theo","text":"Q: 怎麼稱呼？A: Theo Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: backend Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A:老實說，我大多是請教Luka 關於履歷問題、面試問題應對，還有工作狀況、職涯問題XD，尤其是找工作時期有 Luka指點履歷和面試問題，糾正許多自己沒有注意到的缺點，還有比較不容易迷失求職方向，最後是剛入職時期，由於公司沒有前輩可以讓我詢問，所以都是透過 Luka 的熱心答覆，慢慢釐清自己在工作上的定位，以及職場上的心境轉換 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 熱心答覆問題，雖然偶爾話題不斷加開 Q: 有沒有你很想學，但是沒有學到的東西？A: 系統分析的流程和技巧 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我沒有時間 Q: 有沒有什麼話想對 Luka 說？A: 我是 Starbugs 忠實讀者，luka 分享的文章都有乖乖看 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-07-theo/"},{"title":"饅頭計畫 #1 學員心得 (10) 昱穎","text":"Q: 怎麼稱呼？A: 昱穎 Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: \b否，我沒有變轉職成功 Q: 你目前的職業是？A: 都不是，在學前端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 我應該不算有參加到饅頭計畫XD，但我有認真看完yt的影片。yt影片錄得很生動，也重新學到很多。 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 願意很友善的這樣對陌生人XD，還有另一點是影片是從網路的教學資源去講解，讓人有資料可以跟著看，不是那種開一個畫面就開始介紹打code那種教學影片 Q: 有沒有你很想學，但是沒有學到的東西？A: 什麼都想 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 哈哈，我前幾天有跟你打招呼，不過感覺你很忙就沒打擾你了！總之很謝謝你願意跟陌生人說說話還有鼓勵，我還是會繼續學寫程式的ＸＤ。對於上面的問題我應該是還沒辦法當助教，但我想繼續參與。總之很謝謝你～！ Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-10-yu-ying/"},{"title":"饅頭計畫 #1 學員心得 (9) Phoenix","text":"Q: 怎麼稱呼？A: Phoenix Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 後端，前端碰的較少 Q: 你覺得饅頭計畫對你有幫助嘛？A: 非常有幫助，讚！ Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 我找到工作了 雖然我是離開工程師一年後再踏上工程師的路，當時的確忘了很多基本觀念，加上前一份工程師的工作使用較舊的技術，經過這次饅頭計畫，創照這樣的環境，跟著大家一起努力，一起成長。 過程中除了技術的成長外，也會在過程中給予我們工程師該有的知識與養成的一些習慣 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 耐心教學，很願意教我們這點已經夠讓人敬佩了 Q: 有沒有你很想學，但是沒有學到的東西？A: 其實前後端知識都蠻有興趣的，想要一條往 senior 路上必備的知識想把前端弄好一個框架，react 或 vue 都好後端太博大精深了，有點不知道從何學起，或只能遇到問題在去學習了 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 很謝謝你在我當時迷茫低潮害怕的時候給予勇氣，勇敢踏出那一步不知道之後會不會有前進senior之路的教學 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-09-phoenix/"},{"title":"饅頭計畫 #1 學員心得 (12) Celine","text":"Q: 怎麼稱呼？A: Celine Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: \b否，我沒有變轉職成功 Q: 你目前的職業是？A: 前端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 用 HackMD 做筆記、寫部落格、參加相關領域社群的習慣。 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 比起外面、自己找的課程，大多是針對轉職所擬定的，但饅頭計畫是由一個真的在業的真人所引導，感覺對工程師的工作有更親近、踏實的銜接。 Q: 有沒有你很想學，但是沒有學到的東西？A: React Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！而且我已經寫好了 Q: 有沒有什麼話想對 Luka 說？A: 哈囉 Luka 好久不見！上次在台北的聚會沒辦法跟到真可惜，希望之後還能有機會～（歡迎來台南呀！）想說的事情我用條列式好了。 1. 我最近忙著一個計畫（還有製作 Podcast ），耽擱了我找工作的時間，我的作品剩下購物網站（大概進度50%），因為計畫的關係預計延後到 10 月找工作，不過我還蠻有信心的，也覺得自己學得扎實，有想要利用空閒時間更深入地探究 React（雖然真的很忙）。2. 文章我在我的 Medium 上面，那篇講述轉職的文章有一個段落在提饅頭計畫，我覺得饅頭計畫是有機體（？），所以不只把它囿於只有當初在轉職時的一部分學習，之後有工作了，還是會覺得是饅頭計畫的一份子，也會想知道 Luka 和其他成員不管有沒有轉職成功，在各自領域的後續狀況、或許將來有機會參與彼此以及討論。3. 如果是第二彈饅頭計畫，我覺得工作變強好像是不錯的路線喔！現在雜七雜八的轉職入門課太多了，好像很多人沒有想過就想說先來學程式好了。不過不管是哪種，有需要的話我都樂意擔任助教:)4. 希望可以保持聯絡，找到工作之後再通知你～ Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-12-celine/"},{"title":"饅頭計畫 #1 學員心得 (11) Trista","text":"Q: 怎麼稱呼？A: 唯 Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 前端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 我目前找到一份薪水還可以的工作，月薪四萬，重點是，我終於可以不再只是設計師，而是能透過ＪＳ控制元件的人了＾Ｏ＾（超開心）饅頭計畫中我覺得收穫最大的是自信吧，每次聚會聽跟看大家不同的想法，還有自我檢討（雖然為了賺錢沒很積極讀書），但是至少我得到了許多啟發。 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 資源，看到了很多人分享的想法，對我來說就是最大的資源。而 Luka 也給了我許多不同的觀點，這也影響到我現在對小孩學習上的投資（是個媽媽）。 Q: 有沒有你很想學，但是沒有學到的東西？A: 串接ＡＰＩ跟資料庫之類的（其實我現在做的工作就是串ＪＳＯＮ跟寫動態資料，但我不知道這叫不叫ＡＰＩ），或是前端框架大綱（發現好多公司都要會用框架的人，我目前的工作還不需要） Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 很感謝你，在我人生低谷的時候遞出了橄欖枝。 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-11-trista/"},{"title":"饅頭計畫 #1 學員心得 (14) Orow","text":"Q: 怎麼稱呼？A: Orow Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個人人稱羨的工程師 Q: 你目前的職業是？A: 前端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 從無到有開始學習前端，知道怎麼樣開始找資源學習，工作實務上遇到的狀況也可以持續跟mentor討論互相了解 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 依照每個人狀況不同在調整學習曲線 Q: 有沒有你很想學，但是沒有學到的東西？A: 前端各種框架、docker、測試…等等 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 饅頭計畫很棒！ Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-14-orow/"},{"title":"饅頭計畫 #1 學員心得 (13) Sherry","text":"Q: 怎麼稱呼？A: Sherry Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 寫 Vue 的前端工程師 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 在於找工作前的那段衝刺期，除了有Luka老師的提點外，其他找到工作的學員也都很樂於分享。每週定定的計劃讓自己的進步更有明確的方向。 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 溝通語言簡單，邊講也會邊給其他建議 Q: 有沒有你很想學，但是沒有學到的東西？A: 一些工作上的實務觀念和可能面臨的問題與學習歷程 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 謝謝老師，請老師也繼續加油！ Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-13-sherry/"},{"title":"饅頭計畫 #1 學員心得 (15) Old Mo","text":"Q: 怎麼稱呼？A: 老莫 Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 前端為主，偶爾碰後端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 我沒有全程參與計畫，但我有問題就會問你，覺得在職涯能認識資深工程師還願意解惑是很好的事 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 精準回答問題 Q: 有沒有你很想學，但是沒有學到的東西？A: 後端進階應用 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我沒有時間 Q: 有沒有什麼話想對 Luka 說？A: 你好帥 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-15-old-mo/"},{"title":"饅頭計畫 #2 學員心得 (1) Phoebe","text":"Q：名字A：Phoebe Q：你在參加饅頭計畫前是否已經是工程師？A：不，我不是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：是，我成為了一個混水摸魚的工程師 Q：你目前的職業是？A：前端 Q：你覺得饅頭計畫對你有幫助嘛？(單選)A：非常有幫助，讚！ Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：改變最大的是養成了學習時寫部落格的習慣。這個習慣不僅可以幫助到自己，也幫助到別人。強迫自己產出也是饅頭計畫的一部分，而 Luka 也會針對你寫的文章給你意見，並提出許多建議，十分的用心。 Q：你覺得 Luka 教學的過程最好的地方是什麼？A：印象最深刻的是 Luka 有教大家如何提出「好」的問題。身為一個工程師，會問出好問題是非常重要的。那麼 Luka 也制定了許多規範，幫助大家問出更好的問題。Luka 也制訂一些任務，讓大家去完成。那完成之後，也會根據你做出來的東西給予意見，這些回饋都非常的寶貴。因為在剛成為 Junior 時，都會有許多的盲點，這時候就需要一位 mentor 來引導。 Q：有沒有你很想學，但是沒有學到的東西？A：TypeScript Q：有沒有什麼話想對我說？A：感謝 Luka 成立了饅頭計畫，給予當時還是學生的我許多的建議。讓我養成了良好的習慣，不管是在寫部落格，還是開發流程上，在饅頭計畫中都受益良多，讓我少走了一些彎路。期待饅頭計畫會越來越好！","link":"/2023/02/11/mc2-01-Phoebe/"},{"title":"饅頭計畫 #2 學員心得 (3) Eva","text":"Q：名字A：Eva Q：你在參加饅頭計畫前是否已經是工程師？A：不，我不是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：是，我成為了一個人人稱羨的工程師 Q：你目前的職業是？A：前端 Q：你覺得饅頭計畫對你有幫助嘛？(單選)非常有幫助，讚！ Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：1. 當時在 JS 上的學習卡關，透過課程給予 JS 觀念 以及大量實作，才開始建立起 JS 的觀念與實際運用的技巧，Q：也比較知道要如何持續精進JS以及甚至跨到框架的使用。2. 2. 在學習上比較有進度跟規劃，例如使用 github 所開任務或討論，可以依照自己的時間規劃每週應該達成的進度，或是也可以透過 github 上進行討論。 Q：你覺得 Luka 教學的過程最好的地方是什麼？A：1. 給予快速掌握新技術的方式，例如：範例實作、資料查找方式、筆記技巧、提問方法。2. 對於積極學習的學員，只要不害怕提問 Luka 都會給予回饋，對剛起步的學員來說給予極大的鼓勵以及安全感。 Q：有沒有你很想學，但是沒有學到的東西？A：1. 資料庫，在前公司偶爾會接觸後端工程師討論資料庫設計的部分，會希望可以理解，所以在會議中會稍微筆記，並學習資料庫的一些概念。2. 接下來學習方向就會依新工作需求或是未來發展方向進行，如 單元測試、react 等。 3. 後端的部分也會滿想學習，自己建立API 、資料庫並自己製作一個前後端專案（但此部分還不急）。 Q：有沒有什麼話想對我說？A：很感謝 Luka 在自己工作後或轉換工作，有技術或方向問題的詢問都願意給予回覆。另外，若未來有需要協助的地方，時間允許下，我也樂意參與喔！","link":"/2023/01/30/mc2-03-eva/"},{"title":"饅頭計畫 #2 學員心得 (2) 慶慶","text":"Q：名字A：慶慶 Q：你在參加饅頭計畫前是否已經是工程師？A：不，我不是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：否，我沒有變轉職成功 Q：你目前的職業是？A：都不是 Q：你覺得饅頭計畫對你有幫助嘛？(單選)A：有幫助，掌聲鼓勵鼓勵 Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：饅頭計畫是一個對於完全沒經驗的人來說非常棒的地方，有 Luka 帶領著我們，讓我們知道有什麼東西要學什麼東西可以不用急著學，對於自學來說會比較有方向性，因為我沒有轉職成功，但其中使用 Hackmd 紀錄筆記的習慣一直保持到現在，已經習慣把學習到的知識轉化成文字去複習。你覺得 Luka 教學的過程最好的地方是什麼？最好的地方就是 Luka 知道捷徑在哪裡，知道那些技能是現在市場最需要的以及知道哪些是 HR 想看的東西，對於要轉職的人來說非常有幫助，還有每周都會跟大家開直播聊聊天，會有種朋友在陪伴你而不是導師的感覺。有沒有你很想學，但是沒有學到的東西？我那時候很想學好 vue.js，但沒有 (跟老師無關 XD) 就放棄了。 Q：有沒有什麼話想對我說？A：首先對 Luka 很抱歉，當初覺得自己轉職失敗很尷尬所以之前你請我寫的心得我就沒寫了，其實當初會放棄 100% 都是自己的原因，那時候的年底家裡有一些事情，生活壓力太大，頓時覺得自己沒什麼心再往前進，那時候負面到覺得我那麼認真想轉職讓生活變得更好，家裡的事情讓我情緒上變得很暴躁，所以最後選擇繼續在原本的工作躺平算了的想法一直出現就到了前陣子事情結束才比較好一點，其實我去年十一月開始有嘗試寫一些東西 XD 但老實說我還是不知道自己要不要轉職，所以想要嘗試寫 JAVA 跟 SQL 搭配之前學的前端搞個網站玩玩看，如果有機會再看能不能真的轉職到軟體工程的領域，因為畢竟我現在生活上經濟壓力比較大，工廠的收入比較扛的住 XD 我很怕轉職薪水差太多會扛不太住，總之很感恩你，謝謝 Luka","link":"/2023/02/08/mc2-02-qing/"},{"title":"饅頭計畫 #2 學員心得 (4) 鈺涵","text":"Q：名字A：鈺涵 Q：你在參加饅頭計畫前是否已經是工程師？A：不，我不是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：否，因為人生選擇我沒有選擇成為工程師 Q：你目前的職業是？A：仍然是設計師阿哈哈哈啊哈 Q：你覺得饅頭計畫對你有幫助嘛？(單選)A：有幫助，掌聲鼓勵鼓勵 Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：讓我了解工程師部分生態以及如何努力!雖然基於種種理由最後沒有轉職成功=_=但還是十分感謝饅頭哥的教誨XD Q：你覺得 Luka 教學的過程最好的地方是什麼？A：很好笑…………. Q：有沒有你很想學，但是沒有學到的東西？A：因為中斷了所以這一題無解……….你願意寫篇心得記錄饅頭計畫的過程嘛？我願意！但我需要一點時間有沒有什麼話想對我說？謝謝你= =下次回台灣我要請你吃飯XD","link":"/2023/01/29/mc2-04-yuha/"},{"title":"饅頭計畫 #2 學員心得 (5) Michael","text":"Q：名字A：Michael Q：你在參加饅頭計畫前是否已經是工程師？A：不，我不是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：是，我成為了一個混水摸魚的工程師 Q：你目前的職業是？A：前端 Q：你覺得饅頭計畫對你有幫助嘛？(單選)A：非常有幫助，讚！ Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：讓我面對難題時，能夠冷靜有邏輯地解決問題你覺得 Luka 教學的過程最好的地方是什麼？有條理地拆解問題，以及引導解決問題的方向 Q：有沒有你很想學，但是沒有學到的東西？A：沒有 Q：有沒有什麼話想對我說？A：很感謝你的教導！","link":"/2023/01/28/mc2-05-michael/"},{"title":"饅頭計畫 #2 學員心得 (6) Shawn","text":"Q：名字A：Shawn Q：你在參加饅頭計畫前是否已經是工程師？A：不，我不是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：是，我成為了一個混水摸魚的工程師 Q：你目前的職業是？A：python相關工程師 Q：你覺得饅頭計畫對你有幫助嘛？(單選)A：有幫助，掌聲鼓勵鼓勵 Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：主要是學習方式,將學習的知識轉化為筆記並進一步建立成部落格，紀錄學習歷程，這點滿重要的，也因為學習筆記，對我進入現在公司有滿大的加分，至今也仍然使用此方式在學習. Q：你覺得 Luka 教學的過程最好的地方是什麼？A：陪伴你一路轉職，會幫你盯進度，雖然我屬於那種丟了履歷莫名找到工作的，但還是謝謝Luka前期的密集盯哨與陪伴！ Q：有沒有你很想學，但是沒有學到的東西？A：目前還好 Q：有沒有什麼話想對我說？A：謝謝Luka,覺得這樣的計劃非常有意義，也因為這個計畫認識了其他轉職夥伴，可以互相交流","link":"/2023/01/28/mc2-06-Shawn/"},{"title":"饅頭計畫 #2 學員心得 (7) Lily","text":"Q：名字A：Lily Q：你在參加饅頭計畫前是否已經是工程師？A：是，我是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：是，我成為了一個人人稱羨的工程師 Q：你目前的職業是？A：前端 Q：你覺得饅頭計畫對你有幫助嘛？(單選)A：非常有幫助，讚！ Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：感謝 Luka 的耐心協助，指點該如何準備面試，撰寫履歷（很多時候真的不理解到底該怎麼執行，Luka 可以在下班後那麼多事情的情況下願意幫忙，真的很感動），後來也順利拿到薪水更高的 offer。 Q：你覺得 Luka 教學的過程最好的地方是什麼？A：很有耐心、會指點方向讓學員主動學習，而不是直接提供答案 Q：你覺得 Luka 教學的過程最好的地方是什麼？A：pipeline 運作吧 Q：有沒有什麼話想對我說？A：Hi 教練，新年快樂啊～","link":"/2023/01/27/mc2-07-lily/"},{"title":"【 Python 教學 】什麼是 PyPI？跟 pip 又有什麼關係呢？","text":"什麼是 PyPI？ PyPI（英語 Package Index，簡稱PyPI），是 的官方的第三方套件儲存庫。 如果用生活的例子來比喻，就像 Android 手機，有 google play 可以安裝軟體。iphone 有 app store 來安裝軟體。在這之中 PyPI 就像是 google play 或是 app store. 在我們使用 pip 安裝套件的時候，下指令 pip install 套件名稱 預設就是從 PyPI 下載套件。 在 PyPI 上搜尋套件官方網站 我們試著搜尋 web 框架 flask 。看到第一個就是搜尋結果，後方的日期是更新的時間。 點擊進去之後，就可以看到 Flask 的介紹，還有貼心的教學， 在指令列輸入 pip install flask 即可安裝。 在 PyPI 上查看簡易介紹下方還有簡單的範例，不過因為這些套件是第三方 (Third-Party) 維護，也就是開發套件的人是自主開發的，因此我們需要到各自的官網看詳細教學。 在 PyPI 找到套件的官方網站，查看詳細文件所以我們點擊 documentation 就可以進入到 Flask 的官方網站，最詳盡的文件可以在這邊找到。 PyPI 跟 pip 有什麼關係呢？最後我們來回答標題上的第二個問題，PyPI 跟 pip 的關係，剛剛在操作過程已經知道了。pip install 某某套件 預設的官方套件商店就是 PyPI。 總結今天介紹的是從 PyPI 官方網站搜尋到需要的套件 (Flask)，然後使用指令安裝需要的套件，最後是如何查詢 Flask 的使用方式。","link":"/2021/11/27/python/02-what-is-pypi/"},{"title":"【 Python 資料科學 】書籍推薦","text":"Data Science from Scratch 中文版（第二版）：用 Python 學資料科學 這本裡面有大量的名詞幫，適合當工具書來查詢，硬啃的話有點累。名詞如下： 資料視覺化, 線性代數, 統計學, 機率, 假設與推論, 梯度遞減, 取得資料, 處理資料, 機器學習, k最近鄰, 單純貝氏, 簡單線性迴歸, 多元迴歸, 邏輯迴歸, 決策樹, 神經網路, 深度學習, 集群, 自然語言處理, 網路分析, 推薦系統, 資料庫與SQL, MapReduce Python資料分析 第二版 這本是 pandas 的作者寫的書，本書重點在於使用 pandas 與 NumPy 進行資料載入、資料前處理、資料處理、資料視覺化 … 等等的步驟。如果想要學習完整的流程挺推薦。 Python資料科學學習手冊 本書分為五個章節，從資料科學開始介紹，接著介紹常用的 IPython、NumPy、Pandas 資料處理、Matplotlib 資料視覺化、最後介紹 Sckit-Learn 來學習機器學習。非常完整的介紹資料科學的流程。 參考資料[分享] 2020 推薦 Python資料科學的書","link":"/2021/11/25/python/01-data-science-book/"},{"title":"【 Python 冷知識 】你知道 PyPI 怎麼唸嘛？","text":"撰寫另一篇文章 【 Python 教學 】什麼是 PyPI？跟 pip 又有什麼關係呢？的時候，發現 PyPI 的時候，產生了一個疑問，PyPI該怎麼唸？ 可能的答案有： 拍拍 批歪批唉 批批 拍批埃 究竟是哪一個，你念對了嘛？答案在下方教學影片： How to pronounce PyPI (beginner) Anthony explains #020 - YouTube","link":"/2021/11/29/python/03-how-to-pronounce-pypi/"},{"title":"【 Python 教學 】enumerate 函式介紹","text":"Python 的 enumerate() 函式是一個非常有用的工具，特別是在處理迴圈時。這個函式可以將一個可迭代的對象（如列表、元組或字串）轉換為索引序列，同時列出資料和資料對應的索引值。這使得在迴圈中同時獲得元素和其對應索引變得簡單。 基本用法enumerate() 函式的基本語法是 enumerate(iterable, start=0)。其中，iterable 是一個可迭代物件，如列表、元組、字串等。start 是可選參數，用來指定索引值的起始值，預設為 0。 假設有一個列表：fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]。使用 enumerate() 函式，可以這樣遍歷列表： 12for index, fruit in enumerate(fruits): print(index, fruit) 這將輸出： 1230 apple1 banana2 cherry 如果指定 start 參數，例如 enumerate(fruits, start=1)，則索引將從 1 開始計數。 使用範例列表 (List)假設我們有一個包含數字的列表，我們想要列印出每個數字及其索引： 123numbers = [10, 20, 30, 40, 50]for index, number in enumerate(numbers): print(f&quot;Index: {index}, Number: {number}&quot;) 輸出將是： 12345Index: 0, Number: 10Index: 1, Number: 20Index: 2, Number: 30Index: 3, Number: 40Index: 4, Number: 50 元組 (Tuple)元組也可以使用 enumerate()。例如，我們有一個包含幾個城市名稱的元組： 123cities = (&quot;Taipei&quot;, &quot;Kaohsiung&quot;, &quot;Taichung&quot;)for index, city in enumerate(cities): print(f&quot;Index: {index}, City: {city}&quot;) 輸出將是： 123Index: 0, City: TaipeiIndex: 1, City: KaohsiungIndex: 2, City: Taichung 字串 (String)對於字串，enumerate() 可以幫助我們獲得每個字元及其索引： 123text = &quot;Hello&quot;for index, char in enumerate(text): print(f&quot;Index: {index}, Character: {char}&quot;) 輸出將是： 12345Index: 0, Character: HIndex: 1, Character: eIndex: 2, Character: lIndex: 3, Character: lIndex: 4, Character: o 字典 (Dictionary)雖然字典不是傳統意義上的序列，但我們仍然可以使用 enumerate() 來迭代它的鍵： 123info = {&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;}for index, key in enumerate(info): print(f&quot;Index: {index}, Key: {key}, Value: {info[key]}&quot;) 輸出將是： 123Index: 0, Key: name, Value: JohnIndex: 1, Key: age, Value: 30Index: 2, Key: city, Value: New York 在這些例子中，enumerate() 函式為我們提供了一種簡潔且高效的方式來迭代各種類型的可迭代物件，同時獲取它們的索引和值。 心得Python 的 enumerate() 函式是處理迴圈和可迭代物件時的一個強大工具，它提高了程式碼的可讀性和效率。使用 enumerate() 的主要優點是它提供了一種簡潔的方式來獲取索引，並且比使用 range() 和 len() 組合更為直觀和高效。它使程式碼更加清晰，易於理解和維護。","link":"/2023/12/04/python/enumerate/"},{"title":"【 Flask 教學 】Hello, Flask！五分鐘建立你的第一個 Flask 應用","text":"輕量型 Web 框架 - Flask Flask 是一款 Python 的網頁開發框架。它的特色就是輕巧。Flask 的官方網站用 Micro 這個字來說明 Flask 的設計哲學。 Micro 意味著，一開始什麼都沒有，沒有資料庫，沒有好用的表單工具，Flask 就提供給你一個非常非常精簡的 Web 框架。 如果你需要資料庫功能，那麼你需要找尋套件，例如：你想要連接 MySQL 的話，需要安裝 Flask-SQLAlchemy 套件，來擴展你的 Flask 應用程式。 這跟 Python 中另一個主流框架，Django 大相逕庭。然而 Flask 與 Django 的市占率大概 50% vs 50%，非常有趣，意味著各有各的擁護者。 瞭解了 Flask 的設計哲學後，接下來我們實作的 Hello World 應用程式，便是只有提供網頁功能，並且只有「一個檔案」的迷你專案。 Hello Flask！初學程式的時候發現一個奇特的現象，為什麼第一個程式要輸出 Hello World 呢？因為我們第一件事情就是要確保環境能夠正確執行。 安裝 Flask使用 pip 安裝 Flask 1pip install flask 組織專案結構安裝完成之後，我們先建立一個乾淨的資料夾命名為 hello_flask。接著在裡面建立一個新檔案命名為 hello.py所以現在我們的專案結構是 hello_flask 資料夾底下，有一個 hello.py 的檔案 12hello_flask└── hello.py 接著我們編輯 hello.py 的內容，將以下內容撰寫上檔案 1234567891011from flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def hello_world(): return &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;if __name__ == '__main__': app.run(port=5000) 在本地端運行接著下列指令， 12export FLASK_APP=helloflask run 就會發現終端機的畫面，Flask Server (伺服器)已經開始在你的本地開發環境，也就是你的電腦上面運轉囉！ 此時我們複製終端機上的顯示的網址 http://127.0.0.1:5000/ 到瀏覽器上，打開便會看到 Hello World！。 先讓程式跑起來，接下來我們才可以嘗試各式各樣的開發。 參考資料 Flask 官方網站 實作一個簡單的 Flask 入門 | Max行銷誌","link":"/2021/11/29/python-flask/01-hello-flask/"},{"title":"【 Flask 教學 】五分鐘學會 Flask 中的 GET, POST, PUT, PATCH, DELETE","text":"本文詳細講解如何在 Flask 中使用 HTTP 請求方法，包括 GET、POST、PUT、PATCH 和 DELETE。文章介紹每種請求方法的用途和使用方法，並提供了相應的程式碼範例，使讀者能夠更好地理解如何在 Flask 中使用這些請求方法。本文適合初學者閱讀，可快速了解 Flask 中 HTTP 請求方法的基本使用方法。 GET 請求GET 請求用於從伺服器獲取資料。在 Flask 中，使用 GET 請求非常簡單。以下是一個簡單的範例，使用 GET 請求從伺服器獲取資料： 12345678from flask import Flask, jsonifyapp = Flask(__name__)@app.route('/data', methods=['GET'])def get_data(): data = {'name': 'Alice', 'age': 25} return jsonify(data) 在這個範例中，我們使用 Flask 的 @app.route 裝飾器來指定路由，其中 methods=['GET'] 指定了使用 GET 請求。我們定義了一個 get_data 函數，返回一個包含 name 和 age 屬性的 JSON Response。 POST 請求POST 請求用於向伺服器提交資料。在 Flask 中，使用 POST 請求同樣非常簡單。以下是一個範例，使用 POST 請求提交表單資料： 12345678910from flask import Flask, request, jsonifyapp = Flask(__name__)@app.route('/data', methods=['POST'])def post_data(): name = request.form['name'] age = request.form['age'] data = {'name': name, 'age': age} return jsonify(data) 在這個範例中，我們同樣使用 @app.route 裝飾器指定路由和請求方法。我們定義了一個 post_data 函數，使用 request.form 獲取提交的表單資料，然後將資料封裝成 JSON Response返回。 PUT 請求PUT 請求用於更新伺服器上的資料。在 Flask 中，使用 PUT 請求也很簡單。以下是一個範例，使用 PUT 請求更新一條記錄： 1234567891011from flask import Flask, request, jsonifyapp = Flask(__name__)data = {'name': 'Alice', 'age': 25}@app.route('/data/&lt;name&gt;', methods=['PUT'])def put_data(name): age = request.form['age'] data[name] = age return jsonify(data) 在這個範例中，我們使用了 URL 參數 &lt;name&gt; 來指定要更新的記錄。我們定義了一個 put_data 函數，使用 request.form 獲取新的年齡資料，並將資料更新到 data 字典中。 PATCH 請求PATCH 請求用於部分更新伺服器上的資料。在 Flask 中，使用 PATCH 請求同樣很簡單。以下是一個範例，使用 PATCH 請求部分更新一條記錄： 1234567891011from flask import Flask, request, jsonifyapp = Flask(__name__)data = {'name': 'Alice', 'age': 25}@app.route('/data/&lt;name&gt;', methods=['PATCH'])def patch_data(name): age = request.form['age'] data[name]['age'] = age return jsonify(data) 在這個範例中，我們同樣使用 URL 參數 &lt;name&gt; 來指定要更新的記錄。我們定義了一個 patch_data 函數，使用 request.form 獲取新的年齡資料，並將資料部分更新到 data 字典中。 DELETE 請求DELETE 請求用於刪除伺服器上的資料。在 Flask 中，使用 DELETE 請求同樣非常簡單。以下是一個範例，使用 DELETE 請求刪除一條記錄： 12345678910from flask import Flask, jsonifyapp = Flask(__name__)data = {'name': 'Alice', 'age': 25}@app.route('/data/&lt;name&gt;', methods=['DELETE'])def delete_data(name): del data[name] return jsonify(data) 在這個範例中，我們同樣使用 URL 參數 &lt;name&gt; 來指定要刪除的記錄。我們定義了一個 delete_data 函數，使用 Python 的 del 語句從 data 字典中刪除指定的記錄，並將更新後的資料封裝成 JSON Response返回。","link":"/2023/02/11/python-flask/02-routes/"},{"title":"【 Flask 教學 】Flask Factory 介紹","text":"Flask 是一個輕量的 Python 網頁應用框架，因為它簡單易用而廣受歡迎。其中，Flask Factory 是一個新的概念，可以更加靈活地建立 Flask 應用程式。本文將介紹 Flask Factory 的概念以及如何在 Flask 應用程式中使用它。 Flask Factory 是什麼？在傳統的 Flask 應用程式中，我們會在一個檔案中建立 Flask 應用程式物件，然後將它與路由和視圖函式一起定義在同一個檔案中。然而，這種方式的維護和擴展性很差。Flask Factory 的概念就是將 Flask 應用程式物件的建立和設定分離出來，以便更靈活地管理 Flask 應用程式。 Flask Factory 通常會分為三個部分： 工廠函式：這是建立 Flask 應用程式物件的函式，通常是一個叫做 create_app 的函式。這個函式會負責建立 Flask 應用程式物件、設定 Flask 應用程式以及註冊路由和視圖函式。 設定：這是 Flask 應用程式的設定，可以使用 Python Class 或字典來定義。 視圖函式：這些是處理路由的函式，通常是一個或多個藍圖。 如何在 Flask 中使用工廠？以下是一個簡單的 create_app 工廠函式範例： 1234567891011from flask import Flaskdef create_app(): app = Flask(__name__) app.config['DEBUG'] = True @app.route('/') def hello_world(): return 'Hello, World!' return app 在上面的範例中，create_app 函式建立了一個 Flask 應用程式物件，並定義了一個路由和一個視圖函式。此外，它還設定了 DEBUG 設定選項，以便在偵錯模式下執行應用程式。 這個工廠函式可以在另一個檔案中被呼叫，並使用以下程式碼啟動應用程式： 1234from myapp import create_appapp = create_app()app.run() 在上面的範例中，create_app 函式在另一個名為 myapp 的模組中定義，然後被呼叫以建立 Flask 應用程式物件。然後，run 方法啟動了應用程式。 除了上面的範例，我們還可以使用工廠函式來建立複雜的 Flask 應用程式。例如，我們可以使用藍圖來組織視圖函式，使用 Flask 插件來擴展應用程式功能，等等。 以下是一個更複雜的工廠函式範例： 123456789101112131415from flask import Flaskfrom myapp.views import main_bp, admin_bpfrom myapp.extensions import db, login_managerdef create_app(config_object): app = Flask(__name__) app.config.from_object(config_object) db.init_app(app) login_manager.init_app(app) app.register_blueprint(main_bp) app.register_blueprint(admin_bp, url_prefix='/admin') return app 在上面的範例中，create_app 函式建立了一個 Flask 應用程式物件，並使用 config_object 設定來設定應用程式。它還初始化了一些 Flask 插件，如 db 和 login_manager，並將它們與應用程式關聯起來。最後，它註冊了兩個藍圖 main_bp 和 admin_bp，這些藍圖包含不同的視圖函式。 這個工廠函式可以在另一個檔案中被呼叫，並使用以下程式碼啟動應用程式： 12345from myapp import create_appfrom myapp.config import ProductionConfigapp = create_app(ProductionConfig)app.run() 在上面的範例中，create_app 函式在 myapp 模組中定義，然後使用 ProductionConfig 設定物件建立 Flask 應用程式物件。然後，run 方法啟動了應用程式。 總結一下，Flask Factory 是一個有用的概念，可以使我們更加靈活地建立和管理 Flask 應用程式。通過將建立 Flask 應用程式物件的過程分離出來，我們可以更輕鬆地進行擴展和維護。如果你還沒有嘗試過 Flask Factory，我們建議你嘗試一下，體驗一下其帶來的好處。","link":"/2023/02/15/python-flask/04-flask-factory/"},{"title":"【 Flask 教學 】如何在 Flask 設置和操作 Cookie","text":"在 Python Flask 中，cookie 是一種儲存在使用者瀏覽器中的小型資料塊。通常情況下，我們使用 cookie 來記錄使用者的首選設定、登錄資料以及其他與使用者相關的資訊。在 Flask 應用程式中，使用 cookie 的過程非常簡單。 設置 cookie要在 Flask 中設置 cookie，我們需要使用 response 物件的 set_cookie() 方法。這個方法接受以下參數： key：cookie 的名稱，必須是一個字符串 value：cookie 的值，必須是一個字符串，默認為空字符串 max_age：cookie 的存活時間，以秒為單位，默認為 None 以下是一個簡單的 Flask 應用程式，演示如何設置 cookie： 123456789from flask import Flask, make_responseapp = Flask(__name__)@app.route('/')def index(): resp = make_response('Setting a cookie!') resp.set_cookie('my_cookie', 'my_value') return resp 在上面的程式碼中，我們建立了一個名為 my_cookie 的 cookie，其值為 my_value。當使用者訪問該頁面時，他們的瀏覽器將接收到這個 cookie。 讀取 cookie要讀取 cookie，我們可以使用 request 物件的 cookies 屬性。這個屬性是一個字典，其中包含了所有使用者瀏覽器中的 cookie。以下是一個簡單的 Flask 應用程式，演示如何讀取 cookie： 12345678from flask import Flask, requestapp = Flask(__name__)@app.route('/')def index(): my_cookie = request.cookies.get('my_cookie') return f'The value of my_cookie is {my_cookie}' 在上面的程式碼中，我們使用 request.cookies.get() 方法讀取名為 my_cookie 的 cookie。如果該 cookie 存在，它的值將被存儲在 my_cookie 變數中。否則，my_cookie 將為 None。 刪除 cookie要刪除 cookie，我們只需要設置 cookie 的 max_age 參數為 0。以下是一個簡單的 Flask 應用程式，演示如何刪除 cookie： 123456789from flask import Flask, make_responseapp = Flask(__name__)@app.route('/')def index(): resp = make_response('Deleting a cookie!') resp.set_cookie('my_cookie', '', max_age=0) return resp 在上面的程式碼中，我們建立了一個名為 my_cookie 的 cookie，並將其 max_age 設置為 0。這意味著該 cookie 的存活時間為 0 秒，瀏覽器將立即刪除它。 使用 session雖然 cookie 是一種非常方便的儲存使用者設置和資料的方式，但是在一些情況下，它們可能不夠安全。為了增強安全性，Flask 提供了一種名為 session 的機制，它會在伺服器端儲存使用者資料，並使用一個加密的 cookie 將使用者資料傳遞給使用者瀏覽器。以下是一個簡單的 Flask 應用程式，演示如何使用 session： 1234567891011121314from flask import Flask, sessionapp = Flask(__name__)app.secret_key = 'my_secret_key'@app.route('/')def index(): session['my_session'] = 'my_value' return 'Setting a session!'@app.route('/get_session')def get_session(): my_session = session.get('my_session') return f'The value of my_session is {my_session}' 在上面的程式碼中，我們使用 session 物件儲存使用者資料。在設置 session 時，我們可以像設置字典一樣設置 session 的鍵和值。在讀取 session 時，我們使用 session.get() 方法。需要注意的是，使用 session 時需要設置 app.secret_key 屬性，該屬性是用於加密 session 的關鍵。 使用情境以下是使用 Python Flask 框架來實現一些使用 Cookie 的範例： 使用者身份驗證1234567891011121314151617from flask import Flask, request, make_responseapp = Flask(__name__)@app.route('/')def index(): resp = make_response('Welcome!') resp.set_cookie('user_id', '123') return resp@app.route('/dashboard')def dashboard(): user_id = request.cookies.get('user_id') if user_id == '123': return 'Dashboard' else: return 'Unauthorized' 在上面的程式碼中，當使用者訪問首頁時，我們設置了一個名為 user_id 的 cookie，其值為 123。當使用者訪問儀表板頁面時，我們讀取了 user_id cookie 的值，並檢查其是否等於 123。如果相等，則返回儀表板頁面，否則返回未經授權的錯誤。 記住使用者首選設置12345678910111213141516from flask import Flask, request, make_responseapp = Flask(__name__)@app.route('/')def index(): lang = request.cookies.get('lang', 'en') resp = make_response(f'Language: {lang}') resp.set_cookie('lang', lang) return resp@app.route('/set_lang/&lt;lang&gt;')def set_lang(lang): resp = make_response('Language set!') resp.set_cookie('lang', lang) return resp 在上面的程式碼中，我們讀取了名為 lang 的 cookie 的值，並將其用作網站的語言。如果 cookie 不存在，我們默認使用英語。當使用者訪問網站時，我們將 lang cookie 的值設置為當前語言。如果使用者訪問 /set_lang/&lt;lang&gt; 頁面，我們將 lang cookie 的值設置為使用者指定的語言。 記住使用者在線狀態123456789101112131415from flask import Flask, request, make_responseapp = Flask(__name__)@app.route('/')def index(): resp = make_response('Welcome!') resp.set_cookie('online', 'true') return resp@app.route('/logout')def logout(): resp = make_response('Logged out!') resp.set_cookie('online', 'false') return resp 在上面的程式碼中，當使用者訪問首頁時，我們設置了一個名為 online 的 cookie，其值為 true，表示使用者在線。當使用者訪問登出頁面時，我們將 online cookie 的值設置為 false，表示使用者離線。 記住使用者的購物車1234567891011121314151617181920212223242526272829from flask import Flask, request, make_responseapp = Flask(__name__)@app.route('/')def index(): resp = make_response('Welcome to our store!') resp.set_cookie('cart', '') return resp@app.route('/add_to_cart/&lt;item&gt;')def add_to_cart(item): cart = request.cookies.get('cart') if cart: cart += f',{item}' else: cart = item resp = make_response(f'{item} added to cart!') resp.set_cookie('cart', cart) return resp@app.route('/view_cart')def view_cart(): cart = request.cookies.get('cart') if cart: items = cart.split(',') return f'Items in your cart: {&quot;, &quot;.join(items)}' else: return 'Your cart is empty' 在上面的程式碼中，當使用者訪問首頁時，我們設置了一個名為 cart 的 cookie，其值為空，表示使用者的購物車是空的。當使用者訪問加入到購物車頁面時，我們讀取 cart cookie 的值，將新的項目加入到購物車中，然後更新 cart cookie 的值。當使用者訪問查看購物車頁面時，我們讀取 cart cookie 的值，並顯示購物車中的所有項目。 記住使用者的瀏覽歷史12345678910111213141516171819202122232425262728from flask import Flask, request, make_responseapp = Flask(__name__)@app.route('/')def index(): resp = make_response('Welcome to our store!') resp.set_cookie('history', '') return resp@app.route('/view_product/&lt;product&gt;')def view_product(product): history = request.cookies.get('history') if history: products = history.split(',') if product not in products: history += f',{product}' else: history = product resp = make_response(f'Viewing product: {product}') resp.set_cookie('history', history) return resp@app.route('/view_history')def view_history(): history = request.cookies.get('history') if history: products = history.split 總結在 Flask 中，使用 cookie 是一種非常簡單和方便的方式，可以儲存使用者設置和資料。在上面的教學中，我們學習了如何設置、讀取和刪除 cookie，以及如何使用 session 增強安全性。通過這些方法，我們可以更加靈活地設計 Flask 應用程式，以滿足不同的需求。 參考資料 OverIQ：簡單介紹 Flask 中如何使用 set_cookie() 方法設置 cookie。 GeeksforGeeks：提供 Flask cookie 的概述，並介紹如何設置和讀取 cookie。 Flask documentation：官方 Flask 文件，提供全面的關於 cookie 的指南，包括如何設置、讀取、刪除 cookie，以及使用 session。 Python Basics：簡單介紹在 Flask 中如何使用 make_response() 函數和 set_cookie() 方法來設置 cookie。 Stack Overflow：Stack Overflow 討論串，討論了在 Flask 中設置 cookie 會面臨的問題以及如何解決。 Protutorialplus：提供了如何在 Python Flask 中設置和讀取 cookie 的簡單教學。","link":"/2023/02/16/python-flask/06-flask-cookie/"},{"title":"【 Flask 教學 】Flask SQLAlchemy | Python 與資料庫的橋樑","text":"在本篇文章，我們將介紹 Flask-SQLAlchemy，讓我們能夠在 Python Flask 應用程式中使用 SQLAlchemy 的 ORM 和 Flask-SQLAlchemy 進行資料庫溝通。 Flask 是一個輕量級的 Python Web 框架，用於建立 Web 應用程式，而 SQLAlchemy 則是一個 Python 庫，提供對關係資料庫的高效和高效能的訪問。 Flask-SQLAlchemy 是一個用於 Flask 應用程式的擴展程式，簡化了使用 SQLAlchemy 的複雜性，並提供了常見的對象和模式，例如與每個 Web 請求相關聯的會話、模型和引擎，同時不會更改 SQLAlchemy 的工作方式。 下面我們來看看如何在 Python Flask 應用程式中使用 Flask-SQLAlchemy。 安裝 Flask-SQLAlchemy要使用 Flask-SQLAlchemy，首先需要在計算機上安裝它。可以使用以下命令在終端中安裝 Flask-SQLAlchemy： 1pip install Flask-SQLAlchemy 建立 Flask 應用程式 在使用 Flask-SQLAlchemy 之前，需要建立一個 Flask 應用程式。可以使用以下程式碼建立一個簡單的 Flask 應用程式： 12from flask import Flaskapp = Flask(__name__) 設定資料庫 在 Flask-SQLAlchemy 中，可以使用 PostgreSQL、MySQL、SQLite 或 Oracle 等多種資料庫。在本節中，我們將使用 SQLite3 作為資料庫。可以使用以下程式碼設定資料庫： 123from flask_sqlalchemy import SQLAlchemyapp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///example.db'db = SQLAlchemy(app) 上述程式碼將建立一個名為 example.db 的 SQLite3 資料庫。 建立資料庫模型在 Flask-SQLAlchemy 中，資料庫模型由 Python Class定義。以下是一個簡單的範例： 1234567class User(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(80), nullable=False) email = db.Column(db.String(120), unique=True, nullable=False) def __repr__(self): return '&lt;User %r&gt;' % self.username 上述程式碼定義了一個名為 User 的模型，包含三個屬性：id、name 和 email。 建立資料庫表在Flask-SQLAlchemy 中，可以使用以下程式碼建立資料庫表： 1db.create_all() 上述程式碼將根據模型定義建立資料庫表。 加入資料到資料庫在 Flask-SQLAlchemy 中，可以使用以下程式碼向資料庫加入資料： 123user = User(name='John Doe', email='johndoe@example.com')db.session.add(user)db.session.commit() 上述程式碼將建立一個新的 User 對象，將其加入到資料庫中，並提交更改。 從資料庫檢索資料在 Flask-SQLAlchemy 中，可以使用以下程式碼從資料庫檢索資料： 1users = User.query.all() 上述程式碼將檢索資料庫中的所有 User 對象，並將它們作為列表返回。 更新資料庫中的資料在 Flask-SQLAlchemy 中，可以使用以下程式碼更新資料庫中的資料： 123user = User.query.filter_by(email='johndoe@example.com').first()user.name = 'John'db.session.commit() 上述程式碼將從資料庫中檢索具有指定電子郵件地址的 User 對象，將其名稱更改為 John，然後提交更改。 刪除資料庫中的資料在 Flask-SQLAlchemy 中，可以使用以下程式碼從資料庫中刪除資料： 123user = User.query.filter_by(email='johndoe@example.com').first()db.session.delete(user)db.session.commit() 上述程式碼將從資料庫中刪除具有指定電子郵件地址的 User 對象，然後提交更改。 小節綜上所述，本篇教學文章介紹了 Flask-SQLAlchemy 的基本用法，包括建立 Flask 應用程式、設定資料庫、建立資料庫模型、建立資料庫表、加入資料到資料庫、從資料庫檢索資料、更新資料庫中的資料和刪除資料庫中的資料。這些步驟提供了初學者所需的基礎知識，可以用來構建簡單的 Python Flask 應用程式，以及進一步擴展以實現更複雜的資料庫操作。需要注意的是，Flask-SQLAlchemy 需要一定的學習曲線，但一旦掌握了基本概念，就可以輕鬆地使用它來管理資料庫。 希望本篇教學文章能夠為初學者提供一個良好的起點，幫助他們進入 Flask-SQLAlchemy 的世界，並開始在 Python Flask 應用程式中進行資料庫溝通。 延伸閱讀以下是本次回答所使用的參考資料的標題和連結： Flask-SQLAlchemy 快速入門 和 Flask-SQLAlchemy 快速入門：兩篇 Flask-SQLAlchemy 的快速入門指南，介紹了 Flask-SQLAlchemy 的基本用法，是初學者快速入門 Flask-SQLAlchemy 的好資源。 如何在 Flask 應用程式中使用 SQLAlchemy 進行資料庫 ：這篇教學透過一個小型的學生管理系統展示了如何使用 Flask-SQLAlchemy 擴展來完成基本的資料庫溝通，如連接到資料庫伺服器、建立資料庫表、加入資料、檢索資料、更新資料和刪除資料等操作。 如何使用 Flask Blueprints 和 Flask-SQLAlchemy 構建大型 Flask 應用程式的結構：這篇教學詳細介紹了如何使用 Flask 藍圖和 Flask-SQLAlchemy 構建大型 Flask 應用程式的架構。本文提供了範例程式碼和詳細的解釋，是進階學習 Flask-SQLAlchemy 的好資源。 Flask-SQLAlchemy 文件：Flask-SQLAlchemy 的官方文件，提供了完整的 API 參考、常見問題解答和高級主題等內容。無論你是初學者還是經驗豐富的 Python 開發者，都可以在這裡找到所需的資訊。 Flask SQLAlchemy (with Examples)：這是一篇包含範例的教學，介紹了如何使用 Flask-SQLAlchemy 建立和操作資料庫表。本文包含了範例程式碼和詳細的解釋，是初學者快速掌握 Flask-SQLAlchemy 的好資源。 使用 Flask 和 SQLAlchemy 建立一個基本的 CRUD 應用程式：這篇","link":"/2023/02/13/python-flask/03-relational-database/"},{"title":"【 Flask 教學 】用 Flask Blueprint 組織程式碼","text":"Flask Blueprint 組織程式碼的幾種方式Blueprint 是一個用於標示架構和組織軟體專案的概念。在這裡，我們將探討三種不同的專案組織方式：單一應用程式、模組化應用程式，以及使用 Flask Blueprint 的應用程式。以下是這三種組織方式的程式範例： 按功能劃分藍圖在這種組織方式中，我們根據應用程式的功能劃分藍圖。這個範例包含了一個簡單的 Flask 應用程式，使用了按功能劃分的 Blueprint 組織方式。應用程式有兩個功能模塊：身份驗證（auth）和文章（posts）。每個模塊都有自己的視圖和模板。在 app.py 中，我們註冊了兩個藍圖：auth_blueprint 和 posts_blueprint。 目錄結構： 12345678910111213myproject/ ├── auth/ │ ├── __init__.py │ ├── views.py ├── posts/ │ ├── __init__.py │ ├── views.py ├── templates/ │ ├── auth/ │ │ ├── login.html │ ├── posts/ │ │ ├── list.html └── app.py app.py： 12345678910from flask import Flaskfrom auth.views import auth_blueprintfrom posts.views import posts_blueprintapp = Flask(__name__)app.register_blueprint(auth_blueprint)app.register_blueprint(posts_blueprint)if __name__ == '__main__': app.run() auth/init.py： 1# 空文件 auth/views.py： 1234567from flask import Blueprint, render_templateauth_blueprint = Blueprint('auth', __name__, template_folder='templates/auth')@auth_blueprint.route('/login')def login(): return render_template('auth/login.html') templates/auth/login.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Login Page&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; posts/init.py： 1# 空文件 posts/views.py： 1234567from flask import Blueprint, render_templateposts_blueprint = Blueprint('posts', __name__, template_folder='templates/posts')@posts_blueprint.route('/posts')def list_posts(): return render_template('posts/list.html') templates/posts/list.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Posts&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Posts List&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 按角色劃分藍圖在這種組織方式中，我們根據不同的使用者角色（如管理員、使用者…等）劃分藍圖。這樣可以讓應用程式的不同角色有各自的功能界面和邏輯。以下是按角色劃分 Blueprint 的簡單範例： 目錄結構： 12345678910111213myproject/ ├── admin/ │ ├── __init__.py │ ├── views.py ├── user/ │ ├── __init__.py │ ├── views.py ├── templates/ │ ├── admin/ │ │ ├── dashboard.html │ ├── user/ │ │ ├── profile.html └── app.py app.py： 12345678910from flask import Flaskfrom admin.views import admin_blueprintfrom user.views import user_blueprintapp = Flask(__name__)app.register_blueprint(admin_blueprint, url_prefix='/admin')app.register_blueprint(user_blueprint, url_prefix='/user')if __name__ == '__main__': app.run() admin/init.py： 1# 空文件 admin/views.py： 1234567from flask import Blueprint, render_templateadmin_blueprint = Blueprint('admin', __name__, template_folder='templates/admin')@admin_blueprint.route('/dashboard')def dashboard(): return render_template('admin/dashboard.html') templates/admin/dashboard.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Admin Dashboard&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Admin Dashboard&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; user/init.py： 1# 空文件 user/views.py： 1234567from flask import Blueprint, render_templateuser_blueprint = Blueprint('user', __name__, template_folder='templates/user')@user_blueprint.route('/profile')def profile(): return render_template('user/profile.html') templates/user/profile.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;User Profile&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;User Profile&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 第一個範例按照角色劃分，有 admin 和 user 兩個角色，每個角色有對應的視圖和模板。這些範例分別展示了按角色劃分和按資源劃分的兩種 Flask Blueprint 組織方式。 按資源類型劃分藍圖：在這種組織方式中，我們根據應用程式中的資源類型（如文章、評論等）劃分藍圖。這樣可以讓程式碼更具模組化，便於維護和擴展。在 app.py 中，我們註冊了相應的藍圖。 目錄結構： 12345678910111213myproject/ ├── posts/ │ ├── __init__.py │ ├── views.py ├── comments/ │ ├── __init__.py │ ├── views.py ├── templates/ │ ├── posts/ │ │ ├── list.html │ ├── comments/ │ │ ├── list.html └── app.py app.py： 12345678910from flask import Flaskfrom posts.views import posts_blueprintfrom comments.views import comments_blueprintapp = Flask(__name__)app.register_blueprint(posts_blueprint, url_prefix='/posts')app.register_blueprint(comments_blueprint, url_prefix='/comments')if __name__ == '__main__': app.run() posts/init.py： 1# 空文件 posts/views.py： 1234567from flask import Blueprint, render_templateposts_blueprint = Blueprint('posts', __name__, template_folder='templates/posts')@posts_blueprint.route('/')def list_posts(): return render_template('posts/list.html') templates/posts/list.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Posts&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Posts List&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; comments/init.py： 1# 空文件 comments/views.py： 1234567from flask import Blueprint, render_templatecomments_blueprint = Blueprint('comments', __name__, template_folder='templates/comments')@comments_blueprint.route('/')def list_comments(): return render_template('comments/list.html') templates/comments/list.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Comments&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Comments List&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 比較三種方案下表對比了使用 Flask Blueprint 組織程式碼的三種方式的優缺點： 方式 優點 缺點 按功能劃分藍圖 功能模塊清晰 功能模塊過多時結構可能變得複雜 有利於專案的擴展性和可維護性 按角色劃分藍圖 便於實現角色之間的隔離和權限控制 角色之間存在相似功能時可能導致程式碼重複 有利於專案的擴展性和可維護性 按資源類型劃分藍圖 程式碼具有高度模組化 資源之間有相互依賴時可能需要更多的協調和溝通 便於維護和擴展 在選擇組織方式時，應該根據專案的需求和規模來決定。有時候，可以將這些組織方式結合使用，以便更好地滿足專案需求。 混合使用綜合以上三種使用 Flask Blueprint 的程式碼組織方式，開發者可以根據專案需求靈活選擇或混合應用。在實際應用中，專案可能需要更細緻的組織結構，此時可以將多種組織方式結合起來，以便更好地滿足需求。 例如，我們可以根據應用程式的功能和資源類型同時劃分藍圖： 1234567891011121314151617181920212223242526272829303132333435myproject/ ├── auth/ │ ├── __init__.py │ ├── views.py ├── admin/ │ ├── posts/ │ │ ├── __init__.py │ │ ├── views.py │ ├── images/ │ │ ├── __init__.py │ │ ├── views.py ├── user/ │ ├── posts/ │ │ ├── __init__.py │ │ ├── views.py │ ├── comments/ │ │ ├── __init__.py │ │ ├── views.py ├── templates/ │ ├── auth/ │ │ ├── login.html │ │ ├── register.html │ ├── admin/ │ │ ├── posts/ │ │ │ ├── manage_posts.html │ │ ├── images/ │ │ │ ├── manage_images.html │ ├── user/ │ │ ├── posts/ │ │ │ ├── list.html │ │ │ ├── detail.html │ │ ├── comments/ │ │ │ ├── list.html │ │ │ ├── new_comment.html └── app.py 在這個範例中，我們同時根據功能（身份驗證、管理員、使用者）和資源類型（文章、圖片、評論）劃分藍圖。這樣可以使程式碼更具模組化，便於維護和擴展。同時，不同角色的功能和權限也得到了清晰的區分。","link":"/2023/02/16/python-flask/05-flask-blueprint/"},{"title":"【 Flask 教學 】 透過 URL 傳遞參數與透過表單傳遞","text":"通過 URL 傳遞參數嗨，動態路由你好！Flask 是一個輕量級的 Web 框架，提供了簡單易用的路由定義和視圖函數。其中一個優勢是通過 URL 傳遞參數的能力，也就是動態路由。在這個路由方式下，URL 中的一部分可以作為參數傳遞到視圖函數中，從而實現不同的動態內容呈現。 123@app.route('/greet/&lt;name&gt;')def greet(name): return f'Hello, {name}!' 此路由接受 URL 中的 name 參數，我們可以通過 name 參數在函數中訪問它。例如，如果我們輸入網址 http://localhost:5000/greet/Bob，我們將在頁面上看到 “Hello, Bob!”。 在 Flask 中，使用動態路由需要在路由定義中使用 &lt;parameter_name&gt; 語法，指定要傳遞的參數名稱。這個參數可以是任何類型的資料，包括整數、字符串、浮點數等等。在視圖函數中，我們可以使用這個參數來生成不同的內容。 根據網址的文章 id 導向該篇文章下面我們來看一個具體的例子，假設我們有一個博客網站，每一篇文章都有一個獨特的 ID，我們希望通過 URL 顯示不同的文章內容。那麼，我們可以使用以下的路由定義： 1234@app.route('/article/&lt;int:article_id&gt;')def show_article(article_id): # 在這裡使用 article_id 來顯示文章內容 return '這是文章 %d 的內容' % article_id 在上述程式碼中，&lt;int:article_id&gt; 指定了我們要傳遞一個整數類型的參數 article_id。在視圖函數 show_article 中，我們使用了這個參數來顯示文章內容。這個函數只是一個簡單的範例，實際情況中，我們可以從資料庫中獲取文章內容，然後將其呈現在網頁上。 當使用者訪問 /article/123 時，Flask 會自動提取 URL 中的 123，並將其傳遞到 show_article 視圖函數中。因為我們使用了 &lt;int:article_id&gt;，Flask 會自動確認 123 是一個整數類型的資料，並將其轉換成 article_id 參數的值。然後，視圖函數會使用 article_id 來顯示文章內容。 顯示名稱為 username 的使用者資料在 Flask 中，我們可以使用多個動態路由參數，例如： 1234@app.route('/@app.route('/user/&lt;username&gt;/int:user_id')')def show_user(username, user_id): # 在這裡使用 username 和 user_id 來顯示使用者資料 return '使用者名是 %s，ID 是 %d' % (username, user_id) 在這個路由定義中，我們使用了兩個動態路由參數，&lt;username&gt; 和 &lt;int:user_id&gt;。在視圖函數 show_user 中，我們使用了這兩個參數來顯示使用者資料。 動態路由注意事項使用動態路由時需要注意以下幾點： 參數的類型必須指定。在上面的例子中，我們使用 &lt;int:article_id&gt; 和 &lt;username&gt; 指定了參數的類型。 參數名稱必須和視圖函數中的參數名稱相同。 參數的類型轉換是自動進行的，如果轉換失敗，Flask 會返回 404 錯誤頁面。 總而言之，動態路由是 Flask 提供的一個強大的功能，可以讓我們通過 URL 傳遞參數，實現不同的動態內容呈現。通過 &lt;parameter_name&gt; 語法指定參數名稱和類型，在視圖函數中使用參數來生成不同的內容。使用時需要注意參數類型和名稱，以及類型轉換可能出現的錯誤。 透過表單傳遞資料範例程式以下是一個簡單的 Flask 程式，可以處理表單資料： 12345678910111213141516from flask import Flask, render_template, requestapp = Flask(__name__)@app.route('/')def index(): return render_template('index.html')@app.route('/submit', methods=['POST'])def submit(): name = request.form.get('name') age = request.form.get('age') return f'Hello {name}, you are {age} years old!'if __name__ == '__main__': app.run(debug=True) 這個程式定義了兩個路由： /：顯示一個網頁，該網頁包含一個表單，該表單要求使用者輸入姓名和年齡。 /submit：處理提交的表單資料，並顯示一條歡迎消息，包含使用者的姓名和年齡。 這個程式需要一個名為 index.html 的模板文件，該文件定義了表單的 HTML 程式碼。以下是 index.html 的範例程式碼： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Flask Form Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Enter your name and age:&lt;/h1&gt; &lt;form method=&quot;POST&quot; action=&quot;/submit&quot;&gt; &lt;label for=&quot;name&quot;&gt;Name:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt; &lt;br&gt; &lt;label for=&quot;age&quot;&gt;Age:&lt;/label&gt; &lt;input type=&quot;number&quot; name=&quot;age&quot; id=&quot;age&quot;&gt; &lt;br&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 這個模板文件顯示一個表單，要求使用者輸入姓名和年齡，然後提交表單。表單使用 POST 方法提交到 /submit 路由。 Flask 中的 request.form回頭看 Python 主程式 12345678910111213141516from flask import Flask, render_template, requestapp = Flask(__name__)@app.route('/')def index(): return render_template('index.html')@app.route('/submit', methods=['POST'])def submit(): name = request.form.get('name') age = request.form.get('age') return f'Hello {name}, you are {age} years old!'if __name__ == '__main__': app.run(debug=True) 在 Flask 中，request.form 是一個特殊的 Python 字典，用於處理 POST 方法所傳送的表單資料。當使用者在表單中輸入資料並提交時，POST 請求將表單資料打包在請求主體 (request body) 中，並將其傳送到伺服器。Flask 中的 request 物件可以獲取這些表單資料，request.form 字典會將表單中所有名為 “name” 的欄位值映射到 request.form['name'] 的字典鍵上。 在這段程式碼中，submit() 函數使用 request.form.get() 方法從提交的表單資料中獲取使用者名字和年齡。request.form.get() 方法的作用是從 request.form 字典中獲取指定名稱的值，如果字典中不存在指定名稱的值，則返回 None。例如，name = request.form.get('name') 將會從 POST 請求中獲取名為 “name” 的欄位值，如果不存在這個欄位則返回 None。同理，age = request.form.get('age') 則會從 POST 請求中獲取名為 “age” 的欄位值。最後，這些表單資料可以用來產生回應內容，如 “Hello {name}, you are {age} years old!”。 當使用者提交表單時，Flask 調用 submit 函數處理表單資料。這個函數從 request 對象中獲取 name 和 age 字段的值，然後使用這些值顯示一條歡迎訊息。 請注意，在實際應用中，你應該對提交的資料進行驗證和清理，以防止不良使用者輸入無效資料或惡意資料。你還應該對資料進行適當的安全處理，以保護你的應用免受攻擊。 總結在這個教學中，我們學習了如何在 Flask 中定義路由以及如何處理 URL 參數和表單資料。Flask 為構建 Web 應用程式提供了一個靈活而強大的框架，了解如何定義路由是構建任何 Flask 應用程式的關鍵部分。","link":"/2023/02/16/python-flask/07-dynanic_route_and_forms/"}],"tags":[],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"基礎教學","slug":"Python/基礎教學","link":"/categories/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/"},{"name":"Flask 教學","slug":"Python/Flask-教學","link":"/categories/Python/Flask-%E6%95%99%E5%AD%B8/"}]}