{"pages":[{"title":"饅頭計畫 #3","text":"訓練目標用六個月的時間，用任務導向的方式，將你訓練成一名有競爭力的工程師。六個月後將會完成專屬個人作品， 講師介紹嗨，大家好！我是Luka，曾在外商擔任資深工程師。我擅長將前後端技術相互結合，打造各種不同類型的網站，並以直白的教學方式，解釋複雜的技術，讓初學者能夠輕鬆學習。 我專注於初學者教學，經營著 程式柴 Youtube 頻道 ，提供大量免費的教學內容，包括 HTML、CSS、JS、Python … 等等的教學。 如果你想更了解我，請看我過去在 Medium 撰寫的文章，包含了一些技術文章與一些軟性的文章。 此外，我也喜歡研究硬技術，曾經在 COSCUP、MOPCON、RubyConf 等大型研討會上擔任講師。如果你對我過去的演講內容有興趣，請參考我過去的投影片。 訓練方式全線上進行，Level 1 &amp; 2 有需要時進行線上會議。Level 3 &amp; 4 每週線上開會同步學習進度，展示學習成果，討論技術難點。如果選擇「背水一戰」，每週請準備 50 小時以上的學習時間。如果選擇「持久戰」，每週請自行設定學習時間。(詳細定義請參照背水一戰 vs 持久戰) 時程列表 申請時間：即日起 ~ 2023/12/28 結果通知：提出申請後的兩週內回覆是否通過申請。 Level 1 (4 週)：2024/01/01 ~ 2024/01/28 Level 2 (4 週)：2024/01/29 ~ 2024/02/25 Level 3 (8 週)：2024/02/26 ~ 2024/04/21 Level 4 (10 週)： 2024/04/22 ~ 2024/06/16 適合怎樣的人Q：沒接觸過程式，適合嗎？A：饅頭計畫是為零基礎程式小白設計的訓練計畫，身為程式小白，有非常多的技術需要進修，每個禮拜需要花 60 小時的學習時間才可以跟上進度。 Q：已經有程式基礎的人，適合嗎？A：有程式基礎的話起步會比較輕鬆，但如果稍不注意，在不熟悉的領域，可能一不小心就落後了。饅頭計畫的最終產出的專屬個人作品，依照個人實力的不同，呈現的結果也會不一樣。因此非常歡迎想要挑戰自己的人來參加。 Q：一邊工作一邊轉職的人適合申請嘛？A：適合，因為饅頭計畫的設計「可以讓學生自行安排進度」。如果沒有辦法如果無法在六個月內完成，也可以依照任務逐步進行。 Q：辭去工作轉職的人適合嘛A：適合，因為饅頭計畫的設計就是讓一個零基礎的人，在六個月後可以變成一個合格、有競爭力的工程師。 這邊要再次提醒，裸辭轉職風險很大。尤其現在景氣不好，你的求職競爭對手可能比你更有經驗，那麼求職時間便會拉長。 Level 1 - 踏出第一步，建立信心，累積成就感學習目標在等級一的關卡，瞭解了網際網路如何運作，了解程式語言基礎，並且用 Python 與 JS 實作了一個簡易的網路應用 (Web Application)。 每週進度 初學 Python / JS 雙刀流 網頁設計流程與切板 (HTML, CSS, RWD) 用 jQuery 理解 JS Web API 初探後端 (Python Flask) 與網路基礎 訓練時間：四週相關技術：HTML、CSS、JavaScript、Flask解鎖課程：HTML &amp; CSS 基礎、Python 基礎、 JavaScript 基礎、jQuery 基礎 Level 2 - 更進一步，小型專案開發學習目標在等級二的關卡，我們將升級上一個關卡中的前端與後端技術，打造一個麻雀雖小、卻很完全的有趣應用。讓 Web 技術覆蓋的面積更加的完整 每週進度 完整學習 Python Flask 基礎 MySQL 關聯式資料庫入門 會員系統開發 Ajax 前後端串接小型專案 訓練時間：四週相關技術：HTML、CSS、JavaScript、Flask解鎖課程：Flask 基礎、SQL 基礎、Bootstrap 基礎 Level 3 - 獨立開發電商網站學習目標在等級三的關卡中，你需要獨立開發電商網站。前端使用現代化的前端技術和 React.js 框架，後端使用 Flask 開發網頁實作前端需要的 API。並且串接金流，並需要將成品佈署到 AWS 上。 每週進度 需求分析 + 可行性評估 爬蟲獲取資料 + 資料庫設計 首頁功能實作 汽車瀏覽頁面功能實作 預約看車功能實作 支付訂金功能實作 會員功能整合 (Google / Fb 登入) 佈署上雲端 (AWS) 訓練時間：八週相關技術：AWS、Python、現代前端開發工具、React、Webpack、Babel、Bootstrap解鎖課程：React 基礎課程、現代前端工具課程、Flask 進階課程、AWS 基礎 Level 4 - 打造個人專屬作品 (專精前端 / 後端)學習目標在等級四的關卡中，第一步要做的是熟悉專精知識，包含理論與實作。最終你將打造個人專屬作品，如果的目標是轉職，成為你的面試作品。如果你是來進修的，你將學會完成一個完成度高的 Side Project。 每週進度 專精技術（一）前端專精 React.js &amp; 後端專精 Django 專精技術（二）&amp; 專屬作品發想 打造專屬作品 (一) 使用者故事撰寫、頁面流程、資料庫規劃 打造專屬作品 (二) 技術難點研究 打造專屬作品 (三) 開發主要功能 打造專屬作品 (四) 開發次要功能 打造專屬作品 (五) 優化與除錯 打造專屬作品 (六) 完成專屬作品 面試準備(一) 履歷撰寫、面試練習、解題練習 面試準備(二) 模擬面試練習 訓練時間：十週相關技術：React、Django、AWS、Docker解鎖課程：React 實戰、Django 實戰、Docker 基礎、AWS 進階 課程進行方式線上影音教材饅頭計畫提供專屬的課程教材平台提供給學員觀看，讓學員可以快速掌握一門技術。在學習期間可無限次數重複觀看。部分影片跟Youtube 頻道相同，雖然部分影片相同，但是學習的成效大不同。透過「解任務」的方式使用影片中的技術實際解決問題，確實掌握技術的精髓。這也是為何免費公開部分教材的原因。 任務導向學習課程提供大量的影音教材讓學員得以獲得充足的知識。然而單向的學習不足以培養出足以勝任職場的能力，因此使用「任務導向」的方式來學習。 完成每週任務的過程中，你可以使用任何你想得到的方式。例如：你可以問程度比較好的同學，或是你可以問以前的朋友，工作上現在正在寫程式的，或是你可以到任何的開放社群發問，只要對你有幫助的都可以嘗試。 這樣做的目的是幫助你建立一套學習系統，而不是單純學會課堂上的內容，一旦遇到未知的問題就會手足無措。 專案導向學習數週的學習成果，相互呼應，形成較具規模的專案。 Level 1 &amp; Level 2使用 Python + JS 開發一個的一體式架構網站。讓學員感受到開發的樂趣，培養成就感。 Level 3 開始比較硬一點，但也可以學到更多。「獨立開發」一個 MPA + SPA 混合型電商網站。開發的專案題目是相同的，在這個階段中，大家可以體會到在需求的壓力下，如何分配學習的時間，並進而找出方法解決問題。 Level 4 選擇專精前端或者專精後端，打造個人專屬作品。專精前端使用的技術為 React，專精後端使用的技術為 Django。專精前端、專精後端可以兩個人組隊，建構出更完整的作品。如果你是屬於硬派的學習者，也可以前端、後端都自己寫。 多場線上直播Level 1、Level 2 大約兩個禮拜一次線上直播。Level 3、Level 4 每週一次線上會議，同步進度、展示成果，問題討論。 說明「每週任務」與說明每週需要學習的目標 回顧上一週的任務大家的執行狀況，看看有沒有什麼地方需要修正的。 透過學員的反饋，即時補強一些缺乏的重要概念，打通任督二脈。 ps：如果遇到國定假日可能會取消該次直播交流。比較沒有事情的時候直播就以關注學員學習成果為主。 課程規則模擬上班打卡上班開始學習的時候進行「打卡上班」，結束學習時「打卡下班」。學習時間可以自行決定，希望可以規律一點，比較容易持之以恆，例如：每週固定兩個晚上、週末固定一天進行學習。 找得到人每日打卡設計的出發點是讓學員有儀式感，開始學習的時候就專心學習，透過每日打卡，可以知道目前上線學習的同學有哪些。使得在線上的同學們可以互相交流，增加學習動力。 蹺班機制打卡的同時請登入 Discord 頻道，方便同學互相交流。如果私訊超過 1 小時以上未回覆，記錄當日蹺班。 了解自主學習時間打卡可以準確的估算當週的學習時間，方便自我檢視實際學習時間是否跟最初設定的是否有落差。 學習日誌學習時順手記錄筆記，使用「學習日誌」記錄下來，讓日後可以花更少的時間回憶，將破碎的記憶片段組織成具體的知識點。學習日誌格式： (必填) 今天要做什麼？ (必填) 遇到了什麼困難？ps: 沒有的話就寫沒有即可 (必填) 明天要做什麼？ (必填) 今日速記：學習到什麼馬上隨手記錄下來，讓大腦可以專注於重要的事情 (選填) 本日心得：推薦使用 ORID 焦點描述法撰寫心得 每週回顧以週為單位來檢視自己的學習成果，主要檢視的幾點有： 這週學到了哪些東西？ 有沒有遇到什麼困難？ 這週的學習效率好嗎？好的話寫下原因，繼續保持。不好的話寫下原因，下週修正。 下週要做的事情有哪 本週學習心得 透過以上資訊學習教練可以更準確的掌握學員狀況，給予幫助。 每週任務每週指派一定數量的任務，需在截止期限前繳交。每週任務「沒有」手把手的教學，需要用你任何想得到的方式，來解決這個任務。更詳細的說明，請見「任務導向學習」。 課程資訊背水一戰 vs 持久戰根據過往的經驗參加的學員大致上可分為兩種： 背水一戰：目前無正職工作，全力學習，每週可花 50 個小時以上學習。 持久戰：有工作的狀況下想要學習，根據之前統計的結果，如果有工作的狀態下，一個禮拜大約有 15 小時左右的學習時間。 背水一戰背水一戰可以更專心的準備轉職，但相對來說有更大的經濟壓力，如果沒有先存一筆錢，不工作 6 個月很容易斷糧。 如果你能夠有 6 個月的完全空白學習時間，並且能夠保持紀律性，持之以恆的學習。饅頭計畫的課程設計將幫助你轉職成工程師。 持久戰整體來說「持久戰」是我更推薦的方案，因為參加「背水一戰」班的人往往想要壓力更大，但後來發現自己根本沒那麼多時間，或是沒準備那麼多的生活費，最後斷糧只能失敗作收。一邊工作一邊轉職的話只要能撐下去，完成個人專屬的作品，累積面試經驗，最後會有不錯的結果。 求職時間比較採用「背水一戰」模式的話，找到工作時間約略是 6-8 個月之間。以每週可學習時數來換算的話，使用「持久戰」模式的人大約需要花三倍左右的時間，也就是 18 個月 ~ 24 個月左右。實務上，也有「持久戰」的零基礎同學在一年內就找到工作的成功案例。 心得現在的大環境下建議大家多保留一些緩衝空間，如果不是經濟上有餘裕，建議先保留原本的工作，選擇「持久戰」方案即可。如果真的要拼半年轉職，請先準備好 6 個月的學習時間與 2 個月求職緩衝時間的生活費，以免真的辭職了，卻因經濟因素沒辦法專心學習，得不償失。 零元挑戰如果你是「背水一戰」辭去工作轉職，並且能夠做到以下幾點。在結訓六個月之後的兩個月內沒有找到工作，全額退費。如果使用這個方案有找到工作的話，收費會是 1.5 個月的月薪。 每週固定學習 50 小時以上(以打卡時間為準) 每週任務準時繳交 準時完成各個關卡的魔王專案 撰寫學習日誌(有學習的日子都要記錄) 撰寫每週回顧 這次的規則定的比較嚴格，因為上一屆規則定的太鬆，沒有一定的自制力真的無法成功轉職。如果辭去工作背水一戰，努力訓練六個月努力還是無法找到工作，那就是課程設計有問題，全額退費。 每個月不分項目有 3 次容錯空間，超過即判定零元挑戰失敗。例如：缺交作業 1 次、當週學習時數未滿 50 小時 1 次、未撰寫學習日誌 2 次，合計違規 4 次，判定失格。 學習方案 闖關模式 台幣戰士 方案說明 完成一個關卡後，才能接關下一個關卡。 一次購入需要的訓練關卡。 適合對象 對自己是否對寫程式有興趣抱持疑問，使用這個方案最為保險。 1. 已確定要投入大量時間在轉職上2. 可用時間較零碎3. 沒有充足時間 設計原理 通過各個關卡逐步瞭解自己是否適合寫程式。 透過完整的方案學習就業所需的所有技能 卡關機制 有。當前關卡中的任務和魔王專案未完成，無法開啟下一關的內容。 無。當前關卡未破之前可以直接進行下一關卡，有空時再回去破之前關卡。 整體費用 價格較高 經濟實惠Level 1 ~ 3 省 5000Level 1 ~ 4 省 9000 繳費方式 每個關卡分開繳納，逐步體驗。 買斷課程，可選擇一次付清或是分期。分期下來一個月約 6000 元，相當優惠。 價格方案簡單說明一下價格方案，如果還未確定對程式是否有興趣，選擇闖關模式風險更小。如果下定決心，那麼合購的價格更加划算。 類型 級別 價格 上課時間 鑑賞期 闖關模式 Level 1 3000 4 週 5 天 闖關模式 Level 2 5500 4 週 5 天 闖關模式 Level 3 16500 8 週 5 天 闖關模式 Level 4 20000 10 週 5 天 如果選擇台幣戰士，有以下幾種可以選擇 類型 關卡列表 原價 特價 上課時間 平均每個月 鑑賞期 合購優惠 Level 1 + 2 + 3 25000 20000 4 個月 5000元/月 14 天 合購優惠 Level 1 + 2 + 3 + 4 45000 36000 6 個月 6000元/月 14 天 如果選擇「零元挑戰」，在時限內求職成功，則需繳交(1.5個月薪水 - 已繳交學費)的差額。如果在遵守規則的情況下，在時限內無法找到工作，已繳交學費全額退還。如果未遵守規則，則判定零元挑戰失敗，還是可以依照購買的方案繼續上課。 退費說明：在鑑賞期內，如果你不滿意，將無條件退還課程費用的 90%。這項退費政策是基於軟體訂閱和其他不可逆轉的成本考量，因此原課程費用的 10% 將作為辦理退費的手續費。 報名資訊招生人數根據報名人數而定，原則上 Level 3, Level 4 希望是小班制教學，如果人數已滿將停止招生。 報名流程填寫報名表單 + 寄一封信，做完這兩個步驟之後才算完成報名呦。 填寫 報名表單，在這邊選擇你想要選擇的方案。 寄一封信到 codeshiba@gmail.com，標題：饅頭計畫#3 報名_你的姓名，內容如下方範本。 報名後兩個禮拜內寄送報名結果通知，錄取後，根據選擇方案繳交第一期費用完成報名。 信件範本嗨，你好！我是 XXX 我來報名饅頭計畫 3 了 說說你是怎麼樣的人，過著怎麼樣的生活，為什麼要學程式 以前有學過程式嘛？你做了哪些努力來學程式？ 開始做作品了嘛？ 小練習也不要不好意思，讓我可以了解你程度。 想透過參加饅頭計畫獲得哪些幫助？ 你的短期目標是？例如：半年內你想達成什麼事情 你的長期目標是什麼呢? 例如：兩年目標想達成些什麼事情 任何想說的話或是想問的問題 饅頭計畫演化史零 - 起源「饅頭計畫 第零彈」是一個帶領新手快速突破技術瓶頸的計畫。作者 Luka 分享了計畫的初衷、自己的背景，以及學生 Moo Jing 在計畫中的學習成果。透過一對一的密集指導，Moo Jing 從前端工程師轉型學習後端技術，並在一個月內取得顯著進步，包括網站規劃、學習方法和技術實作等多方面的成長。 壹 - 設計理念經過一段時間的，發布了「饅頭計畫第一彈」。分為三個階段：衝刺的嬰兒、翻轉教學和 YouTube 教學。 衝刺的嬰兒：這階段適合能夠承受壓力、有大量時間投入學習的人。課程節奏快速，涵蓋基礎網頁開發知識。 翻轉教學：這階段適合有長期學習目標的學生。學生可以根據自己的步調學習，透過觀看預先錄製的教學影片和參與互動式問答來學習。 YouTube 教學：最後階段，將課程內容公開於 YouTube，讓更多人能夠自行學習。 雖然這是一個免費的教學計畫，但學生應該認真對待，並且自己的努力是關鍵。課程的目標是打下扎實的基礎，培養成為一名工程師所需的思維和技能。 最後的成果：饅頭計畫第一彈 最後成果：15 人跟課到最後，10 人轉職成功！ 貳 - 極限就業的雙面刃饅頭計畫第二彈是以極速就業為導向的一個就業服務，執行之後，有部分同學的確很快的就找到了工作，但是也有些同學為了追求快，而忽略了些重要的基礎。 整體來說，課程設計的還行，節錄一段： 培養你成為一個工程師應該有的思維和技能。打下扎實的基礎，讓你可以在學習程式的路上有一個很好的開始。在你之後挑戰更高的職缺時，你會感受到基礎的重要性的。 詳細內容可以看這一篇。後來執行的結果，覺得不算好，因為這一屆盡量降低學習曲線，這樣的情況下盡量不給學員太大壓力。因為我想說要培養興趣。後來證實，這樣做的效果似乎不太好。還是要有一定的壓力才能使人有突破的成長。 成果記錄在這篇文章：饅頭計畫第二彈成果報告. 14 人參加，順利找到工作的 6人，成功率 42% 。 歷屆過程記錄 饅頭計畫第零期 -不管你是前端、後端，兇狠的變強吧 ！ 饅頭計畫第一彈 — 從零開始茁壯吧！ 一步一腳印，扎實成長. 饅頭計畫前端幼幼班教材釋出｜HTML、CSS、JS、jQuery、Git 、CMD Line 教學一次滿足 饅頭計畫第一彈成果分享 最後成果：15 人跟課到最後，10 人轉職成功！ 饅頭計畫第二彈 | 挑戰最難的教學，以成果為導向的就業服務 饅頭計畫第二彈成果報告. 14 人參加，順利找到工作的 6人，成功率 42% 。 歷屆學員心得 順序 學員名稱 1 饅頭計畫 #2 學員心得 (1) Phoebe 2 饅頭計畫 #2 學員心得 (2) 慶慶 3 饅頭計畫 #2 學員心得 (3) Eva 4 饅頭計畫 #2 學員心得 (4) 鈺涵 5 饅頭計畫 #2 學員心得 (5) Michael 6 饅頭計畫 #2 學員心得 (6) Shawn 7 饅頭計畫 #2 學員心得 (7) Lily 8 饅頭計畫 #1 學員心得 (1) Joanne 9 饅頭計畫 #1 學員心得 (2) GK 10 饅頭計畫 #1 學員心得 (3) Genie 11 饅頭計畫 #1 學員心得 (4) TsungYu 12 饅頭計畫 #1 學員心得 (5) Leah 13 饅頭計畫 #1 學員心得 (6) Shirley 14 饅頭計畫 #1 學員心得 (7) Theo 15 饅頭計畫 #1 學員心得 (8) Windy 16 饅頭計畫 #1 學員心得 (9) Phoenix 17 饅頭計畫 #1 學員心得 (10) 昱穎 18 饅頭計畫 #1 學員心得 (11) Trista 19 饅頭計畫 #1 學員心得 (12) Celine 20 饅頭計畫 #1 學員心得 (13) Sherry 21 饅頭計畫 #1 學員心得 (14) Orow 22 饅頭計畫 #1 學員心得 (15) Old Mo 23 饅頭計畫 #0 學員心得 Moojing 聯絡方式有任何問題，歡迎使用電子郵件聯繫，請寄信至 codeshiba.gmail.com也可以傳訊息至程式柴 FB 粉絲專頁。","link":"/bootcamp/index.html"},{"title":"JS Web API 教學","text":"什麼是 JS Web APIJavaScript Web API（Application Programming Interface）是一組在網頁瀏覽器中可用的功能和接口，它們擴展了 JavaScript 的能力，使開發人員能夠與瀏覽器和網頁內容進行互動。 JavaScript Web API 包括以下功能和能力： 操作 DOM（Document Object Model）：用於改變網頁上的元素，例如選擇元素、修改內容和樣式，以及添加或刪除元素。 事件處理：允許處理事件，如點擊、輸入、滑鼠移動等，以實現交互性。 發送 HTTP 請求：用於從網絡上獲取數據，包括網頁 API、外部數據 API 等。 圖像、音頻和視頻處理：允許加載、顯示和操作媒體內容。 地理位置信息：提供訪問用戶設備的地理位置數據，用於定位應用。 本地存儲數據：用於在瀏覽器中保存數據，例如 Cookies、Web Storage 和 IndexedDB 等。 這些 API 的存在使得開發人員能夠建立動態、交互性和功能豐富的網頁應用程序，這些應用程序可以回應用戶的操作，從而提供更好的用戶體驗。總之，JavaScript Web API 是網頁開發的關鍵元素，它們使得創建現代網頁應用變得可能並且更容易實現。 DOM API當我們談論 DOM（Document Object Model, 文件物件模型）API 時，實際上是在談論你如何以生動的方式與網頁上的元素互動。DOM 是你和網頁之間的橋樑，讓你可以透過程式碼來操作和改變網頁的外觀和行為。現在，讓我們深入了解 DOM 的不同方面，並附上簡單的範例以幫助你理解 選擇元素和訪問其屬性這就像在一個巨大的零食袋中挑選你最愛的糖果一樣。你可以使用 JavaScript 來選擇網頁上的元素，然後獲取它們的屬性或內容。例如，你可以通過元素的 ID 來選擇它，並獲取其文字內容。 首先，創建一個 HTML 檔案（例如：index.html）如下： 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-TW&quot;&gt;&lt;head&gt; &lt;title&gt; 選擇元素和獲取文字內容 &lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt; 選擇元素和獲取文字內容 &lt;/h1&gt; &lt;p id=&quot;myElementId&quot;&gt; 曾經在一個遙遠的網頁上，有一段文字...&lt;/p&gt; &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 接著，創建一個 JavaScript 檔案（例如：script.js）如下： 12345678// 首先，我們需要選擇指定ID的HTML元素var myElement = document.getElementById('myElementId');// 接著，我們使用一段程式碼來獲取它的文字內容var textContent = myElement.textContent;// 最後，我們將獲取的文字內容輸出到控制台，以揭示文字的內容console.log(&quot;這段文字告訴了我們：&quot;, textContent); 這段程式是一個簡單的 JavaScript 代碼，它的作用是選擇 HTML 文件中具有特定 ID 的段落元素，然後獲取該段落元素的文字內容，最後在瀏覽器的控制台中顯示這些文字內容。 它演示了如何使用 JavaScript 來操作 HTML 文檔中的元素和數據 ** 選擇元素 **：透過 document.getElementById('myElementId')，這段程式使用 DOM 方法 getElementById 來選擇具有特定 ID 的 HTML 元素。這展示了 DOM 如何通過元素的 ID 來選擇特定的元素。 ** 檢索元素的文字內容 **：使用 myElement.textContent，這段程式獲取了選定元素的文字內容。這顯示了如何使用 DOM 的屬性來獲取元素的內容。 ** 操作 HTML 文檔 **：最後，這段程式使用 console.log 方法將獲取到的文字內容輸出到瀏覽器的控制台中。儘管這不是直接改變 HTML 文檔的演示，但它展示了如何使用 JavaScript 來處理和操作 HTML 文檔中的數據。 這個簡單的範例展示了 DOM 的一部分，即如何通過 JavaScript 選擇和操作 HTML 元素，並檢索它們的內容。這是 DOM 在實際網頁開發中常見的應用之一，用於與網頁上的元素進行互動和操作。 修改元素的內容和樣式想像一下你有一個魔法筆，可以改變糖果的顏色和味道。你可以使用 JavaScript 來更改元素的文字內容或樣式，讓網頁變得更吸引人。 12345// 修改元素的文字內容myElement.textContent = '嗨，我是新的文字內容！';// 修改元素的樣式myElement.style.color = 'red'; 創建、添加和刪除元素像是在製作自己的糖果，你可以使用 JavaScript 動態地創建新的元素，然後將它們添加到網頁中，或者刪除不需要的元素。 123456789// 創建一個新的 &lt;div&gt; 元素var newDiv = document.createElement('div');// 添加新元素到網頁document.body.appendChild(newDiv);// 刪除一個元素var elementToRemove = document.getElementById('elementToRemove');elementToRemove.remove(); 事件處理程序和事件監聽器想像一下，你在派對上擔任 DJ，你需要監聽歌曲請求並播放音樂。在網頁上，你可以使用事件處理程序和事件監聽器來響應用戶的操作，例如點擊按鈕或提交表單。 1234// 添加點擊事件監聽器myElement.addEventListener('click', function() { alert('你點擊了我！');}); 瀏覽器事件模型這就像是一場糖果瀑布，事件從頂部開始流下來，直到達到最底層的元素。瀏覽器事件模型描述了事件如何在 DOM 樹中傳播，並允許你捕獲和處理事件。 遍歷 DOM 樹想像一下你在糖果商店中探險，尋找最美味的糖果。你可以使用 JavaScript 來遍歷整個 DOM 樹，找到你想要的元素，然後對它們進行操作。 12345// 遍歷所有段落元素並修改它們的樣式var paragraphs = document.querySelectorAll('p');paragraphs.forEach(function(paragraph) { paragraph.style.fontWeight = 'bold';}); 希望這些生動的比喻和範例幫助你更好地理解 DOM（文件物件模型）API，並開始寫程式碼來控制網頁上的元素！如果你有更多問題，請隨時問我。","link":"/mentocamp/js-web-api.html"},{"title":"如何從 jQuery 轉換到原生 JS 語法","text":"從 jQuery 轉換到原生 JS 的重要性可以從幾個方面來解釋： 性能優化：原生 JS 比起依賴於 jQuery 的程式碼，通常會有更好的性能。這是因為原生 JS 直接與瀏覽器的 API 互動，沒有額外的抽象層，這減少了執行時間和記憶體使用。 現代瀏覽器的改進：過去，jQuery 是很受歡迎的，主要是因為它能夠解決跨瀏覽器的兼容性問題。但隨著時間的推移，現代瀏覽器已經大幅改進，許多原生 JS API 現在在主流瀏覽器中都有很好的支援，這使得直接使用原生 JS 變得更加可行。 學習和理解底層：了解原生 JS 對於任何前端開發者來說都是一項重要的技能。它不僅僅是學習語法，更是理解 JavaScript 如何工作的基礎。這對於深入了解程式語言和瀏覽器的運作方式非常重要。 依賴性減少：使用原生 JS 可以減少對第三方庫的依賴。這意味著程式碼更加獨立，避免了因為依賴的庫不再維護或更新而造成的風險。 現代框架和工具鏈：現代的前端開發趨勢是使用如 React、Vue 或 Angular 這樣的框架，這些框架大多基於原生 JS 和新的網頁標準。因此，掌握原生 JS 對於使用這些現代工具非常有幫助。 學習和使用原生 JavaScript 是為了提高性能，與現代瀏覽器和框架保持一致，減少外部依賴，並深入理解 JavaScript 的工作原理。這些都是對前端開發者而言非常重要的。 選擇器 Selector非常感謝你的慷慨！我將詳細說明如何使用 jQuery 和原生 JavaScript (JS) 分別實現每個段落的效果。 1. ID 選擇器效果說明使用 jQuery 和原生 JavaScript 選擇具有特定 ID（”myElement”）的元素，並將其文字內容更改為 “哇！這個盒子變成了火箭！”，然後將文字顏色設定為紅色。 使用 jQuery 實現12$(&quot;#myElement&quot;).html(&quot;哇！這個盒子變成了火箭！&quot;);$(&quot;#myElement&quot;).css(&quot;color&quot;, &quot;red&quot;); 使用原生 JavaScript 實現123var element = document.getElementById(&quot;myElement&quot;);element.innerHTML = &quot;哇！這個盒子變成了火箭！&quot;;element.style.color = &quot;red&quot;; 詳細說明 使用 jQuery，我們使用 $() 函數來選擇 ID 為 “myElement” 的元素，然後使用 .html() 方法來設定內容，使用 .css() 方法來設定文字顏色。 使用原生 JavaScript，我們使用 document.getElementById(&quot;myElement&quot;) 來選擇具有特定 ID 的元素，然後使用 .innerHTML 屬性來設定內容，使用 .style.color 屬性來設定文字顏色。 Class 選擇器效果說明使用 jQuery 和原生 JavaScript 選擇所有帶有 “myClass” 類別的元素，將它們的文字內容更改為 “大家都變成了魔法師！”，然後將它們的背景顏色設定為黃色。 使用 jQuery 實現12$(&quot;.myClass&quot;).html(&quot;大家都變成了魔法師！&quot;);$(&quot;.myClass&quot;).css(&quot;background-color&quot;, &quot;yellow&quot;); 使用原生 JavaScript 實現12345var elements = document.querySelectorAll(&quot;.myClass&quot;);elements.forEach(function(element) { element.innerHTML = &quot;大家都變成了魔法師！&quot;; element.style.backgroundColor = &quot;yellow&quot;;}); 詳細說明 使用 jQuery，我們使用 $() 函數來選擇具有 “myClass” 類別的所有元素，然後使用 .html() 方法來設定內容，使用 .css() 方法來設定背景顏色。 使用原生 JavaScript，我們使用 document.querySelectorAll(&quot;.myClass&quot;) 來選擇所有帶有特定類別的元素，然後使用 .forEach() 方法遍歷它們，對每個元素使用 .innerHTML 屬性來設定內容，使用 .style.backgroundColor 屬性來設定背景顏色。 元素選擇器效果說明使用 jQuery 和原生 JavaScript 選擇所有 &lt;p&gt; 元素，將它們的文字內容更改為 “咦，我變成了魔法書！”，並添加點擊事件監聽器，以在點擊時顯示警示框以顯示秘密資料。 使用 jQuery 實現1234$(&quot;p&quot;).html(&quot;咦，我變成了魔法書！&quot;);$(&quot;p&quot;).click(function() { alert(&quot;快看，這個魔法書有秘密！&quot;);}); 使用原生 JavaScript 實現12345678var paragraphs = document.querySelectorAll(&quot;p&quot;);paragraphs.forEach(function(paragraph) { paragraph.innerHTML = &quot;咦，我變成了魔法書！&quot;; paragraph.addEventListener(&quot;click&quot;, function() { alert(&quot;快看，這個魔法書有秘密！&quot;); });}); 詳細說明 使用 jQuery，我們使用 $() 函數來選擇所有 &lt;p&gt; 元素，然後使用 .html() 方法來設定內容，使用 .click() 方法添加點擊事件監聽器。 使用原生 JavaScript，我們使用 document.querySelectorAll(&quot;p&quot;) 來選擇所有指定元素，然後使用 .forEach() 方法遍歷它們，對每個元素使用 .innerHTML 屬性來設定內容，並使用 .addEventListener() 方法添加點擊事件監聽器。 事件 Event以下是針對每個效果的詳細解釋和範例程式碼 滑鼠事件，點擊 (click) 與連續兩次點擊 (dblclick)效果說明 使用 jQuery 實現點擊一次元素時觸發單擊事件，連續兩次點擊時觸發雙擊事件。 使用原生 JavaScript 實現點擊一次元素時觸發單擊事件，連續兩次點擊時觸發雙擊事件。 使用 jQuery 實現123456789// 單擊事件$(&quot;#myElement&quot;).click(function() { alert(&quot;單擊事件發生！&quot;);});// 雙擊事件$(&quot;#myElement&quot;).dblclick(function() { alert(&quot;雙擊事件發生！&quot;);}); 使用原生 JavaScript 實現12345678910111213141516var element = document.getElementById(&quot;myElement&quot;);var clicks = 0;// 單擊事件element.addEventListener(&quot;click&quot;, function() { clicks++; if (clicks === 2) { alert(&quot;雙擊事件發生！&quot;); clicks = 0; }});// 防止連續單擊事件element.addEventListener(&quot;dblclick&quot;, function(event) { event.preventDefault();}); 詳細說明 使用 jQuery，我們使用 .click() 和 .dblclick() 方法來添加單擊和雙擊事件的監聽器。 使用原生 JavaScript，我們使用 .addEventListener() 來添加單擊事件的監聽器，並使用變數 clicks 來追蹤點擊次數，以實現連續兩次點擊事件。為了防止連續單擊事件，我們還阻止了雙擊事件的預設行為。 滑鼠事件，移入 (mouseenter) 與移出(mouseout)效果說明 使用 jQuery 實現當滑鼠移入元素時觸發移入事件，當滑鼠移出元素時觸發移出事件。 使用原生 JavaScript 實現當滑鼠移入元素時觸發移入事件，當滑鼠移出元素時觸發移出事件。 使用 jQuery 實現123456789// 移入事件$(&quot;#myElement&quot;).mouseenter(function() { alert(&quot;滑鼠移入事件發生！&quot;);});// 移出事件$(&quot;#myElement&quot;).mouseout(function() { alert(&quot;滑鼠移出事件發生！&quot;);}); 使用原生 JavaScript 實現1234567891011var element = document.getElementById(&quot;myElement&quot;);// 移入事件element.addEventListener(&quot;mouseenter&quot;, function() { alert(&quot;滑鼠移入事件發生！&quot;);});// 移出事件element.addEventListener(&quot;mouseout&quot;, function() { alert(&quot;滑鼠移出事件發生！&quot;);}); 詳細說明 使用 jQuery，我們使用 .mouseenter() 和 .mouseout() 方法來添加滑鼠移入和移出事件的監聽器。 使用原生 JavaScript，我們使用 .addEventListener() 來添加 mouseenter 和 mouseout 事件的監聽器。 如何在 vscode 中快速產生 ready code snippet對於在 Visual Studio Code (VSCode) 中快速生成 ready 事件程式碼塊，無論是使用 jQuery 還是原生 JavaScript，都有相應的方法 使用 jQuery 實現在 VSCode 中輸入 “ready” 並按下 Tab 鍵，即可生成 ready 事件程式碼塊。VSCode 會自動識別你想要使用 jQuery 的 ready 函數，然後生成以下程式碼 123$(document).ready(function() { // 在這裡放置你的程式碼}); 使用原生 JavaScript 實現VSCode 也可以自動生成 DOMContentLoaded 事件的程式碼塊，無需特殊程式碼。 只需在 HTML 文件中輸入以下部分 12345&lt;script&gt;document.addEventListener(&quot;DOMContentLoaded&quot;, function() { // 在這裡放置你的程式碼});&lt;/script&gt; 當你輸入上述部分時，VSCode 通常會自動提供提示，讓你輕鬆生成 DOMContentLoaded 事件程式碼塊。 這樣，無論你是使用 jQuery 還是原生 JavaScript，都可以輕鬆生成 ready 事件程式碼塊，以確保在 DOM 完全就緒時執行你的 JavaScript 程式碼。 詳細說明 在 VSCode 中，當你輸入 “ready” 並按下 Tab 鍵，它會自動生成 ready 事件的程式碼塊，不論是使用 jQuery 還是原生 JavaScript。 我們怎麼知道 DOM 是否已經就緒 - 使用 ready效果說明 使用 jQuery 實現使用 ready 函數確保 DOM 已經就緒並可以操作。 使用原生 JavaScript 實現使用 DOMContentLoaded 事件確保 DOM 已經就緒並可以操作。 使用 jQuery 實現123$(document).ready(function() { // 在這裡放置你的程式碼}); 使用原生 JavaScript 實現123document.addEventListener(&quot;DOMContentLoaded&quot;, function() { // 在這裡放置你的程式碼}); 詳細說明 使用 jQuery，我們使用 $(document).ready() 來確保文件已經完全加載並且 DOM 可以被操縱。 滑鼠的 hover 事件效果說明 當滑鼠移入元素時，將改變元素的外觀（例如，改變背景顏色）。 當滑鼠移出元素時，恢復元素的初始外觀。 使用 jQuery 實現123456789101112$(document).ready(function() { $(&quot;#myElement&quot;).hover( function() { // 滑鼠移入事件 $(this).css(&quot;background-color&quot;, &quot;yellow&quot;); }, function() { // 滑鼠移出事件 $(this).css(&quot;background-color&quot;, &quot;&quot;); // 恢復初始背景顏色 } );}); 使用原生 JavaScript 實現12345678910111213document.addEventListener(&quot;DOMContentLoaded&quot;, function() { var element = document.getElementById(&quot;myElement&quot;); element.addEventListener(&quot;mouseenter&quot;, function() { // 滑鼠移入事件 this.style.backgroundColor = &quot;yellow&quot;; }); element.addEventListener(&quot;mouseleave&quot;, function() { // 滑鼠移出事件 this.style.backgroundColor = &quot;&quot;; // 恢復初始背景顏色 });}); 詳細說明 使用 jQuery，我們使用 .hover() 方法，接受兩個函數作為參數，第一個函數處理滑鼠移入事件，第二個函數處理滑鼠移出事件。 使用原生 JavaScript，我們使用 .addEventListener() 來添加 mouseenter 和 mouseleave 事件的監聽器，分別處理滑鼠移入和移出事件。 如果遇到沒看過的滑鼠事件該怎麼辦效果說明 學習如何處理未知的滑鼠事件。 使用 jQuery 實現12345$(document).ready(function() { $(&quot;#myElement&quot;).on(&quot;unknownMouseEvent&quot;, function(event) { alert(&quot;未知的滑鼠事件發生&quot; + event.type); });}); 使用原生 JavaScript 實現1234567document.addEventListener(&quot;DOMContentLoaded&quot;, function() { var element = document.getElementById(&quot;myElement&quot;); element.addEventListener(&quot;unknownMouseEvent&quot;, function(event) { alert(&quot;未知的滑鼠事件發生&quot; + event.type); });}); 詳細說明 無論是 jQuery 還是原生 JavaScript，你都可以添加一個事件監聽器來處理滑鼠事件。當發生未知的滑鼠事件時，你可以使用 event.type 屬性來獲取事件的類型並進行處理。 on(‘click’, ..) 與 click() 是等價的效果說明 介紹 on('click', ...) 和 click(...) 方法之間的等價性。 使用 jQuery 實現123456789$(document).ready(function() { $(&quot;#myElement&quot;).on(&quot;click&quot;, function() { alert(&quot;使用 on 方法處理點擊事件！&quot;); }); $(&quot;#myElement2&quot;).click(function() { alert(&quot;使用 click 方法處理點擊事件！&quot;); });}); 使用原生 JavaScript 實現123456789101112document.addEventListener(&quot;DOMContentLoaded&quot;, function() { var element = document.getElementById(&quot;myElement&quot;); var element2 = document.getElementById(&quot;myElement2&quot;); element.addEventListener(&quot;click&quot;, function() { alert(&quot;使用 addEventListener 方法處理點擊事件！&quot;); }); element2.addEventListener(&quot;click&quot;, function() { alert(&quot;使用 addEventListener 方法處理點擊事件！&quot;); });}); 詳細說明 在 jQuery 中，on('click', ...) 和 click(...) 方法都用於處理點擊事件，它們是等價的。你可以選擇使用其中之一，根據你的喜好和程式碼風格。 在原生 JavaScript 中，我們使用 addEventListener(&quot;click&quot;, ...) 來處理點擊事件。同樣，你可以根據個人偏好選擇不同的方法。 這些範例展示了如何使用 jQuery 和原生 JavaScript 實現不同滑鼠事件以及處理未知事件。同時，它們還強調了 on('click', ...) 和 click(...) 方法之間的等價性。 Traversal選擇器的進階 Traversal - 鄰居、爸爸與小孩效果說明 學習如何使用 Traversal 選擇器獲取元素的鄰居、父元素和子元素。 使用 jQuery 實現12345678// 選擇 ID 為 &quot;myElement&quot; 的元素的下一個兄弟元素var nextSibling = $(&quot;#myElement&quot;).next();// 選擇 ID 為 &quot;myElement&quot; 的元素的父元素var parentElement = $(&quot;#myElement&quot;).parent();// 選擇 ID 為 &quot;myElement&quot; 的元素的所有子元素var childElements = $(&quot;#myElement&quot;).children(); 使用 jQuery，我們可以使用 .next() 選擇下一個兄弟元素，使用 .parent() 選擇父元素，使用 .children() 選擇所有子元素。 使用原生 JavaScript，我們使用 .nextElementSibling 屬性選擇下一個兄弟元素，使用 .parentElement 屬性選擇父元素，使用 .children 屬性選擇所有子元素。 使用原生 JavaScript 實現以下是如何使用原生 JavaScript 將 jQuery 程式碼進行重寫 123456789// 選擇 ID 為 &quot;myElement&quot; 的元素的下一個兄弟元素var myElement = document.getElementById(&quot;myElement&quot;);var nextSibling = myElement.nextElementSibling;// 選擇 ID 為 &quot;myElement&quot; 的元素的父元素var parentElement = myElement.parentElement;// 選擇 ID 為 &quot;myElement&quot; 的元素的所有子元素var childElements = Array.from(myElement.children); 詳細說明 選擇 ID 為 “myElement” 的元素的下一個兄弟元素 我們首先使用 document.getElementById(&quot;myElement&quot;) 來選擇具有 ID 為 “myElement” 的元素，將其存儲在 myElement 變數中。 然後，使用 myElement.nextElementSibling 可以獲取 myElement 元素的下一個兄弟元素，實現了與 $(&quot;#myElement&quot;).next() 類似的效果。 選擇 ID 為 “myElement” 的元素的父元素 我們直接使用 myElement.parentElement 可以獲取 myElement 元素的父元素，實現了與 $(&quot;#myElement&quot;).parent() 類似的效果。 選擇 ID 為 “myElement” 的元素的所有子元素 我們首先使用 document.getElementById(&quot;myElement&quot;) 來選擇具有 ID 為 “myElement” 的元素，將其存儲在 myElement 變數中。 然後，使用 myElement.children 可以獲取 myElement 元素的所有子元素，但它返回的是一個 HTMLCollection，我們使用 Array.from() 將其轉換為數組，這樣就實現了與 $(&quot;#myElement&quot;).children() 類似的效果。 jQuery 中怎麼找爸爸，怎麼找孩子效果說明 學習如何使用 jQuery 找到元素的父元素和子元素。 使用 jQuery 實現12345// 使用 .parent() 找到元素的父元素var parentElement = $(&quot;#myElement&quot;).parent();// 使用 .children() 找到元素的所有子元素var childElements = $(&quot;#myElement&quot;).children(); 使用原生 JavaScript 實現以下是如何使用原生 JavaScript 將 jQuery 程式碼進行重寫 1234567// 使用 .parent() 找到元素的父元素var myElement = document.getElementById(&quot;myElement&quot;);var parentElement = myElement.parentElement;// 使用 .children() 找到元素的所有子元素var childElements = Array.from(myElement.children); 詳細說明 使用 .parent() 找到元素的父元素 我們首先使用 document.getElementById(&quot;myElement&quot;) 來選擇具有 ID 為 “myElement” 的元素，將其存儲在 myElement 變數中。 然後，使用 myElement.parentElement 可以獲取 myElement 元素的父元素，實現了與 $(&quot;#myElement&quot;).parent() 類似的效果。 使用 .children() 找到元素的所有子元素 我們首先使用 document.getElementById(&quot;myElement&quot;) 來選擇具有 ID 為 “myElement” 的元素，將其存儲在 myElement 變數中。 然後，使用 myElement.children 可以獲取 myElement 元素的所有子元素，但它返回的是一個 HTMLCollection，我們使用 Array.from() 將其轉換為數組，這樣就實現了與 $(&quot;#myElement&quot;).children() 類似的效果。 parant(), parents(), parentsUntil() 的差異效果說明我們將探討 jQuery 中的 parent()、parents() 和 parentsUntil() 這三個方法之間的差別以及它們的使用情況。 使用 jQuery 實現 使用 parent() 方法選擇元素的直接父元素。 使用 parents() 方法選擇元素的所有祖先元素。 使用 parentsUntil() 方法選擇元素的祖先元素，直到特定的祖先元素為止。 12345678// 使用 parent() 選擇元素的直接父元素var directParent = $(&quot;#myElement&quot;).parent();// 使用 parents() 選擇元素的所有祖先元素var allAncestors = $(&quot;#myElement&quot;).parents();// 使用 parentsUntil() 選擇元素的祖先元素，直到特定祖先元素為止var ancestorsUntil = $(&quot;#myElement&quot;).parentsUntil(&quot;#container&quot;); 使用原生 JavaScript 實現我們將使用原生 JavaScript 來模擬這三個 jQuery 方法的功能。 123456789101112131415161718192021// 使用原生 JavaScript 實現 parent() 方法選擇元素的直接父元素var directParent = document.getElementById(&quot;myElement&quot;).parentNode;// 使用原生 JavaScript 實現 parents() 方法選擇元素的所有祖先元素var allAncestors = [];var currentNode = document.getElementById(&quot;myElement&quot;).parentNode;while (currentNode) { allAncestors.push(currentNode); currentNode = currentNode.parentNode;}// 使用原生 JavaScript 實現 parentsUntil() 方法選擇元素的祖先元素，直到特定的祖先元素為止var containerElement = document.getElementById(&quot;container&quot;);var ancestorsUntil = [];currentNode = document.getElementById(&quot;myElement&quot;).parentNode;while (currentNode &amp;&amp; currentNode !== containerElement) { ancestorsUntil.push(currentNode); currentNode = currentNode.parentNode;} 詳細說明 parent() 方法選擇元素的直接父元素，它返回一個包含一個元素的 jQuery 對象。 parents() 方法選擇元素的所有祖先元素，它返回一個包含所有祖先元素的 jQuery 對象。 parentsUntil() 方法選擇元素的祖先元素，直到特定的祖先元素為止，它返回一個包含符合條件的祖先元素的 jQuery 對象。 在原生 JavaScript 中，我們使用 parentNode 屬性來獲取元素的父元素，並使用循環來模擬 parents() 和 parentsUntil() 方法的功能。 parentsUntil() 方法需要額外的條件檢查來確保選擇的祖先元素在特定的祖先元素之前停止。 Traversal: first(), last(), find()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來執行三個不同的選擇操作：first()、last() 和 find()。 使用 jQuery 實現使用 jQuery，我們可以輕鬆實現這些選擇操作： 12345678// 使用 first() 選取第一個匹配的元素var firstElement = $(&quot;p&quot;).first();// 使用 last() 選取最後一個匹配的元素var lastElement = $(&quot;p&quot;).last();// 使用 find() 選取子元素中匹配的元素var foundElements = $(&quot;div&quot;).find(&quot;.child&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 12345678910// 使用 first() 選取第一個匹配的元素var firstElement = document.querySelector(&quot;p&quot;);// 使用 last() 選取最後一個匹配的元素var allParagraphs = document.querySelectorAll(&quot;p&quot;);var lastElement = allParagraphs[allParagraphs.length - 1];// 使用 find() 選取子元素中匹配的元素var parentElement = document.querySelector(&quot;div&quot;);var foundElements = parentElement.querySelectorAll(&quot;.child&quot;); 詳細說明 使用 jQuery 的 first() 方法可以輕鬆地選取第一個匹配的元素。它返回一個 jQuery 對象，可以進一步處理。 同樣地，last() 方法用於選取最後一個匹配的元素。 find() 方法可用於在選定的元素內查找所有匹配的子元素。在這個案例中，我們使用它來在 div 元素中查找所有具有 .child 類的子元素。 在原生 JavaScript 中，我們使用 querySelector() 方法來選取第一個匹配的元素，使用 querySelectorAll() 方法來選取所有匹配的元素。通過簡單的索引操作，我們可以獲取最後一個元素。對於 find() 的操作，我們首先選擇父元素，然後使用 querySelectorAll() 來選擇所有子元素，再進行過濾。這些方法可以讓你以原生 JavaScript 方式實現與 jQuery 相同的選擇操作。 Traversal: eq(), filter(), not()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來執行三個不同的選擇操作：eq()、filter() 和 not()。 使用 jQuery 實現使用 jQuery，我們可以輕鬆實現這些選擇操作： 12345678// 使用 eq() 選取特定索引位置的元素var specificElement = $(&quot;p&quot;).eq(2); // 選取第三個 &lt;p&gt; 元素（索引從 0 開始）// 使用 filter() 選取符合特定條件的元素var filteredElements = $(&quot;div&quot;).filter(&quot;.special&quot;); // 選取具有 .special 類的 &lt;div&gt; 元素// 使用 not() 選取不符合特定條件的元素var notElements = $(&quot;p&quot;).not(&quot;.exclude&quot;); // 選取不具有 .exclude 類的 &lt;p&gt; 元素 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456789101112131415// 使用 eq() 選取特定索引位置的元素var allParagraphs = document.querySelectorAll(&quot;p&quot;);var specificElement = allParagraphs[2]; // 選取第三個 &lt;p&gt; 元素（索引從 0 開始）// 使用 filter() 選取符合特定條件的元素var allDivs = document.querySelectorAll(&quot;div&quot;);var filteredElements = Array.from(allDivs).filter(function(element) { return element.classList.contains(&quot;special&quot;);});// 使用 not() 選取不符合特定條件的元素var allParagraphs = document.querySelectorAll(&quot;p&quot;);var notElements = Array.from(allParagraphs).filter(function(element) { return !element.classList.contains(&quot;exclude&quot;);}); 詳細說明 使用 jQuery 的 eq() 方法可以輕鬆地選取特定索引位置的元素。注意，索引從 0 開始，所以 eq(2) 選取的是第三個元素。 filter() 方法用於選取符合特定條件的元素，並返回一個新的 jQuery 對象。在原生 JavaScript 中，我們需要使用 querySelectorAll() 來選取所有元素，然後使用 filter() 方法對元素進行過濾，最後轉換成陣列進行處理。 not() 方法用於選取不符合特定條件的元素，並返回一個新的 jQuery 對象。在原生 JavaScript 中，我們使用 querySelectorAll() 來選取所有元素，然後使用 filter() 方法對元素進行過濾，這次選取不符合特定條件的元素。這些方法可以讓你以原生 JavaScript 方式實現與 jQuery 相同的選擇操作。 特效類特效類 API: hide() 與 show()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來執行元素的隱藏 hide() 和顯示 show() 操作。 使用 jQuery 實現使用 jQuery，我們可以輕鬆實現隱藏和顯示元素的效果： 123456789// 隱藏元素$(&quot;button#hide-button&quot;).click(function(){ $(&quot;p&quot;).hide(); // 將所有 &lt;p&gt; 元素隱藏});// 顯示元素$(&quot;button#show-button&quot;).click(function(){ $(&quot;p&quot;).show(); // 顯示所有 &lt;p&gt; 元素}); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456789101112131415// 隱藏元素document.querySelector(&quot;button#hide-button&quot;).addEventListener(&quot;click&quot;, function(){ var paragraphs = document.querySelectorAll(&quot;p&quot;); for (var i = 0; i &lt; paragraphs.length; i++) { paragraphs[i].style.display = &quot;none&quot;; }});// 顯示元素document.querySelector(&quot;button#show-button&quot;).addEventListener(&quot;click&quot;, function(){ var paragraphs = document.querySelectorAll(&quot;p&quot;); for (var i = 0; i &lt; paragraphs.length; i++) { paragraphs[i].style.display = &quot;block&quot;; }}); 詳細說明 使用 jQuery 的 hide() 方法可以隱藏選定的元素，而 show() 方法則用於顯示它們。這些方法可以輕鬆地在單擊按鈕等事件觸發時實現元素的隱藏和顯示。 在原生 JavaScript 中，我們首先使用 querySelector() 方法來選取按鈕元素，然後使用 addEventListener() 方法來添加點擊事件的監聽器。當按鈕被點擊時，我們使用 querySelectorAll() 來選取所有需要隱藏或顯示的元素，然後使用遍歷的方式設置它們的 style.display 屬性，來達到隱藏或顯示的效果。這樣就實現了與 jQuery 中 hide() 和 show() 方法相同的效果。 Callback 回調函式效果說明我們想要實現在 DOM 操作中使用回調函式 (callback function) 的效果。這將允許我們在元素被操作後執行其他操作，例如在元素淡出 (fade out) 後執行某些程式碼。 使用 jQuery 實現使用 jQuery，我們可以使用回調函式 (callback function) 來實現這一效果： 1234567// 使用回調函式實現淡出效果$(&quot;button#fade-out-button&quot;).click(function(){ $(&quot;p&quot;).fadeOut(&quot;slow&quot;, function(){ // 在淡出完成後執行的程式碼 alert(&quot;段落已經淡出了！&quot;); });}); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456789101112131415161718192021222324252627282930// 使用回調函式實現淡出效果document.querySelector(&quot;button#fade-out-button&quot;).addEventListener(&quot;click&quot;, function(){ var paragraphs = document.querySelectorAll(&quot;p&quot;); var fadeDuration = 1000; // 淡出時間，以毫秒為單位 var interval = 50; // 更新間隔，以毫秒為單位 var fadeOut = function(element, callback) { var opacity = 1; var timer = setInterval(function(){ if (opacity &lt;= 0) { clearInterval(timer); element.style.display = &quot;none&quot;; // 隱藏元素 if (typeof callback === &quot;function&quot;) { callback(); // 執行回調函式 } } else { opacity -= 50 / fadeDuration; // 更新不透明度 element.style.opacity = opacity; } }, interval); }; // 淡出所有段落 for (var i = 0; i &lt; paragraphs.length; i++) { fadeOut(paragraphs[i], function(){ // 在淡出完成後執行的程式碼 alert(&quot;段落已經淡出了！&quot;); }); }}); 詳細說明 在 jQuery 中，我們可以使用 fadeOut() 方法來實現淡出效果，並在函式的第二個參數中傳遞回調函式 (callback function)。回調函式將在淡出效果完成後執行。 在原生 JavaScript 中，我們首先選取按鈕元素，然後使用 addEventListener() 方法添加點擊事件的監聽器。當按鈕被點擊時，我們遍歷所有段落元素，並使用 fadeOut() 函式實現淡出效果。該函式使用 setInterval() 定期更新元素的不透明度，直到不透明度達到 0 為止，然後執行回調函式以觸發在淡出完成後執行的程式碼。這樣就實現了與 jQuery 中 fadeOut() 方法相同的效果，包括回調函式的功能。 方法鏈 (Method Chaining)效果說明我們想要實現在 DOM 操作中使用方法鏈 (Method Chaining) 的效果，這將允許我們連續對多個元素進行操作，而不必多次選擇它們。 使用 jQuery 實現使用 jQuery，方法鏈 (Method Chaining) 是一種方便的方法，可以將多個操作連接在一起： 12345// 使用方法鏈來設置多個屬性$(&quot;p&quot;) .css(&quot;color&quot;, &quot;red&quot;) .addClass(&quot;highlight&quot;) .fadeOut(&quot;slow&quot;); 使用原生 JavaScript 實現在原生 JavaScript 中，方法鏈 (Method Chaining) 需要更多的工作，但也是可行的： 1234567891011121314151617181920212223// 使用原生 JavaScript 實現方法鏈var paragraphs = document.querySelectorAll(&quot;p&quot;);for (var i = 0; i &lt; paragraphs.length; i++) { paragraphs[i].style.color = &quot;red&quot;; paragraphs[i].classList.add(&quot;highlight&quot;); fadeOut(paragraphs[i]);}// 淡出函式function fadeOut(element) { var opacity = 1; var interval = 50; // 更新間隔，以毫秒為單位 var fadeDuration = 1000; // 淡出時間，以毫秒為單位 var timer = setInterval(function(){ if (opacity &lt;= 0) { clearInterval(timer); } else { opacity -= 50 / fadeDuration; // 更新不透明度 element.style.opacity = opacity; } }, interval);} 詳細說明 在 jQuery 中，方法鏈 (Method Chaining) 非常容易實現。只需將多個方法連接起來，每個方法返回的是 jQuery 對象，允許對同一組元素進行連續操作。 在原生 JavaScript 中，實現方法鏈需要手動對每個元素進行操作，並根據需要連續調用不同的函式。在上面的例子中，我們遍歷了所有的段落元素，設置它們的顏色、添加類名、以及調用 fadeOut() 函式來執行淡出效果。這樣可以實現與 jQuery 中方法鏈相似的效果，但需要更多的程式碼來達到同樣的目標。 特效類動畫: 使用 animate()效果說明我們想要實現在 DOM 中使用動畫效果，使元素以動畫方式改變位置或屬性。具體而言，我們希望將一個元素從左側移動到右側。 使用 jQuery 實現使用 jQuery，我們可以使用 animate() 方法來實現這種簡單的動畫效果： 123456// 使用 animate() 實現元素移動$(&quot;button#animate-button&quot;).click(function(){ $(&quot;div#animated-box&quot;).animate({ left: &quot;200px&quot; // 將 left 屬性從 0px 改變為 200px }, 1000); // 動畫持續 1 秒}); 使用原生 JavaScript 實現在原生 JavaScript 中，實現動畫效果需要更多的程式碼和計時器： 12345678910111213141516171819202122// 使用原生 JavaScript 實現元素移動document.querySelector(&quot;button#animate-button&quot;).addEventListener(&quot;click&quot;, function(){ var animatedBox = document.querySelector(&quot;div#animated-box&quot;); var startPosition = 0; var endPosition = 200; var duration = 1000; // 動畫持續 1 秒 var interval = 10; // 更新間隔，以毫秒為單位 var distance = endPosition - startPosition; var steps = duration / interval; var stepSize = distance / steps; var currentStep = 0; var timer = setInterval(function(){ if (currentStep&gt;= steps) { clearInterval(timer); } else { startPosition += stepSize; animatedBox.style.left = startPosition + &quot;px&quot;; currentStep++; } }, interval);}); 詳細說明 在 jQuery 中，我們使用 animate() 方法來實現動畫效果。該方法接受一個對象，其中包含要改變的屬性和相應的目標值。在這個例子中，我們改變 left 屬性，使元素從 0px 移動到 200px，動畫持續 1 秒。 在原生 JavaScript 中，實現動畫效果需要使用計時器。我們計算出每一步的變化量，然後使用 setInterval() 定期更新元素的位置，直到達到目標位置為止。這樣就實現了類似於 jQuery 中 animate() 方法的動畫效果，但需要更多的程式碼和計算。 淡入和淡出效果: 使用 fadeIn() 和 fadeOut()效果說明我們想實現在 DOM 中使用淡入 (fadeIn()) 和淡出 (fadeOut()) 效果，以使元素以漸變的方式顯示和隱藏。 使用 jQuery 實現使用 jQuery，我們可以使用 fadeIn() 和 fadeOut() 方法來實現淡入和淡出效果： 123456789// 使用 fadeIn() 實現淡入效果$(&quot;button#fade-in-button&quot;).click(function(){ $(&quot;div#fading-box&quot;).fadeIn(&quot;slow&quot;); // 慢速淡入});// 使用 fadeOut() 實現淡出效果$(&quot;button#fade-out-button&quot;).click(function(){ $(&quot;div#fading-box&quot;).fadeOut(&quot;slow&quot;); // 慢速淡出}); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456789101112131415161718192021222324252627282930313233343536// 使用原生 JavaScript 實現淡入效果document.querySelector(&quot;button#fade-in-button&quot;).addEventListener(&quot;click&quot;, function(){ var fadingBox = document.querySelector(&quot;div#fading-box&quot;); var opacity = 0; var interval = 50; // 更新間隔，以毫秒為單位 var fadeDuration = 1000; // 淡入時間，以毫秒為單位 var timer = setInterval(function(){ if (opacity&gt;= 1) { clearInterval(timer); } else { opacity += 50 / fadeDuration; // 更新不透明度 fadingBox.style.opacity = opacity; } }, interval); fadingBox.style.display = &quot;block&quot;; // 顯示元素});// 使用原生 JavaScript 實現淡出效果document.querySelector(&quot;button#fade-out-button&quot;).addEventListener(&quot;click&quot;, function(){ var fadingBox = document.querySelector(&quot;div#fading-box&quot;); var opacity = 1; var interval = 50; // 更新間隔，以毫秒為單位 var fadeDuration = 1000; // 淡出時間，以毫秒為單位 var timer = setInterval(function(){ if (opacity &lt;= 0) { clearInterval(timer); fadingBox.style.display = &quot;none&quot;; // 隱藏元素 } else { opacity -= 50 / fadeDuration; // 更新不透明度 fadingBox.style.opacity = opacity; } }, interval);}); 詳細說明 在 jQuery 中，我們使用 fadeIn() 方法實現淡入效果，而使用 fadeOut() 方法實現淡出效果。可以指定動畫的速度，例如 “slow” 代表慢速。這些方法會自動處理不透明度和顯示 / 隱藏的細節，使元素以漸變的方式顯示和隱藏。 在原生 JavaScript 中，我們使用計時器和不透明度屬性來實現淡入和淡出效果。計時器定期更新元素的不透明度，從而實現漸變效果。在淡出完成後，我們使用 style.display 來控制元素的顯示狀態。這樣可以實現與 jQuery 中 fadeIn() 和 fadeOut() 方法相似的效果，但需要更多的程式碼和計算。 「取得」與「覆寫」值屬性操作: 使用 attr()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來取得或改變元素的屬性。 使用 jQuery 實現使用 jQuery，我們可以使用 attr() 方法來取得或改變元素的屬性： 12345// 取得元素的屬性值var linkHref = $(&quot;a#my-link&quot;).attr(&quot;href&quot;);// 改變元素的屬性值$(&quot;img#my-image&quot;).attr(&quot;src&quot;, &quot;new-image.jpg&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 1234567// 取得元素的屬性值var linkElement = document.querySelector(&quot;a#my-link&quot;);var linkHref = linkElement.getAttribute(&quot;href&quot;);// 改變元素的屬性值var imageElement = document.querySelector(&quot;img#my-image&quot;);imageElement.setAttribute(&quot;src&quot;, &quot;new-image.jpg&quot;); 詳細說明 在 jQuery 中，我們使用 attr() 方法來取得元素的屬性值或改變元素的屬性。第一個參數是要操作的屬性名稱，第二個參數是要設置的新值（如果是改變屬性的話）。 在原生 JavaScript 中，我們使用 getAttribute() 方法來取得元素的屬性值，並使用 setAttribute() 方法來改變元素的屬性。注意，原生 JavaScript 中需要明確指定要取得或改變的屬性名稱，而在 jQuery 中，屬性名稱作為參數傳遞給 attr() 方法。這樣可以實現相同的效果，但語法略有不同。 操作 DOM 內容: 使用 html()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來取得或修改元素的 HTML 內容。 使用 jQuery 實現使用 jQuery，我們可以使用 html() 方法來取得或修改元素的 HTML 內容： 12345// 取得元素的 HTML 內容var content = $(&quot;div#my-div&quot;).html();// 修改元素的 HTML 內容$(&quot;div#my-div&quot;).html(&quot;&lt;p&gt;New Content&lt;/p&gt;&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456// 取得元素的 HTML 內容var divElement = document.querySelector(&quot;div#my-div&quot;);var content = divElement.innerHTML;// 修改元素的 HTML 內容divElement.innerHTML = &quot;&lt;p&gt;New Content&lt;/p&gt;&quot;; 詳細說明 在 jQuery 中，我們使用 html() 方法來取得元素的 HTML 內容或設置新的 HTML 內容。如果不傳遞參數，它將返回元素的 HTML 內容；如果傳遞參數，則將設置元素的 HTML 內容為指定的值。 在原生 JavaScript 中，我們使用 innerHTML 屬性來取得元素的 HTML 內容或設置新的 HTML 內容。如果要取得 HTML 內容，只需獲取該屬性的值；如果要設置 HTML 內容，只需將新的 HTML 字符串賦值給該屬性。這樣可以實現相同的效果，但語法略有不同。 表單操作: 使用 val()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來取得或修改表單 (form) 元素的值。 使用 jQuery 實現使用 jQuery，我們可以使用 val() 方法來取得或修改表單元素的值： 12345// 取得表單輸入框的值var inputValue = $(&quot;input#my-input&quot;).val();// 修改表單輸入框的值$(&quot;input#my-input&quot;).val(&quot;新的值&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456// 取得表單輸入框的值var inputElement = document.querySelector(&quot;input#my-input&quot;);var inputValue = inputElement.value;// 修改表單輸入框的值inputElement.value = &quot;新的值&quot;; 詳細說明 在 jQuery 中，我們使用 val() 方法來取得表單元素的值或設置新的值。如果不傳遞參數，它將返回表單元素的值；如果傳遞參數，則將設置表單元素的值為指定的值。 在原生 JavaScript 中，我們使用 value 屬性來取得表單元素的值或設置新的值。如果要取得值，只需獲取該屬性的值；如果要設置值，只需將新的值賦值給該屬性。這樣可以實現相同的效果，但語法略有不同。 操作元素文字內容: 使用 text()效果說明我們想要實現在 DOM 中使用 jQuery 或原生 JavaScript 來取得元素的文字內容。 使用 jQuery 實現使用 jQuery，我們可以使用 text() 方法來取得元素的文字內容： 12// 取得元素的文字內容var textContent = $(&quot;p#my-paragraph&quot;).text(); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123// 取得元素的文字內容var paragraphElement = document.querySelector(&quot;p#my-paragraph&quot;);var textContent = paragraphElement.textContent; 詳細說明 在 jQuery 中，我們使用 text() 方法來取得元素的文字內容。這個方法返回元素包含的文字，不包含 HTML 標記。 在原生 JavaScript 中，我們使用 textContent 屬性來取得元素的文字內容。這個屬性也只包含文字，不包含 HTML 標記。兩種方法都可以實現取得元素的文字內容，具體選擇哪種取決於你的需求和程式碼風格。 DOM 的操作在容器內插入內容: 使用 before() 和 after()效果說明我們想要在 DOM 中使用 jQuery 或原生 JavaScript 來在特定容器內的元素前面或後面插入新的內容。 使用 jQuery 實現使用 jQuery，我們可以使用 before() 和 after() 方法來在元素前面或後面插入內容： 12345// 在元素前面插入內容$(&quot;p#my-paragraph&quot;).before(&quot;&lt;p&gt;New content before&lt;/p&gt;&quot;);// 在元素後面插入內容$(&quot;p#my-paragraph&quot;).after(&quot;&lt;p&gt;New content after&lt;/p&gt;&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 12345678910// 在元素前面插入內容var paragraphElement = document.querySelector(&quot;p#my-paragraph&quot;);var newElementBefore = document.createElement(&quot;p&quot;);newElementBefore.textContent = &quot;New content before&quot;;paragraphElement.parentNode.insertBefore(newElementBefore, paragraphElement);// 在元素後面插入內容var newElementAfter = document.createElement(&quot;p&quot;);newElementAfter.textContent = &quot;New content after&quot;;paragraphElement.parentNode.insertBefore(newElementAfter, paragraphElement.nextSibling); 詳細說明 在 jQuery 中，我們使用 before() 方法來在元素前面插入新的內容，使用 after() 方法來在元素後面插入新的內容。我們只需將要插入的 HTML 程式碼作為參數傳遞給這些方法即可。 在原生 JavaScript 中，我們首先選擇要插入內容的元素，然後使用 createElement() 方法來建立一個新的元素，設置其內容，然後使用 parentNode.insertBefore() 方法來將新元素插入到指定元素前面或後面。要在元素後面插入，我們使用元素的 nextSibling 屬性來確定插入位置。這樣可以實現與 jQuery 中 before() 和 after() 方法相似的效果，但需要更多的程式碼。 修改 DOM 結構: 使用 append() 和 prepend()效果說明我們想要在 DOM 中使用 jQuery 或原生 JavaScript 來向容器元素添加新的子元素，可以選擇將其追加到容器的末尾或插入到容器的開頭。 使用 jQuery 實現使用 jQuery，我們可以使用 append() 方法將新的子元素追加到容器的末尾，使用 prepend() 方法將新的子元素插入到容器的開頭： 12345// 將新的子元素追加到容器末尾$(&quot;div#my-container&quot;).append(&quot;&lt;p&gt;New content at the end&lt;/p&gt;&quot;);// 將新的子元素插入到容器開頭$(&quot;div#my-container&quot;).prepend(&quot;&lt;p&gt;New content at the beginning&lt;/p&gt;&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 12345678910// 將新的子元素追加到容器末尾var containerElement = document.querySelector(&quot;div#my-container&quot;);var newElementEnd = document.createElement(&quot;p&quot;);newElementEnd.textContent = &quot;New content at the end&quot;;containerElement.appendChild(newElementEnd);// 將新的子元素插入到容器開頭var newElementStart = document.createElement(&quot;p&quot;);newElementStart.textContent = &quot;New content at the beginning&quot;;containerElement.insertBefore(newElementStart, containerElement.firstChild); 詳細說明 在 jQuery 中，我們使用 append() 方法將新的子元素追加到容器的末尾，使用 prepend() 方法將新的子元素插入到容器的開頭。我們只需將要插入的 HTML 程式碼作為參數傳遞給這些方法。 在原生 JavaScript 中，我們首先選擇容器元素，然後使用 createElement() 方法來建立新的子元素，設置其內容，然後使用 appendChild() 方法將新元素追加到容器末尾。要將新元素插入到開頭，我們使用 insertBefore() 方法，將新元素插入到容器的第一個子元素之前。這樣可以實現與 jQuery 中 append() 和 prepend() 方法相似的效果，但需要更多的程式碼。 清空內容和移除元素: 使用 empty() 和 remove()效果說明我們想要在 DOM 中使用 jQuery 或原生 JavaScript 來清空元素的內容或將元素從 DOM 中移除。 使用 jQuery 實現使用 jQuery，我們可以使用 empty() 方法來清空元素的內容，使用 remove() 方法將元素從 DOM 中移除： 12345// 清空元素的內容$(&quot;div#my-element&quot;).empty();// 將元素從 DOM 中移除$(&quot;div#my-element&quot;).remove(); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 1234567// 清空元素的內容var elementToEmpty = document.querySelector(&quot;div#my-element&quot;);elementToEmpty.innerHTML = &quot;&quot;;// 將元素從 DOM 中移除var elementToRemove = document.querySelector(&quot;div#my-element&quot;);elementToRemove.parentNode.removeChild(elementToRemove); 注意事項 使用 empty() 方法僅清空元素的內容，但保留元素本身。使用 remove() 方法將元素從 DOM 中永久移除。 在使用 remove() 方法時，被移除的元素將無法再次使用，並且無法通過 JavaScript 對其進行操作。請謹慎使用 remove()，特別是對於需要保留的元素。 刪除元素屬性: 使用 removeAttr()效果說明我們想要在 DOM 中使用 jQuery 或原生 JavaScript 來刪除元素的特定屬性。 使用 jQuery 實現使用 jQuery，我們可以使用 removeAttr() 方法來刪除元素的屬性： 12// 刪除元素的特定屬性$(&quot;img#my-image&quot;).removeAttr(&quot;alt&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123// 刪除元素的特定屬性var imageElement = document.querySelector(&quot;img#my-image&quot;);imageElement.removeAttribute(&quot;alt&quot;); 詳細說明 在 jQuery 中，我們使用 removeAttr() 方法來刪除元素的特定屬性。只需將要刪除的屬性名稱作為參數傳遞給該方法即可。 在原生 JavaScript 中，我們使用 removeAttribute() 方法來刪除元素的特定屬性。同樣，只需將要刪除的屬性名稱作為參數傳遞給該方法即可。這兩種方法都可以實現刪除元素屬性的效果，具體選擇哪種取決於你的需求和程式碼風格。 在容器中插入內容: 使用 append() 和 prepend()效果說明我們想要在 DOM 中使用 jQuery 或原生 JavaScript 來向容器元素添加新的子元素，可以選擇將其追加到容器的末尾或插入到容器的開頭。 使用 jQuery 實現使用 jQuery，我們可以使用 append() 方法將新的子元素追加到容器的末尾，使用 prepend() 方法將新的子元素插入到容器的開頭： 12345// 將新的子元素追加到容器末尾$(&quot;div#my-container&quot;).append(&quot;&lt;p&gt;New content at the end&lt;/p&gt;&quot;);// 將新的子元素插入到容器開頭$(&quot;div#my-container&quot;).prepend(&quot;&lt;p&gt;New content at the beginning&lt;/p&gt;&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 12345678910// 將新的子元素追加到容器末尾var containerElement = document.querySelector(&quot;div#my-container&quot;);var newElementEnd = document.createElement(&quot;p&quot;);newElementEnd.textContent = &quot;New content at the end&quot;;containerElement.appendChild(newElementEnd);// 將新的子元素插入到容器開頭var newElementStart = document.createElement(&quot;p&quot;);newElementStart.textContent = &quot;New content at the beginning&quot;;containerElement.insertBefore(newElementStart, containerElement.firstChild); 詳細說明 在 jQuery 中，我們使用 append() 方法將新的子元素追加到容器的末尾，使用 prepend() 方法將新的子元素插入到容器的開頭。我們只需將要插入的 HTML 程式碼作為參數傳遞給這些方法。 在原生 JavaScript 中，我們首先選擇容器元素，然後使用 createElement() 方法來建立新的子元素，設置其內容，然後使用 appendChild() 方法將新元素追加到容器末尾。要將新元素插入到開頭，我們使用 insertBefore() 方法，將新元素插入到容器的第一個子元素之前。這樣可以實現與 jQuery 中 append() 和 prepend() 方法相似的效果，但需要更多的程式碼。 包覆元素: 使用 wrap()效果說明我們想要在 DOM 中使用 jQuery 或原生 JavaScript 來包覆一個元素，將其放入新的容器中。 使用 jQuery 實現使用 jQuery，我們可以使用 wrap() 方法將元素包覆在新的容器內： 12// 包覆元素$(&quot;p#my-paragraph&quot;).wrap(&quot;&lt;div class='wrapper'&gt;&lt;/div&gt;&quot;); 使用原生 JavaScript 實現如果要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456// 包覆元素var paragraphElement = document.querySelector(&quot;p#my-paragraph&quot;);var wrapperElement = document.createElement(&quot;div&quot;);wrapperElement.className = &quot;wrapper&quot;;paragraphElement.parentNode.insertBefore(wrapperElement, paragraphElement);wrapperElement.appendChild(paragraphElement); 詳細說明 在 jQuery 中，我們使用 wrap() 方法來將元素包覆在指定的 HTML 元素內。我們只需將要包覆的 HTML 程式碼作為參數傳遞給該方法。 在原生 JavaScript 中，我們首先選擇要包覆的元素和新容器元素，然後使用 createElement() 方法來建立新的容器元素，設置其類名等屬性，然後使用 insertBefore() 方法將新容器插入到原始元素的前面，最後使用 appendChild() 方法將原始元素移動到新容器內。這樣可以實現與 jQuery 中 wrap() 方法相似的效果，但需要更多的程式碼。包覆元素通常不是經常使用的操作，所以較少用到。 用 CSS 的類別來控制視覺: 使用 addClass() 和 removeClass()效果說明我們想要了解如何使用 jQuery 的 addClass() 和 removeClass() 方法來添加或移除元素的 CSS 類別，從而控制其視覺樣式。 使用 jQuery 實現使用 jQuery，我們可以使用 addClass() 方法來添加一個或多個 CSS 類別到元素，使用 removeClass() 方法來從元素中移除一個或多個 CSS 類別： 12345// 添加 CSS 類別到元素$(&quot;p#my-paragraph&quot;).addClass(&quot;highlight&quot;);// 移除 CSS 類別從元素$(&quot;p#my-paragraph&quot;).removeClass(&quot;highlight&quot;); 使用原生 JavaScript 實現要使用原生 JavaScript 來實現相同的效果，可以這樣做： 123456// 添加 CSS 類別到元素var paragraphElement = document.querySelector(&quot;p#my-paragraph&quot;);paragraphElement.classList.add(&quot;highlight&quot;);// 移除 CSS 類別從元素paragraphElement.classList.remove(&quot;highlight&quot;); 詳細說明 使用 jQuery 的 addClass() 方法可以將一個或多個 CSS 類別添加到元素，從而改變其視覺樣式。使用 removeClass() 方法可以從元素中移除一個或多個 CSS 類別，還原其樣式。 在原生 JavaScript 中，我們使用 classList 屬性來添加或移除 CSS 類別。使用 classList.add() 方法可以添加一個或多個 CSS 類別，使用 classList.remove() 方法可以從元素中移除一個或多個 CSS 類別。這兩種方法可以實現與 jQuery 中 addClass() 和 removeClass() 方法相似的效果，但需要更多的程式碼。控制 CSS 類別是調整元素視覺樣式的重要方法之一。","link":"/mentocamp/jquery2js.html"},{"title":"【 Python x JS 】雙刀流","text":"基本型別文字的世界： 字串 (String)在這裡，我們探討了 Python 和 JavaScript 中的字串（String）型別。字串是程式語言中的基本概念，用於存儲和操作文本資料。雖然 Python 和 JavaScript 在語法上有所不同，但它們對字串的處理方式有許多相似之處。 Python 中的字串 (str) 在 Python 中，字串是由單引號 ('') 或雙引號 (&quot; &quot;) 包圍的一系列字符。 字串是不可變的，這意味著一旦建立，字串的內容就不能被修改。 字串型別在 Python 中用 str 表示。 Python 程式碼範例 123my_str = &quot;Hello, World!&quot;print(my_str) # 輸出: Hello, World!print(type(my_str)) # 輸出: &lt;class 'str'&gt; JavaScript 中的字串 (string) 與 Python 類似，JavaScript 中的字串也是由單引號、雙引號，或反引號（用於模板字串）包圍的字符序列。 JavaScript 的字串同樣是不可變的。 字串型別在 JavaScript 中用 string 表示。 JavaScript 程式碼範例 123let myString = &quot;Hello, World!&quot;;console.log(myString); // 輸出: Hello, World!console.log(typeof myString); // 輸出: 'string' 綜合比較 在 Python 和 JavaScript 中，字串用來表示文本資料。 兩種語言中，字串的操作和處理方法類似，提供了許多內建的方法來檢查、處理和操作字串。 字串在這兩種語言中都是不可變的，一旦建立，其內容就不能被修改。 數字的世界：int、float、Number、BigInt在這個例子中，我們探討了 Python 和 JavaScript 中的數字型別，包括整數 (int), 浮點數 (float), 數字 (Number), 大整數 (BigInt)。每種語言對這些型別的處理方式有所不同。 Python 的數字型別整數 (int) 代表整數，沒有小數部分。 例如：my_int = 10。 浮點數 (float) 代表帶有小數的數字。 例如：my_float = 10.5。 Python 程式碼範例： 1234my_int = 10my_float = 10.5print(my_int, my_float) # 輸出: 10 10.5print(type(my_int), type(my_float)) # 輸出: &lt;class 'int'&gt; &lt;class 'float'&gt; JavaScript 的數字型別數字 (Number)當在 JavaScript 中使用 Number 型別時，可以表示整數和浮點數。JavaScript 不區分整數和浮點數，所有數字都被視為 Number 型別。以下是一些示範： 以下是加上程式碼突顯的版本： 1. 整數 123let integerNumber = 42;console.log(integerNumber); // 42console.log(typeof integerNumber); // 'number' 在這個範例中，我們宣告了一個整數變數 integerNumber，並賦予它值 42。我們使用 console.log 來輸出它的值，結果是 42，同時我們使用 typeof 來確認它的型別，結果是 'number'。 2. 浮點數 123let floatingPointNumber = 3.14;console.log(floatingPointNumber); // 3.14console.log(typeof floatingPointNumber); // 'number' 這裡我們宣告了一個浮點數變數 floatingPointNumber，賦予它值 3.14。同樣地，我們使用 console.log 輸出它的值（3.14），並使用 typeof 確認它的型別為 'number'。 3. 整數和浮點數都是 Number 123let combinedNumber = 100.0;console.log(combinedNumber); // 100console.log(typeof combinedNumber); // 'number' 這個範例中，我們宣告了一個數字變數 combinedNumber，它的值是 100.0。儘管它包含小數點，但 JavaScript 仍然將其視為 'number' 型別。我們輸出了它的值（100）以及型別（'number'）。 4. 數字運算 123let result = integerNumber + floatingPointNumber; // 整數和浮點數相加console.log(result); // 45.14console.log(typeof result); // 'number' 最後，我們執行了一個數字運算，將整數和浮點數相加，並將結果存儲在 result 變數中。結果 result 包含了計算的結果（45.14），同樣它的型別仍然是 'number'。 在上述示範中，我們展示了 JavaScript 中的數字 (Number) 型別的用法。無論是整數還是浮點數，它們都被視為 Number 型別。你可以進行數學運算，包括整數和浮點數之間的運算。 JavaScript 會自動處理型別轉換，使得整數和浮點數之間的運算成為可能。 大整數 (BigInt)當使用 Number 型別來表示太大的數字時，會出現數值精度丟失或溢出的情況。以下是一個示範，展示了使用 Number 表示超出範圍的數字時會出現的問題。 1234567let largeNumber = 1234567890123456789012345678901234567890;console.log(largeNumber); // 正確顯示數字console.log(largeNumber + 1); // 結果不正確，精度丟失console.log(largeNumber - 1234567890); // 結果不正確，精度丟失console.log(largeNumber * 2); // 結果不正確，溢出console.log(largeNumber / 3); // 結果不正確，精度丟失 在這個示範中，largeNumber 是一個非常大的整數，超出了 Number 型別的表示範圍，因此在進行數學運算時會出現精度丟失或溢出的問題。 為了解決這些問題，你可以使用 BigInt 型別，如下所示： 1234567let largeBigInt = 1234567890123456789012345678901234567890n;console.log(largeBigInt); // 正確顯示大整數console.log(largeBigInt + 1n); // 正確計算，不會精度丟失console.log(largeBigInt - 1234567890n); // 正確計算，不會精度丟失console.log(largeBigInt * 2n); // 正確計算，不會溢出console.log(largeBigInt / 3n); // 正確計算，不會精度丟失 使用 BigInt 型別可以保持數值的精確度，並且不會出現溢出或精度丟失的問題，特別適用於處理非常大的整數。 綜合比較 在 Python 中，整數和浮點數是分開的型別，分別由 int 和 float 表示。 在 JavaScript 中，Number 既可以是整數也可以是浮點數，而 BigInt 是一種特殊的型別，用於處理極大的整數。 是非對錯：布林值 (Boolean)布林值就像是開關，只有「開」（True）和「關」（False）兩種狀態。這在 Python 和 JavaScript 中都一樣。 Python 123my_bool = Trueprint(my_bool) # Trueprint(type(my_bool)) # &lt;class 'bool'&gt; JavaScript 123let myBoolean = true;console.log(myBoolean); // trueconsole.log(typeof myBoolean); // 'boolean' 以下是詳細的操作方式： Python 的布林值 (bool)在 Python 中，布林值用 bool 這個資料型別來表示。Python 的布林值有兩個可能的值：True 和 False。以下是範例： 定義布林變數123my_bool = Trueprint(my_bool) # Trueprint(type(my_bool)) # &lt;class 'bool'&gt; 使用布林運算12result = 5 &gt; 3 # 5 大於 3，結果是 Trueprint(result) # True 布林運算123and_result = True and False # and 運算，結果是 Falseor_result = True or False # or 運算，結果是 Truenot_result = not True # not 運算，結果是 False JavaScript 的布林值 (Boolean)在 JavaScript 中，布林值用 Boolean 這個資料型別來表示。JavaScript 的布林值同樣有兩個可能的值：true 和 false。以下是範例： 定義布林變數123let myBoolean = true;console.log(myBoolean); // trueconsole.log(typeof myBoolean); // 'boolean' 使用布林運算12let result = 5 &gt; 3; // 5 大於 3，結果是 trueconsole.log(result); // true 布林運算123let andResult = true &amp;&amp; false; // and 運算，結果是 falselet orResult = true || false; // or 運算，結果是 truelet notResult = !true; // not 運算，結果是 false 布林值通常用於控制流程、判斷條件、邏輯運算和其他需要表示真假的情況。無論是在 Python 還是 JavaScript 中，布林值都是程式中非常重要的資料型別之一。 空空如也：None, null, undefinedPython 中的「None」在 Python 中，None 是一個特殊的型別，用於表示「什麼都沒有」或缺少值的情況。它通常用來初始化變數，或者作為函式的返回值，以表明沒有有效的返回值。 以下是用 Python 程式碼說明這兩個範例的用處： 初始化變數12my_none = Noneprint(my_none) # None 在這個範例中，我們將變數 my_none 設置為 None，這表示這個變數目前沒有任何值或資料。這在程式中的一些情況下很有用，例如當你希望在稍後的程式中為變數指派值，但還不知道初始值是什麼時。使用 None 來初始化變數可以讓你明確地表示變數的未定義狀態。 函式的返回值12345def find_element(arr, target): for element in arr: if element == target: return element return None # 如果找不到目標元素，返回 None 在這個範例中，我們定義了一個名為 find_element 的函式，該函式接受一個陣列 arr 和一個目標值 target 作為參數。函式的用處是在陣列中尋找目標值，如果找到目標值，則返回該值；如果在整個陣列中找不到目標值，則返回 None。這種設計允許函式明確地指示特殊情況，即目標值不存在於陣列中。在呼叫這個函式後，你可以檢查返回值是否為 None，以確定是否找到了目標元素。 總之，None 在這兩個情況下都用於表示缺少值或未定義的情況，以提供程式碼中的明確性和處理特殊情況的能力。 JavaScript 中的「null」和「undefined」在 JavaScript 中，有兩個值用來表示「空」的狀態，分別是 null 和 undefined。 null：這裡什麼都沒有它通常是由程式開發者明確賦值的，用來表示變數目前沒有有效的值。 12let myNull = null;console.log(myNull); // null undefined：變數存在，但尚未定義undefined：表示變數或屬性存在，但尚未賦值，或者尚未被定義。它通常是變數被聲明但未賦值時的默認值。 12let myUndefined;console.log(myUndefined); // undefined 在上述範例中，我們分別展示了 null 和 undefined 的使用方式。它們用來表示不同的情況，但都代表著某種形式的「空」。在不同的程式語言中，有不同的方式來表達「空」或缺少值的狀態，這些方式在特定情況下很有用，可以幫助程式開發者處理不同的情況。 運算子Python 和 JavaScript 運算子的通用寫法基本算術運算子 Python: 12345a = 5 + 3 # 加法，結果為 8b = 5 - 3 # 減法，結果為 2c = 5 * 3 # 乘法，結果為 15d = 5 / 2 # 除法，結果為 2.5e = 5 % 2 # 取餘，結果為 1 這些基本算術運算子在 Python 中與數學中的使用方式相同。你可以使用加法（+）、減法（-）、乘法（*）、除法（/）和取餘（%）來進行數值計算。 JavaScript: 12345let a = 5 + 3; // 加法，結果為 8let b = 5 - 3; // 減法，結果為 2let c = 5 * 3; // 乘法，結果為 15let d = 5 / 2; // 除法，結果為 2.5let e = 5 % 2; // 取餘，結果為 1 在 JavaScript 中，這些基本算術運算子的使用方式與 Python 相似。你可以使用加法（+）、減法（-）、乘法（*）、除法（/）和取餘（%）來執行數值運算。 比較運算子 Python: 1234print(5 &gt; 3) # Trueprint(5 &lt; 3) # Falseprint(5 &gt;= 5) # Trueprint(5 &lt;= 4) # False 在 Python 中，比較運算子（大於、小於、大於等於、小於等於）用於比較數值，並返回布林值（True 或 False）。 JavaScript: 1234console.log(5 &gt; 3); // trueconsole.log(5 &lt; 3); // falseconsole.log(5 &gt;= 5); // trueconsole.log(5 &lt;= 4); // false 在 JavaScript 中，比較運算子的使用方式與 Python 相似。它們也用於比較數值，並返回布林值。 賦值運算子 Python: 12345x = 10 # 賦值x += 5 # x = x + 5x -= 3 # x = x - 3x *= 2 # x = x * 2x /= 4 # x = x / 4 在 Python 中，賦值運算子（+=、-=、*=、/=）用於更新變數的值。它們可以實現簡潔的變數更新操作。 JavaScript: 12345let x = 10; // 賦值x += 5; // x = x + 5x -= 3; // x = x - 3x *= 2; // x = x * 2x /= 4; // x = x / 4 在 JavaScript 中，賦值運算子的使用方式也與 Python 相似。它們用於更新變數的值。 邏輯運算子 Python: 123a = True and False # Falseb = True or False # Truec = not True # False 在 Python 中，邏輯運算子（and、or、not）用於執行布林邏輯操作。它們可以用於組合和改變布林值。 JavaScript: 123let a = true &amp;&amp; false; // falselet b = true || false; // truelet c = !true; // false 在 JavaScript 中，邏輯運算子的使用方式也與 Python 相似。它們用於執行布林邏輯操作。 位元運算子 Python: 123456a = 5 &amp; 3 # 位元 AND，結果為 1b = 5 | 3 # 位元 OR，結果為 7c = 5 ^ 3 # 位元 XOR，結果為 6d = ~5 # 位元非，結果為 -6e = 5 &lt;&lt; 1 # 左移，結果為 10f = 5 &gt;&gt; 1 # 右移，結果為 2 在 Python 中，位元運算子（位元 AND、位元 OR、位元 XOR、位元非、左移、右移）用於執行位元級別的操作。 JavaScript: 123456let a = 5 &amp; 3; // 位元 AND，結果為 1let b = 5 | 3; // 位元 OR，結果為 7let c = 5 ^ 3; // 位元 XOR，結果為 6let d = ~5; // 位元非，結果為 -6let e = 5 &lt;&lt; 1; // 左移，結果為 10let f = 5 &gt;&gt; 1; // 右移，結果為 2 在 JavaScript 中，位元運算子的使用方式也與 Python 相似。它們用於執行位元級別的操作，例如位元 AND、位元 OR 和位元 XOR。 這些範例展示了 Python 和 JavaScript 在基本運算子的使用上的相似之處，讓你更清楚地了解它們之間的相似性和差異。 Python 和 JavaScript 運算子的不同之處嚴格等於運算子 JavaScript: 12console.log(1 == &quot;1&quot;); // true - 僅比較值console.log(1 === &quot;1&quot;); // false - 比較值和類型 在 JavaScript 中，== 運算子比較兩個值，而 === 運算子不僅比較值還比較數據類型。因此，1 == &quot;1&quot; 返回 true，因為它們的值相等，但數據類型不同，而 1 === &quot;1&quot; 返回 false，因為它們的數據類型不同。 整數除法和冪運算 Python: 12a = 10 // 3 # 整數除法，結果為 3b = 2 ** 3 # 冪運算，結果為 8 在 Python 中，// 運算子執行整數除法，返回整數結果。** 運算子用於計算冪，即指數運算。 JavaScript: 12let a = Math.floor(10 / 3); // 整數除法的模擬，結果為 3let b = 2 ** 3; // 冪運算，結果為 8 在 JavaScript 中，沒有專門的整數除法運算子，因此我們使用 Math.floor() 函數來模擬整數除法。** 運算子用於計算冪，與 Python 中的操作相同。 三元運算子 Python: 12condition = Trueresult = &quot;Yes&quot; if condition else &quot;No&quot; 在 Python 中，我們可以使用三元運算子 condition ? value_if_true : value_if_false 來根據條件選擇不同的值。 JavaScript: 12let condition = true;let result = condition ? &quot;Yes&quot; : &quot;No&quot;; 在 JavaScript 中，三元運算子的語法與 Python 相同，用於根據條件選擇不同的值。 邏輯運算子的語法 Python: 123a = True and False # Falseb = True or False # Truec = not True # False 在 Python 中，邏輯運算子（and、or、not）用於執行布林邏輯操作，其語法比較直觀。 JavaScript: 123let a = true &amp;&amp; false; // falselet b = true || false; // truelet c = !true; // false 在 JavaScript 中，邏輯運算子的語法也與 Python 相似，用於執行布林邏輯操作。 特殊運算子 Python (海象運算子): 12if (n := 10) &gt; 5: print(&quot;Greater than 5&quot;) # n 在這裡被賦值為 10 在 Python 中，使用海象運算子（:=）可以同時賦值和比較。這是 Python 3.8+ 中的新特性。 JavaScript (類型運算子, 實例運算子, 空值合併運算子): 12345console.log(typeof &quot;Hello&quot;); // &quot;string&quot;console.log(&quot;Hello&quot; instanceof String); // falselet name = null;let displayName = name ?? &quot;Anonymous&quot;;console.log(displayName); // &quot;Anonymous&quot; 在 JavaScript 中，我們使用 typeof 運算子來獲得變數或值的數據類型。instanceof 運算子用於檢查對象是否是指定類型的實例。?? 運算子用於提供默認值，如果左邊的值為 null 或 undefined，則使用右邊的值。 位元運算的差異 JavaScript (無符號右移運算子): 1let a = -8 &gt;&gt;&gt; 1; // 將 -8 視為無符號整數進行右移，結果為 2147483644 在 JavaScript 中，存在無符號右移運算子 &gt;&gt;&gt;，它將數字視為無符號整數進行右移。這是 Python 中不具備的位元運算功能。 這些範例突顯了 Python 和 JavaScript 在運算子使用上的一些重要差異，這些差異反映了它們各自的語言特性和設計理念。瞭解這些差異對於有效地使用這兩種語言來進行編程是很重要的。 資料結構多彩多姿的集合：列表 (List) 和 陣列 (Array)在 Python 的世界裡，我們有個叫列表 list 的東西。它就像一個大胃王，什麼都能吞。數字、字串、甚至是小數，都能裝進去。嗯，我們來看看 my_list 是不是真的這麼厲害： 123my_list = [1, &quot;hello&quot;, 3.14]print(my_list) # [1, 'hello', 3.14]print(type(my_list)) # &lt;class 'list'&gt; 在 JavaScript 的宇宙中，陣列 Array 就是這個角色。它也能存放各種各樣的元素。讓我們看看 myArray 是不是也一樣多才多藝。 123let myArray = [1, &quot;hello&quot;, 3.14];console.log(myArray); // [1, 'hello', 3.14]console.log(typeof myArray); // 'object' Python 中的列表 (List)列表是一種有序的集合，它可以容納不同類型的元素，包括整數、字串、小數等。以下是列表的主要特點和使用方式。 建立列表 1my_list = [1, &quot;hello&quot;, 3.14] 在這個範例中，我們建立了一個名為 my_list 的列表，其中包含了整數、字串和浮點數。 存取列表元素 12print(my_list[0]) # 存取第一個元素，結果是 1print(my_list[1]) # 存取第二個元素，結果是 &quot;hello&quot; 你可以使用索引來存取列表中的元素，索引從 0 開始計數。 添加元素 1my_list.append(42) # 在列表末尾添加一個新元素 42 使用 append 方法可以在列表的末尾添加新的元素。 刪除元素 1del my_list[1] # 刪除第二個元素，my_list 變為 [1, 3.14] 你可以使用 del 關鍵字來刪除列表中的元素。 列表長度 1length = len(my_list) # 獲得列表的長度，結果是 2 你可以使用 len 函式獲得列表的長度。 JavaScript 中的陣列 (Array)陣列也是一種有序的集合，它和 Python 的列表在概念上相似，但在使用上有些許不同。以下是陣列的主要特點和使用方式： 建立陣列 1let myArray = [1, &quot;hello&quot;, 3.14]; 在這個範例中，我們建立了一個名為 myArray 的陣列，其中包含了整數、字串和浮點數。 存取陣列元素 12console.log(myArray[0]); // 存取第一個元素，結果是 1console.log(myArray[1]); // 存取第二個元素，結果是 &quot;hello&quot; 你同樣可以使用索引來存取陣列中的元素，索引也是從 0 開始計數。 添加元素 1myArray.push(42); // 在陣列末尾添加一個新元素 42 使用 push 方法可以在陣列的末尾添加新的元素。 刪除元素 1myArray.splice(1, 1); // 刪除第二個元素，myArray 變為 [1, 3.14] 你可以使用 splice 方法來刪除陣列中的元素。 陣列長度 1let length = myArray.length; // 獲得陣列的長度，結果是 2 你可以使用 length 屬性獲得陣列的長度。 列表 (List) 和陣列 (Array) 都是用來存儲一系列元素的資料結構，它們在不同的程式語言中都具有類似的功能，但具體的使用方式和方法可能有所不同。無論你選擇使用哪種語言，都可以靈活地操作這些集合來處理資料。 鍵值對的魔法：字典 (Dict) 和 物件 (Object)Python 的 字典 就像一本魔法書，裡面用鍵和值的配對記錄了許多秘密。比如說，愛麗絲的年齡和名字： 123my_dict = {&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30}print(my_dict) # {'name': 'Alice', 'age': 30}print(type(my_dict)) # &lt;class 'dict'&gt; 而在 JavaScript 的世界，物件 是這樣的存在。它也保存著類似的秘密，只不過寫法有點不一樣。 123let myObject = {name: &quot;Alice&quot;, age: 30};console.log(myObject); // {name: 'Alice', age: 30}console.log(typeof myObject); // 'object' Python 中的字典 (Dict)字典是一種無序的集合，它使用鍵值對的方式來存儲資料，每個鍵都對應一個值。以下是字典的主要特點和使用方式： 建立字典 123my_dict = {&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30}print(my_dict) # {'name': 'Alice', 'age': 30}print(type(my_dict)) # &lt;class 'dict'&gt; 存取字典元素 1234name_value = my_dict[&quot;name&quot;] # 存取鍵為 &quot;name&quot; 的值age_value = my_dict[&quot;age&quot;] # 存取鍵為 &quot;age&quot; 的值print(&quot;Name:&quot;, name_value) # Name: Aliceprint(&quot;Age:&quot;, age_value) # Age: 30 添加新的鍵值對 12my_dict[&quot;city&quot;] = &quot;New York&quot; # 添加一個新的鍵值對print(my_dict) # {'name': 'Alice', 'age': 30, 'city': 'New York'} 刪除鍵值對 12del my_dict[&quot;age&quot;] # 刪除鍵為 &quot;age&quot; 的鍵值對print(my_dict) # {'name': 'Alice', 'city': 'New York'} 字典的長度 12length = len(my_dict) # 獲得字典的長度，結果是 2print(length) JavaScript 中的物件 (Object)物件也是一種無序的集合，它使用鍵值對的方式來存儲資料，每個鍵都對應一個值。以下是物件的主要特點和使用方式： 建立物件 123let myObject = {name: &quot;Alice&quot;, age: 30};console.log(myObject); // {name: 'Alice', age: 30}console.log(typeof myObject); // 'object' 存取物件元素 1234let nameValue = myObject.name; // 存取鍵為 &quot;name&quot; 的值let ageValue = myObject.age; // 存取鍵為 &quot;age&quot; 的值console.log(&quot;Name:&quot;, nameValue); // Name: Aliceconsole.log(&quot;Age:&quot;, ageValue); // Age: 30 添加新的鍵值對 12myObject.city = &quot;New York&quot;; // 添加一個新的鍵值對console.log(myObject); // {name: 'Alice', age: 30, city: 'New York'} 刪除鍵值對 12delete myObject.age; // 刪除鍵為 &quot;age&quot; 的鍵值對console.log(myObject); // {name: 'Alice', city: 'New York'} 物件的屬性數量 12let numProperties = Object.keys(myObject).length; // 獲得物件的屬性數量，結果是 2console.log(numProperties); 在每個範例中，我們都印出了結果，展示了字典 (Dict) 和物件 (Object) 的使用方法和操作的效果。 堅固小組：元組 (Tuple)在 Python 裡，tuple 就像是一個不能被改變的小組。一旦建立，就無法改變它的成員。來看看我們的 my_tuple 123my_tuple = (1, &quot;hello&quot;, 3.14)print(my_tuple) # (1, 'hello', 3.14)print(type(my_tuple)) # &lt;class 'tuple'&gt; JavaScript 則沒有這麼嚴格的小組，但我們可以用 Array 加上一些魔法（Object.freeze）來模擬這種不變性。 123let myTuple = Object.freeze([1, &quot;hello&quot;, 3.14]);console.log(myTuple); // [1, 'hello', 3.14]console.log(typeof myTuple); // 'object' Python 元組（Tuple）在 Python 中，元組是一種不可變的資料結構。這意味著一旦建立，就無法更改元組中的元素。這使得元組在某些場景中非常有用，特別是當你需要保證資料不被修改時。例如： 123456789my_tuple = (1, &quot;hello&quot;, 3.14)print(my_tuple) # (1, 'hello', 3.14)print(type(my_tuple)) # &lt;class 'tuple'&gt;# 嘗試修改元組，但會引發錯誤try: my_tuple[0] = 42except TypeError as e: print(f&quot;Error: {e}&quot;) 我們首先建立了一個名為 my_tuple 的元組，它包含了整數、字串和浮點數。 然後，我們嘗試修改這個元組的第一個元素，但會引發 TypeError 錯誤，證明無法更改元組的成員。 在 JS 中模擬元組不變性JavaScript 則沒有這麼嚴格的小組，但我們可以用 Array 加上一些魔法（Object.freeze）來模擬這種不變性。以下是範例，包括一個嘗試修改凍結的結構的例子： 1234567let myTuple = Object.freeze([1, &quot;hello&quot;, 3.14]);console.log(myTuple); // [1, 'hello', 3.14]console.log(typeof myTuple); // 'object'// 嘗試修改凍結的結構，但不會成功myTuple[0] = 42;console.log(myTuple); // [1, 'hello', 3.14] 我們首先使用 Object.freeze 函數來凍結一個包含整數、字串和浮點數的陣列，以模擬元組的不變性。 然後，我們嘗試修改這個凍結的陣列的第一個元素，但不會成功，並輸出了原始的內容，證明無法更改凍結的結構。 在這個 JavaScript 例子中，即使變量名稱是 myTuple，它實際上仍是一個陣列，只是被凍結以防止修改。這是模擬 Python 元組行為的一種方式，但需要注意的是，這個凍結的陣列在 JavaScript 中仍被視為一個對象，而非一個新的或特殊的資料類型。 獨一無二的 集合 (set)Python 的 set 就像一個派對，但不允許重複的客人。每個元素都是獨一無二的。 123456guest_set = {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;}print(guest_set) # {'Alice', 'Bob', 'Charlie'}# 嘗試加入重複的客人guest_set.add(&quot;Bob&quot;) # Bob 已經存在於集合中，不會重複添加print(guest_set) # {'Alice', 'Bob', 'Charlie'} 在 JavaScript 的派對（Set）也是這樣，不歡迎重複的客人。 123456let guestSet = new Set([&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]);console.log(guestSet); // Set(3) {'Alice', 'Bob', 'Charlie'}// 嘗試加入重複的客人guestSet.add(&quot;Bob&quot;); // Bob 已經存在於集合中，不會重複添加console.log(guestSet); // Set(3) {'Alice', 'Bob', 'Charlie'} 大致了解 Set 的用途後，接著我們分別介紹 Python, JS 中 Set 的詳細用法。 Python 的 集合 (Set)在 Python 中， 集合 (Set) 是一個無序的可變容器，它是由一組獨一無二的元素所組成的。這意味著集合中不允許有重複的元素，每個元素都是唯一的。你可以使用大括號 {} 或 set() 建立一個集合，然後將元素添加到集合中。以下是一些範例： 建立一個集合1my_set = {1, 2, 3} 增加元素到集合1my_set.add(4) 刪除元素1my_set.remove(2) 檢查元素是否存在1print(1 in my_set) # True 遍歷集合12for item in my_set: print(item) 輸出集合及其類型12print(my_set) # {1, 3, 4}print(type(my_set)) # &lt;class 'set'&gt; JavaScript 的 Set在 JavaScript 中，Set 也是一個無序的集合，它用於存儲唯一的值。你可以使用 new Set() 構造函式建立一個 Set 對象，然後使用 add() 方法添加值。與 Python 不同的是，JavaScript 的 Set 是一個對象，而不是原始的資料類型。以下是一些範例： 建立一個 Set1let mySet = new Set([1, 2, 3]); 增加值到 Set1mySet.add(4); 刪除值1mySet.delete(2); 檢查值是否存在1console.log(mySet.has(1)); // true 遍歷 Set123mySet.forEach(item =&gt; { console.log(item);}); 輸出 Set 及其類型12console.log(mySet); // Set(3) {1, 3, 4}console.log(typeof mySet); // 'object' 綜合比較雖然 Python 的 集合 (Set) 和 JavaScript 的 Set 在功能上很相似，但要注意它們之間的一些差異： 類型差異：Python 的 集合 (Set) 的類型是 set，而 JavaScript 的 Set 是一個對象。 語法差異：Python 使用大括號 {} 定義集合，而 JavaScript 使用 new Set() 建立 Set 對象。 遍歷方式：Python 使用 for item in my_set 遍歷集合，而 JavaScript 使用 forEach 方法。 儘管有這些差異，兩者的基本功能都是相同的，都可以用來儲存唯一的值，並進行相關操作。 流程控制 (一) 條件判斷用餐廳點菜學 if-elseif-else 就像在一家餐廳點菜一樣。如果你有特定的食物喜好，比如大門口的餐廳有你喜歡的食物，你就走進去，否則你去下一家。 Python 中的 if-else在 Python 中，if 與 else 語句的最後要加上冒號 :，符合條件判斷後的執行程式需要縮排。 12345food_preference = &quot;披薩&quot;if food_preference == &quot;壽司&quot;: print(&quot;我要壽司&quot;)else: print(&quot;我找下一家餐廳&quot;) JavaScript 中的 if-else在 JavaScript 中，語法多了括號和分號，但不會嚴格限制縮排的空格。空格數量錯誤還是可以執行。 123456let restaurant = &quot;義大利料理&quot;;if (restaurant === &quot;日本料理&quot;) { console.log(&quot;我想吃壽司。&quot;);} else { console.log(&quot;讓我們試試下一家餐廳吧。&quot;);} 用服飾風格學 switch-case我們要示範的題目是「在試衣間試穿不同風格的服裝時，可根據喜好選擇服裝風格。」，在有多個選項的情況下，使用 switch-case 比起 if-else 具有更高的可讀性。 在 Python 使用 match-case 或是 if-else3.10 以前，使用 if-else 來模擬 switch-case在 Python 3.10 以前的版本沒有 switch-case 語句可以用，只能用 if-else。 12345678910111213outfit_style = &quot;casual&quot;outfit = &quot;&quot;if outfit_style == &quot;formal&quot;: outfit = &quot;西裝筆挺&quot;elif outfit_style == &quot;casual&quot;: outfit = &quot;牛仔褲和 T 恤&quot;elif outfit_style == &quot;athletic&quot;: outfit = &quot;運動裝&quot;else: outfit = &quot;不知道穿什麼&quot;print(outfit) 3.10 之後，使用 match-casePython 3.10 以後，我們可以使用 match 語句。例如： 1234567891011outfit_style = &quot;casual&quot;outfit = match outfit_style: case &quot;formal&quot;: &quot;西裝筆挺&quot; case &quot;casual&quot;: &quot;牛仔褲和 T 恤&quot; case &quot;athletic&quot;: &quot;運動裝&quot; case _: &quot;不知道穿什麼&quot;print(outfit) 在 JavaScript 中使用 switch 與 case在 JavaScript 中則是早在 ECMAScript 第一版就加入了 switch case 的語法。switch-case 的語句也是比較典型的控制流程關鍵字。例如：Java 和 C 都是使用 switch-case 關鍵字。 12345678910111213141516let outfit_style = &quot;casual&quot;;let outfit;switch (outfit_style) { case &quot;formal&quot;: outfit = &quot;西裝筆挺&quot;; break; case &quot;casual&quot;: outfit = &quot;牛仔褲和 T 恤&quot;; break; case &quot;athletic&quot;: outfit = &quot;運動裝&quot;; break; default: outfit = &quot;不知道穿什麼&quot;;}console.log(outfit); 使用 switch 語句時，如果不加入 break 會發生什麼事情在 JavaScript 中，switch 語句中的 break 語句是可選的，但它對控制流程具有重要影響。如果省略了 break，則 switch 將繼續執行下一個 case 或 default 分支，直到遇到 break 或 switch 結束為止。 在你上一個範例的程式碼中，每個 case 後面都有 break，這是一種良好的實踐，因為它確保只有一個 case 被執行。 如果省略了這些 break，將發生 “穿透”（fall-through）效應，即使多個 case 條件都被匹配，所有符合條件的 case 以及後續的程式碼都將被執行。 例如，如果省略了 break： 12345678910111213141516let outfit_style = &quot;casual&quot;;let outfit;switch (outfit_style) { case &quot;formal&quot;: outfit = &quot;西裝筆挺&quot;; // 沒有 break，將穿透到下一個 case case &quot;casual&quot;: outfit = &quot;牛仔褲和 T 恤&quot;; // 再次沒有 break，將穿透到下一個 case case &quot;athletic&quot;: outfit = &quot;運動裝&quot;; // 再次沒有 break，將穿透到 default default: outfit = &quot;不知道穿什麼&quot;;}console.log(outfit); // 最終輸出為 &quot;不知道穿什麼&quot; 在上面的例子中，由於缺少 break 語句，控制流程穿透到了下一個 case，直到 default。預期的答案 casual 應該對應的是「牛仔褲和 T 恤」，卻因為穿透效應，變成「不知道穿什麼」。 因此，為了確保每個 case 只執行一次，通常應在每個 case 的末尾加上 break。這有助於避免預期外的行為和錯誤。 流程控制 (二) 迴圈For 迴圈：最萬用的迴圈Python 的 For 迴圈 目的：for 迴圈在 Python 中用於遍歷可迭代對象，這些對象可以是列表、元組、字串、字典等。它允許你逐個訪問這些對象的元素或元素的索引。 語法結構：For 迴圈的基本結構如下： 12for 迴圈變數 in 可迭代對象: # 在這裡執行你的程式碼，這段程式碼會在每次迭代中執行 迴圈變數：這是一個變數名稱，它在每次迭代中被賦值為可迭代對象中的當前元素。你可以自行命名這個變數。 可迭代對象：這是你要遍歷的對象，可以是列表、元組、字串等。 迴圈內的程式碼：這是在每次迭代中執行的程式碼，它必須使用縮排（縮進）表示，並且需要與 for 語句對齊。 範例：讓我們使用購物清單的例子來說明： 123shopping_list = [&quot;蘋果&quot;, &quot;香蕉&quot;, &quot;橙子&quot;, &quot;葡萄&quot;]for item in shopping_list: print(&quot;我要買&quot;, item) 在這個例子中，item 是迴圈變數，它依次被賦值為購物清單中的每個項目，然後印出相應的訊息。 遍歷範圍：For 迴圈也可以用於遍歷範圍（range），範圍是一個表示數字序列的可迭代對象。這對於執行一定次數的迭代非常有用。 12for i in range(5): print(&quot;迭代次數：&quot;, i) 這個例子會執行 5 次迭代，分別印出 0 到 4 的數字。 Python 中的 for 迴圈用於遍歷各種可迭代對象，它為每次迭代提供一個變數，並在迴圈內部執行相關的程式碼。這使得處理序列資料變得非常方便。 JavaScript 的 For 迴圈 在 JavaScript 中的 for 迴圈就像一場比賽，你知道比賽有多長，並且你會根據比賽的距離一圈又一圈地跑。 1234let raceDistance = 10; // 10 圈比賽for (let lap = 1; lap &lt;= raceDistance; lap++) { console.log(&quot;我跑了第&quot; + lap + &quot;圈&quot;);} 在 JavaScript 中的 for 迴圈是一個非常有用的工具，可以讓你重複執行指定次數的操作，就像一場比賽一樣。讓我們來更詳細地說明： 初始化（Initialization）：在 for 迴圈的開始，你會設定一個初始值，這個值通常代表迴圈控制變數。在你的範例中，控制變數是 lap，初始值是 1，它代表你的比賽一開始的狀態。 條件（Condition）：接下來，你會設定一個條件，只要這個條件為真，迴圈就會繼續運行。在你的程式碼中，條件是 lap &lt;= raceDistance，這意味著只要 lap 的值小於或等於 raceDistance（比賽的總圈數），迴圈就會繼續執行。 遞增/ 遞減語句（Increment / Decrement Statement）：在每一輪迴圈結束時，你會執行遞增（或遞減）語句，這通常用於改變控制變數的值，以便最終滿足條件不再為真。在你的範例中，你使用 lap++ 來將 lap 的值增加 1，表示你跑了一圈。 迴圈體（LoopBody）：在迴圈的大括號 {} 內，你放置了希望重複執行的程式碼。在這裡，你使用 console.log 來顯示你跑了第幾圈。 所以，在你的 JavaScript 程式碼中，當迴圈開始運行時，控制變數 lap 的值從 1 開始，然後它滿足條件 lap &lt;= raceDistance，因此迴圈繼續執行。在每一圈結束時，lap 的值都會增加 1，直到它不再滿足條件，那麼迴圈就結束了。這就像一場比賽，你知道你需要跑多少圈，然後一圈一圈地跑，直到完成比賽。 While 迴圈：當條件符合，持續運作Python 中的 while 迴圈 在 Python 中的 while 迴圈就像你等待公車一樣。你不知道公車什麼時候會到來，所以你一直檢查，只要公車到達，你就可以上車。 123456waiting_for_bus = Truewhile waiting_for_bus: print(&quot;等公車...&quot;) if bus_arrived: waiting_for_bus = Falseprint(&quot;上車了！&quot;) Python 中的 while 迴圈根據指定的條件表達式的真假來執行迴圈。 使用 while 關鍵字，並在 while 後指定條件表達式，只要條件為真，就會繼續執行迴圈。 迴圈體使用縮排表示，並在條件為假時退出。 JavaScript 中的 while 迴圈 在 JavaScript 中的 while 迴圈就像一個運動員進行訓練。他們一直在做重複的練習，直到達到一定的目標。 1234567let trainingTime = 0;let trainingGoal = 60; // 訓練 60 分鐘while (trainingTime &lt; trainingGoal) { console.log(&quot;練習中...&quot;); trainingTime += 10; // 每次增加 10 分鐘}console.log(&quot;訓練完成！&quot;); JavaScript 中的 while 迴圈也根據指定的條件表達式的真假來執行迴圈。 使用 while 關鍵字，並在 while 後指定條件表達式，只要條件為真，就會繼續執行迴圈。 迴圈體使用大括號 {} 表示，並在條件為假時退出。 Do While 迴圈：先做再說Python 沒有 do while 在 Python 中沒有嚴格的 do while 迴圈，但我們可以模擬它，比如吃冰淇淋。你首先吃冰淇淋，然後檢查你是否還有口渴，如果是，就繼續吃冰淇淋。 1234567ice_cream = 3while ice_cream &gt; 0: print(&quot;吃冰淇淋...&quot;) ice_cream -= 1 if thirsty: breakprint(&quot;吃完了！&quot;) Python 中沒有嚴格的 do while 迴圈，但可以使用 while True 來實現類似的功能，再加上 break 語句來控制退出條件。 使用 while 關鍵字建立一個無限循環，並在適當的時候使用 break 退出。 JavaScript 中的 do while 在 JavaScript 中的 do while 迴圈就像打電話給朋友，不管朋友是否接聽，你都要至少嘗試一次。 123456let attempts = 0;do { console.log(&quot;打電話給朋友...&quot;); attempts++;} while (attempts &lt; 3);console.log(&quot;不接聽了！&quot;); JavaScript 中的 do while 迴圈是一個至少執行一次的迴圈，然後根據指定的條件表達式決定是否繼續執行。 使用 do 關鍵字來開始迴圈，並在 while 後指定條件表達式。 迴圈體使用大括號 {} 表示，並在條件為假時退出。 這些比喻希望幫助你理解 Python 和 JavaScript 中的迴圈。無論你是在購物、比賽、等公車、訓練、吃冰淇淋還是打電話，迴圈是程式中一個強大且常見的控制結構，可以幫助你重複執行任務。 函式發送問候：函式在 Python 中使用函式在 Python 的世界裡，一個函式 (function) 可以用來發送溫暖的問候。它會告訴你它的型態是個函式。以下是範例： 12345def greet(name): return f&quot;Hello, {name}!&quot;print(greet(&quot;Alice&quot;)) # Hello, Alice!print(type(greet)) # &lt;class 'function'&gt; 我們首先定義了一個名為 greet 的函式，它接受一個名字作為參數。 在函式內部，我們使用 f-string 將問候該名字的字串建立起來。 然後，我們呼叫這個函式，將 “Alice” 作為參數傳遞給它，並輸出了函式的結果，也就是 “Hello, Alice!”。 最後，我們輸出了 greet 函式本身的型態，這證明它確實是一個函式。 在 JavaScript 中使用函式在 JavaScript 的國度中，一個函式 (function) 也能做同樣的事情。它也會自豪地告訴你它是一個函式。以下是範例： 123456function greet(name) { return `Hello, ${name}!`;}console.log(greet(&quot;Alice&quot;)); // Hello, Alice!console.log(typeof greet); // 'function' 我們首先定義了一個名為 greet 的函式，它同樣接受一個名字作為參數。 在函式內部，我們使用模板字串 (template string) 將問候該名字的字串建立起來。 然後，我們呼叫這個函式，將 “Alice” 作為參數傳遞給它，並輸出了函式的結果，也就是 “Hello, Alice!”。 最後，我們輸出了 greet 函式本身的型態，這證明它確實是一個函式。 這兩個範例展示了如何在 Python 和 JavaScript 中使用函式和函式來實現相同的目標，即發送溫暖的問候。儘管語法和語言不同，但概念相似。 變身魔法：Python 列表推導式 vs JS 陣列方法在 Python 中使用列表推導式在 Python 中，列表推導式就像是個魔法師，可以把一個普通的數字列表變成它們的平方。以下是範例： 1234numbers = [1, 2, 3, 4, 5]squared = [x ** 2 for x in numbers]print(squared) # [1, 4, 9, 16, 25]print(type(squared)) # &lt;class 'list'&gt; 我們首先定義一個名為 numbers 的列表，其中包含數字 1 到 5。 然後，我們使用列表推導的方法建立了一個名為 squared 的新列表，該列表包含了 numbers 中每個數字的平方。 最後，我們輸出了 squared 列表的內容以及它的型態。 在 JavaScript 中使用 map 方法在 JavaScript 中，map 方法也能做到相同的事，只不過它用的咒語聽起來不太一樣。以下是範例： 1234let numbers = [1, 2, 3, 4, 5];let squared = numbers.map(x =&gt; x ** 2);console.log(squared); // [1, 4, 9, 16, 25]console.log(typeof squared); // 'object' 我們首先定義一個名為 numbers 的陣列，其中包含數字 1 到 5。 然後，我們使用 map 方法，對 numbers 陣列中的每個元素應用一個函式，這個函式將每個元素取平方。 最後，我們輸出了 squared 陣列的內容以及它的型態。 這兩個範例展示了如何在 Python 和 JavaScript 中以不同的方式實現相同的目標，即將一個數字列表轉換為它們的平方值。在 Python 中使用列表推導，而在 JavaScript 中使用 map 方法。 例外處理當我們談論 JavaScript（JS）和 Python 的例外處理時，我們可以想像成在餐廳用餐時遇到的情境： Python現在，讓我們轉向 Python 的例外處理。 你在一家餐廳點了一份特別的料理，但當廚師在烹飪過程中意外燒焦了食物。這就像 Python 中的例外情況。 12345678910try: # 可能引發例外的程式碼，就像料理過程 result = 10 / 0 # 這裡的除以零就像食物燒焦 print(result) # 這一行實際上不會執行，就像你無法享受燒焦的料理except ZeroDivisionError as e: # 例外處理區塊，就像處理燒焦的料理 print('發生錯誤：', str(e)) # 這就像告訴廚師食物燒焦了finally: # 最終執行的區塊，不管是否有錯誤都會執行，就像總是要結帳一樣 print('不管是否有錯誤，這裡都會執行，就像總是要結帳') 在這個情境中，你期望享受美味的料理（try 區塊），但由於烹飪失敗（錯誤），你需要通知廚師（except 區塊）食物燒焦了，然後總是需要結帳（finally 區塊）。 JavaScript (JS)想像你在一家餐廳點了一份蛋糕，但服務生在端上蛋糕的時候，意外地把蛋糕摔到地上。這就像 JavaScript 中的錯誤。 1234567891011try { // 可能引發例外的程式碼，就像端蛋糕 let result = 10 / 0; // 這裡的除以零就像摔蛋糕 console.log(result); // 這一行實際上不會執行，就像你無法享用摔碎的蛋糕} catch (error) { // 例外處理區塊，就像處理摔碎的蛋糕 console.error('發生錯誤：' + error.message); // 這就像告訴服務生蛋糕摔壞了} finally { // 最終執行的區塊，不管是否有錯誤都會執行，就像總是要結帳一樣 console.log('不管是否有錯誤，這裡都會執行，就像總是要結帳');} 在這個情境中，你嘗試享用蛋糕（try 區塊），但由於服務失誤（錯誤），你需要處理這個情況，告訴服務生（catch 區塊）蛋糕摔壞了，然後總是要完成結帳（finally 區塊）。 這兩個情境幫助我們理解 JavaScript 和 Python 中的例外處理，無論是在餐廳中處理料理或點心，還是在程式碼中處理錯誤，都需要適當的處理和最終的清理步驟。 綜合比較在上面的例子中，我們可以比較 Python 和 JavaScript（JS）在例外處理方面的不同之處： 語法不同: Python: Python 使用 try...except 構造來處理例外情況，並使用 as 來指定錯誤的別名。這種語法相對簡潔。 JavaScript: JavaScript 使用 try...catch 構造來處理錯誤，並在 catch 區塊中使用 error 變數來訪問錯誤物件的訊息。 錯誤類型不同: Python: 在Python中，每個錯誤都有特定的類型。在例子中，我們使用 ZeroDivisionError 來處理除以零的錯誤。 JavaScript: JavaScript的錯誤通常是通用的，並不總是有明確的錯誤類型。在例子中，我們只使用了通用的錯誤物件，而沒有指定特定的錯誤類型。 訊息處理不同: Python: 在 Python 中，我們使用 str(e) 來獲取錯誤物件 e 的訊息，並在 except 區塊中處理它。 JavaScript: 在 JavaScript 中，我們使用 error.message 來獲取錯誤物件 error 的訊息，同樣在 catch 區塊中處理它。 最終執行: Python: Python 和 JavaScript 都支援 finally 區塊，用於確保無論是否有錯誤，某些程式碼都會執行。 JavaScript: 在這兩種語言中，finally 區塊的功能是相似的，都用於執行清理程式碼。 結論Python 和 JavaScript 在例外處理方面有一些語法上的不同，例如 try...except（Python）和 try...catch（JavaScript），以及錯誤類型的表示方式。然而，核心概念相似，都是用於處理程式運行時可能引發的錯誤，並提供一種方式來捕捉、處理和最終處理這些錯誤。 專有名詞對照表 專有名詞 Python JavaScript 資料型別 整數 (int) 整數 (Number) 浮點數 (float) 浮點數 (Number) 布林 (bool) 布林 (Boolean) 字串 (str) 字串 (String) 資料結構 列表 (list) 陣列 (Array) 字典 (dictionary) 物件 (Object) 元組 (tuple) 集合 (set) 集合 (Set) 控制流程 條件語句 (if) 條件語句 (if) 迴圈 (loop) 迴圈 (loop) while 迴圈 while 迴圈 for 迴圈 for 迴圈 switch 語句 switch 語句 迴圈控制 (break, continue) 迴圈控制 (break, continue) 函式相關 參數 (parameter) 參數 (parameter) 返回值 (return value) 返回值 (return value) 自訂函數 (user-defined function) 自訂函數 (user-defined function) 方法 (method) 方法 (method) 例外處理 例外處理 (try, except, finally) 例外處理 (try, catch, finally) 斷言 (assert) 斷言 (assert) 例外拋出 (raise) 例外拋出 (throw) 其他名詞 註釋 (comment) 註釋 (comment) 變數 (variable) 變數 (variable) 常數 (constant) 常數 (constant) 運算符 (operator) 運算符 (operator) 資料類型轉換 (type conversion) 特殊值 NaN, Infinity","link":"/mentocamp/python-vs-js.html"}],"posts":[{"title":"饅頭計畫 #0 學員心得 (1) Moojing","text":"第零屆的學員只有一個人，這位同學寫了系列文章文章記錄了學習軌跡。 前端工程師後端之旅(1) — 原來30天可以走這麼遠. 一個月可以做很多事：可以讀一本書、可以出國旅遊、可以養成一個你想要的好習慣，我用… | by Moojing | Medium前端工程師後端之旅(2) — 從畫面拆解，到整理User Story前端工程師後端之旅(3) — 路由設計以及Slug SEO優化前端工程師後端之旅(4) — 前端體驗優化前端工程師後端之旅(5) — 資料庫關係設計前端工程師後端之旅(6) — 利用爬蟲取得網站原始商品資料前端工程師後端之旅(7) — 直上穹頂的最後一哩路：部署[Javascript] 製作 Base on Cookie 的購物車[Javascript] 初探Regex 正規表達式[javasrcipt] Summernote 所見即所得編輯器達成圖片上傳","link":"/2019/02/06/mc0-01-moojing/"},{"title":"饅頭計畫 #1 學員心得 (1) Joanne","text":"Q: 怎麼稱呼？A: Joanne Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 全端，但專案框架都雷同 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 還記得加入饅頭計畫沒多久，同時也在準備實習面試(目前已畢業轉正)，當時的我coding能力其實並不好，許多基本觀念、技術也都很不熟悉，所以對於即將開始實習這件事，感到非常緊張和擔心，擔心自己能力不足也擔心自己沒辦法好好表現，所以也曾經請教過Luka，該如何提升自己的能力呢 ? 甚至到底該如何學習「物件導向」? 而請教完也相對比較有概念，知道如果要把「物件導向」的相關書籍從頭啃到尾，實在有點痛苦，做中學才能真正理解何謂物件導向。而其實也相當感謝Luka願意無私的分享自己的技術，講解了許多基本觀念和分享開發過程中會接觸到的工具，你的課程很棒~真的有幫助到我~~~ XD 即使在後期因為工作繁忙比較少參與課程，但還是非常謝謝Luka ʕ•ᴥ•ʔ Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 覺得Luka做事很積極哈哈哈，非常的棒啊啊啊啊，當我準備怠惰時，看到Luka下班後還開直播教學，立馬從沙發跳起 (沒資格軟爛)。hahaha Q: 有沒有你很想學，但是沒有學到的東西？A: 資料庫正規化設計及資料庫效能優化 很需要加強… AWS (工作上有接觸到一些，已購入課程，目標今年考到證照!!!) Ruby、Ruby On Rails 網路架構這塊…超弱 QQ 什麼封包什麼router switch，因為我是IT部門，這塊早晚還是必須學起來 強大的邏輯，有了清晰又強大的邏輯力，遇到問題就可以馬上知道問題點及解決方法 (:::з」∠) Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 非常期待饅頭計畫第二彈 ! Luka加油~! Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-01-joanne/"},{"title":"饅頭計畫 #1 學員心得 (2) GK","text":"Q: 怎麼稱呼？A: GK Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 前端工程師 Q: 你覺得饅頭計畫對你有幫助嘛？A: 非常有幫助，讚！ Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 不好意思說自己是人人稱羨的工程師，只好自稱混水摸魚，但其實還是稍微認真的在工作著，也逐漸朝系統分析的領域、後端領域與資料庫的領域學習。我覺得最大的好處就是有人督促學習，監督進度，不然自己真的很容易懶散。感謝 Luka！ Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 逼迫的部分 Q: 有沒有你很想學，但是沒有學到的東西？A: 沒有特別想學什麼，都是順著路走 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 我寫了一篇轉職心得，其中有提到一點點饅頭計畫https://gkfat.github.io/gk-blog/2019/10/15/road-to-front-end Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-02-gk/"},{"title":"饅頭計畫 #1 學員心得 (4) TsungYu","text":"Q: 怎麼稱呼？A: 宗裕 Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 偏向雲端工程師 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可 A: 我覺得這個計畫對我最大的影響是讓我在學習的過程中，學會自己去找問題解答，有幾次因為 Mentor 的提點，才有辦法找出解法。過程雖然挫折，但我相信這是成為一位 Engineer 必須具備的能力，畢竟很多時候，不可能會有人手把手帶著自己(別人也沒有義務)。 另外覺得很不錯的地方在於 Mentor 鼓勵學員將自己的學習記錄成文章，在撰寫的過程中，其實也是在檢視自己對於該技術的認知程度到多少。而更多時候是，記錄下來的東西是幫助到未來的自己！經常在 Coding 時會回過頭來看筆記，每次看著看著，就會想哪裏沒寫好，或是還有哪些可以補充，我想這也是一種成長。 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: Luka 的引導方式有別於一般Mentor，遇到問題的時候，不會急著給答案，而是給解決問題的方向，要學員嘗試自己去找解法，讓學員養成試著自己除錯的習慣。 Q: 有沒有你很想學，但是沒有學到的東西？A: 後端工程師的一些必備知識，e.g. 網路、資料庫、資安等等 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 謝謝 Luka! 若不是饅頭計畫，我可能沒辦法即時修正自己的學習方法，從發散式的學習到收斂至主要目標，切分成一個個的學習步驟。 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 我才不要勒","link":"/2020/09/06/mc1-04-tsung-yu/"},{"title":"饅頭計畫 #1 學員心得 (5) Leah","text":"Q: 怎麼稱呼？A: Leah Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 前端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 非常有幫助，讚！ Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A:初期找工作時明確知道準備方向，也因為有Luka開Asana的票，隨時盯自己的進度，比較不會自己一個人準備就沒自信、鬆懈。之後跟其他學院加入群組，還有一次實體分享會，在裡面看到其他人的分享，也督促自己成為工程師之後還是要持續進修 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 願意分享經驗，提供明確的建議，很大方提供Udemy讓我當免費仔XD Q: 有沒有你很想學，但是沒有學到的東西？A: Docket k8s 這些新潮的雲端部署的概念 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！而且我已經寫好了 Q: 有沒有什麼話想對 Luka 說？A: 在年初的激勵之下，拖了半年，我終於勇敢換工作了！換到一家比較有成長性的公司，不過是還沒滿試用期的菜雞 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-05-leah/"},{"title":"饅頭計畫 #1 學員心得 (6) Shirley","text":"Q: 怎麼稱呼？A: shirley Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: \b否，我沒有變轉職成功 Q: 你目前的職業是？A: UI設計師，會接觸到一些切版 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 因課程教學不到一半，自己先去找到工作了 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 暸解到前端，基本學習 Q: 有沒有你很想學，但是沒有學到的東西？A: 目前沒有 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？\bA: 抱歉，這題我 pass Q: 有沒有什麼話想對 Luka 說？A: 謝謝你，給我們學習的機會，讓我們收穫很多。辛苦你，準備很多題材～ 你題材很棒 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 我才不要勒","link":"/2020/09/06/mc1-06-shirley/"},{"title":"饅頭計畫 #1 學員心得 (3) Genie","text":"Q: 怎麼稱呼？A: Genie Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: \b否，我沒有變轉職成功 Q: 你目前的職業是？A: 還在學習中，目標今年轉職成功 Q: 你覺得饅頭計畫對你有幫助嘛？A: 還好，so so Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 暫無。 不過主要是我自己的原因啦，的確沒有花太多的時間與精力在饅頭計畫上，也沒有與 Luka 保持聯繫，討論學習中所遇到的狀況與進度。 如果有機會再參加一次的話，應該會嘗試有沒有其他作法，把時間管理以及與進度追蹤做好，以這樣的狀態來參加饅頭計畫應該比較有意義 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 沒有將每支影片都看完，不過Luka的教學架構做的很具體，所以透過影片的標題的關鍵字，可以知道要成為網站工程師需要了解以及學習的技能有哪些;然後就是 Luka 是個很願意分享的人，剛開始有 slack 私訊以及發 PR 說明自己目前的學習狀況，Luka 會認真地分析以及指出要怎麼加強，在自學的路上有個有經驗的人可以指引方向很重要 Q: 有沒有你很想學，但是沒有學到的東西？A: 想知道後端方面所需要學習的知識與技能，以及如何與前端配合 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 參與 Luka 饅頭計畫後，覺得 Luka 是個用很用心的態度在做事的 mentor，這個計劃的發心以及構想很不錯，而且真的有人透過饅頭計畫轉職成功，其實蠻替這些人感到高興的，另一方面透過這次的經驗，發現自己在學習上屬於較被動型的，有些學習的策略是需要調整的，教練，我好想變強啊。 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-03-genie/"},{"title":"饅頭計畫 #1 學員心得 (7) Theo","text":"Q: 怎麼稱呼？A: Theo Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: backend Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A:老實說，我大多是請教Luka 關於履歷問題、面試問題應對，還有工作狀況、職涯問題XD，尤其是找工作時期有 Luka指點履歷和面試問題，糾正許多自己沒有注意到的缺點，還有比較不容易迷失求職方向，最後是剛入職時期，由於公司沒有前輩可以讓我詢問，所以都是透過 Luka 的熱心答覆，慢慢釐清自己在工作上的定位，以及職場上的心境轉換 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 熱心答覆問題，雖然偶爾話題不斷加開 Q: 有沒有你很想學，但是沒有學到的東西？A: 系統分析的流程和技巧 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我沒有時間 Q: 有沒有什麼話想對 Luka 說？A: 我是 Starbugs 忠實讀者，luka 分享的文章都有乖乖看 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-07-theo/"},{"title":"饅頭計畫 #1 學員心得 (8) Windy","text":"Q: 怎麼稱呼？A: windy Q: 你在參加饅頭計畫前是否已經是工程師？A: 是，我是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 前端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 觀念上有幫助 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 教學的方法 是適合我的 Q: 有沒有你很想學，但是沒有學到的東西？A: 目前的觀念還是很弱 我應該還是會主要在繼續把觀念搞好 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: \b抱歉，這題我 pass Q: 有沒有什麼話想對 Luka 說？A: 謝謝你願意花時間， 幫助想轉職或者觀念不好的人 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 我才不要勒","link":"/2020/09/06/mc1-08-windy/"},{"title":"饅頭計畫 #1 學員心得 (10) 昱穎","text":"Q: 怎麼稱呼？A: 昱穎 Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: \b否，我沒有變轉職成功 Q: 你目前的職業是？A: 都不是，在學前端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 我應該不算有參加到饅頭計畫XD，但我有認真看完yt的影片。yt影片錄得很生動，也重新學到很多。 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 願意很友善的這樣對陌生人XD，還有另一點是影片是從網路的教學資源去講解，讓人有資料可以跟著看，不是那種開一個畫面就開始介紹打code那種教學影片 Q: 有沒有你很想學，但是沒有學到的東西？A: 什麼都想 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 哈哈，我前幾天有跟你打招呼，不過感覺你很忙就沒打擾你了！總之很謝謝你願意跟陌生人說說話還有鼓勵，我還是會繼續學寫程式的ＸＤ。對於上面的問題我應該是還沒辦法當助教，但我想繼續參與。總之很謝謝你～！ Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-10-yu-ying/"},{"title":"饅頭計畫 #1 學員心得 (11) Trista","text":"Q: 怎麼稱呼？A: 唯 Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 前端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 我目前找到一份薪水還可以的工作，月薪四萬，重點是，我終於可以不再只是設計師，而是能透過ＪＳ控制元件的人了＾Ｏ＾（超開心）饅頭計畫中我覺得收穫最大的是自信吧，每次聚會聽跟看大家不同的想法，還有自我檢討（雖然為了賺錢沒很積極讀書），但是至少我得到了許多啟發。 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 資源，看到了很多人分享的想法，對我來說就是最大的資源。而 Luka 也給了我許多不同的觀點，這也影響到我現在對小孩學習上的投資（是個媽媽）。 Q: 有沒有你很想學，但是沒有學到的東西？A: 串接ＡＰＩ跟資料庫之類的（其實我現在做的工作就是串ＪＳＯＮ跟寫動態資料，但我不知道這叫不叫ＡＰＩ），或是前端框架大綱（發現好多公司都要會用框架的人，我目前的工作還不需要） Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 很感謝你，在我人生低谷的時候遞出了橄欖枝。 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-11-trista/"},{"title":"饅頭計畫 #1 學員心得 (12) Celine","text":"Q: 怎麼稱呼？A: Celine Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: \b否，我沒有變轉職成功 Q: 你目前的職業是？A: 前端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 用 HackMD 做筆記、寫部落格、參加相關領域社群的習慣。 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 比起外面、自己找的課程，大多是針對轉職所擬定的，但饅頭計畫是由一個真的在業的真人所引導，感覺對工程師的工作有更親近、踏實的銜接。 Q: 有沒有你很想學，但是沒有學到的東西？A: React Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！而且我已經寫好了 Q: 有沒有什麼話想對 Luka 說？A: 哈囉 Luka 好久不見！上次在台北的聚會沒辦法跟到真可惜，希望之後還能有機會～（歡迎來台南呀！）想說的事情我用條列式好了。 1. 我最近忙著一個計畫（還有製作 Podcast ），耽擱了我找工作的時間，我的作品剩下購物網站（大概進度50%），因為計畫的關係預計延後到 10 月找工作，不過我還蠻有信心的，也覺得自己學得扎實，有想要利用空閒時間更深入地探究 React（雖然真的很忙）。2. 文章我在我的 Medium 上面，那篇講述轉職的文章有一個段落在提饅頭計畫，我覺得饅頭計畫是有機體（？），所以不只把它囿於只有當初在轉職時的一部分學習，之後有工作了，還是會覺得是饅頭計畫的一份子，也會想知道 Luka 和其他成員不管有沒有轉職成功，在各自領域的後續狀況、或許將來有機會參與彼此以及討論。3. 如果是第二彈饅頭計畫，我覺得工作變強好像是不錯的路線喔！現在雜七雜八的轉職入門課太多了，好像很多人沒有想過就想說先來學程式好了。不過不管是哪種，有需要的話我都樂意擔任助教:)4. 希望可以保持聯絡，找到工作之後再通知你～ Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-12-celine/"},{"title":"饅頭計畫 #1 學員心得 (13) Sherry","text":"Q: 怎麼稱呼？A: Sherry Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 寫 Vue 的前端工程師 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 在於找工作前的那段衝刺期，除了有Luka老師的提點外，其他找到工作的學員也都很樂於分享。每週定定的計劃讓自己的進步更有明確的方向。 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 溝通語言簡單，邊講也會邊給其他建議 Q: 有沒有你很想學，但是沒有學到的東西？A: 一些工作上的實務觀念和可能面臨的問題與學習歷程 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 謝謝老師，請老師也繼續加油！ Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-13-sherry/"},{"title":"饅頭計畫 #1 學員心得 (14) Orow","text":"Q: 怎麼稱呼？A: Orow Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個人人稱羨的工程師 Q: 你目前的職業是？A: 前端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 從無到有開始學習前端，知道怎麼樣開始找資源學習，工作實務上遇到的狀況也可以持續跟mentor討論互相了解 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 依照每個人狀況不同在調整學習曲線 Q: 有沒有你很想學，但是沒有學到的東西？A: 前端各種框架、docker、測試…等等 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 饅頭計畫很棒！ Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-14-orow/"},{"title":"饅頭計畫 #1 學員心得 (15) Old Mo","text":"Q: 怎麼稱呼？A: 老莫 Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 前端為主，偶爾碰後端 Q: 你覺得饅頭計畫對你有幫助嘛？A: 有幫助，掌聲鼓勵鼓勵 Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 我沒有全程參與計畫，但我有問題就會問你，覺得在職涯能認識資深工程師還願意解惑是很好的事 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 精準回答問題 Q: 有沒有你很想學，但是沒有學到的東西？A: 後端進階應用 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我沒有時間 Q: 有沒有什麼話想對 Luka 說？A: 你好帥 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-15-old-mo/"},{"title":"饅頭計畫 #2 學員心得 (1) Phoebe","text":"Q：名字A：Phoebe Q：你在參加饅頭計畫前是否已經是工程師？A：不，我不是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：是，我成為了一個混水摸魚的工程師 Q：你目前的職業是？A：前端 Q：你覺得饅頭計畫對你有幫助嘛？(單選)A：非常有幫助，讚！ Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：改變最大的是養成了學習時寫部落格的習慣。這個習慣不僅可以幫助到自己，也幫助到別人。強迫自己產出也是饅頭計畫的一部分，而 Luka 也會針對你寫的文章給你意見，並提出許多建議，十分的用心。 Q：你覺得 Luka 教學的過程最好的地方是什麼？A：印象最深刻的是 Luka 有教大家如何提出「好」的問題。身為一個工程師，會問出好問題是非常重要的。那麼 Luka 也制定了許多規範，幫助大家問出更好的問題。Luka 也制訂一些任務，讓大家去完成。那完成之後，也會根據你做出來的東西給予意見，這些回饋都非常的寶貴。因為在剛成為 Junior 時，都會有許多的盲點，這時候就需要一位 mentor 來引導。 Q：有沒有你很想學，但是沒有學到的東西？A：TypeScript Q：有沒有什麼話想對我說？A：感謝 Luka 成立了饅頭計畫，給予當時還是學生的我許多的建議。讓我養成了良好的習慣，不管是在寫部落格，還是開發流程上，在饅頭計畫中都受益良多，讓我少走了一些彎路。期待饅頭計畫會越來越好！","link":"/2023/02/11/mc2-01-Phoebe/"},{"title":"饅頭計畫 #2 學員心得 (2) 慶慶","text":"Q：名字A：慶慶 Q：你在參加饅頭計畫前是否已經是工程師？A：不，我不是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：否，我沒有變轉職成功 Q：你目前的職業是？A：都不是 Q：你覺得饅頭計畫對你有幫助嘛？(單選)A：有幫助，掌聲鼓勵鼓勵 Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：饅頭計畫是一個對於完全沒經驗的人來說非常棒的地方，有 Luka 帶領著我們，讓我們知道有什麼東西要學什麼東西可以不用急著學，對於自學來說會比較有方向性，因為我沒有轉職成功，但其中使用 Hackmd 紀錄筆記的習慣一直保持到現在，已經習慣把學習到的知識轉化成文字去複習。你覺得 Luka 教學的過程最好的地方是什麼？最好的地方就是 Luka 知道捷徑在哪裡，知道那些技能是現在市場最需要的以及知道哪些是 HR 想看的東西，對於要轉職的人來說非常有幫助，還有每周都會跟大家開直播聊聊天，會有種朋友在陪伴你而不是導師的感覺。有沒有你很想學，但是沒有學到的東西？我那時候很想學好 vue.js，但沒有 (跟老師無關 XD) 就放棄了。 Q：有沒有什麼話想對我說？A：首先對 Luka 很抱歉，當初覺得自己轉職失敗很尷尬所以之前你請我寫的心得我就沒寫了，其實當初會放棄 100% 都是自己的原因，那時候的年底家裡有一些事情，生活壓力太大，頓時覺得自己沒什麼心再往前進，那時候負面到覺得我那麼認真想轉職讓生活變得更好，家裡的事情讓我情緒上變得很暴躁，所以最後選擇繼續在原本的工作躺平算了的想法一直出現就到了前陣子事情結束才比較好一點，其實我去年十一月開始有嘗試寫一些東西 XD 但老實說我還是不知道自己要不要轉職，所以想要嘗試寫 JAVA 跟 SQL 搭配之前學的前端搞個網站玩玩看，如果有機會再看能不能真的轉職到軟體工程的領域，因為畢竟我現在生活上經濟壓力比較大，工廠的收入比較扛的住 XD 我很怕轉職薪水差太多會扛不太住，總之很感恩你，謝謝 Luka","link":"/2023/02/08/mc2-02-qing/"},{"title":"饅頭計畫 #2 學員心得 (3) Eva","text":"Q：名字A：Eva Q：你在參加饅頭計畫前是否已經是工程師？A：不，我不是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：是，我成為了一個人人稱羨的工程師 Q：你目前的職業是？A：前端 Q：你覺得饅頭計畫對你有幫助嘛？(單選)非常有幫助，讚！ Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：1. 當時在 JS 上的學習卡關，透過課程給予 JS 觀念 以及大量實作，才開始建立起 JS 的觀念與實際運用的技巧，Q：也比較知道要如何持續精進JS以及甚至跨到框架的使用。2. 2. 在學習上比較有進度跟規劃，例如使用 github 所開任務或討論，可以依照自己的時間規劃每週應該達成的進度，或是也可以透過 github 上進行討論。 Q：你覺得 Luka 教學的過程最好的地方是什麼？A：1. 給予快速掌握新技術的方式，例如：範例實作、資料查找方式、筆記技巧、提問方法。2. 對於積極學習的學員，只要不害怕提問 Luka 都會給予回饋，對剛起步的學員來說給予極大的鼓勵以及安全感。 Q：有沒有你很想學，但是沒有學到的東西？A：1. 資料庫，在前公司偶爾會接觸後端工程師討論資料庫設計的部分，會希望可以理解，所以在會議中會稍微筆記，並學習資料庫的一些概念。2. 接下來學習方向就會依新工作需求或是未來發展方向進行，如 單元測試、react 等。 3. 後端的部分也會滿想學習，自己建立API 、資料庫並自己製作一個前後端專案（但此部分還不急）。 Q：有沒有什麼話想對我說？A：很感謝 Luka 在自己工作後或轉換工作，有技術或方向問題的詢問都願意給予回覆。另外，若未來有需要協助的地方，時間允許下，我也樂意參與喔！","link":"/2023/01/30/mc2-03-eva/"},{"title":"饅頭計畫 #2 學員心得 (4) 鈺涵","text":"Q：名字A：鈺涵 Q：你在參加饅頭計畫前是否已經是工程師？A：不，我不是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：否，因為人生選擇我沒有選擇成為工程師 Q：你目前的職業是？A：仍然是設計師阿哈哈哈啊哈 Q：你覺得饅頭計畫對你有幫助嘛？(單選)A：有幫助，掌聲鼓勵鼓勵 Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：讓我了解工程師部分生態以及如何努力!雖然基於種種理由最後沒有轉職成功=_=但還是十分感謝饅頭哥的教誨XD Q：你覺得 Luka 教學的過程最好的地方是什麼？A：很好笑…………. Q：有沒有你很想學，但是沒有學到的東西？A：因為中斷了所以這一題無解……….你願意寫篇心得記錄饅頭計畫的過程嘛？我願意！但我需要一點時間有沒有什麼話想對我說？謝謝你= =下次回台灣我要請你吃飯XD","link":"/2023/01/29/mc2-04-yuha/"},{"title":"饅頭計畫 #2 學員心得 (5) Michael","text":"Q：名字A：Michael Q：你在參加饅頭計畫前是否已經是工程師？A：不，我不是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：是，我成為了一個混水摸魚的工程師 Q：你目前的職業是？A：前端 Q：你覺得饅頭計畫對你有幫助嘛？(單選)A：非常有幫助，讚！ Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：讓我面對難題時，能夠冷靜有邏輯地解決問題你覺得 Luka 教學的過程最好的地方是什麼？有條理地拆解問題，以及引導解決問題的方向 Q：有沒有你很想學，但是沒有學到的東西？A：沒有 Q：有沒有什麼話想對我說？A：很感謝你的教導！","link":"/2023/01/28/mc2-05-michael/"},{"title":"饅頭計畫 #2 學員心得 (6) Shawn","text":"Q：名字A：Shawn Q：你在參加饅頭計畫前是否已經是工程師？A：不，我不是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：是，我成為了一個混水摸魚的工程師 Q：你目前的職業是？A：python相關工程師 Q：你覺得饅頭計畫對你有幫助嘛？(單選)A：有幫助，掌聲鼓勵鼓勵 Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：主要是學習方式,將學習的知識轉化為筆記並進一步建立成部落格，紀錄學習歷程，這點滿重要的，也因為學習筆記，對我進入現在公司有滿大的加分，至今也仍然使用此方式在學習. Q：你覺得 Luka 教學的過程最好的地方是什麼？A：陪伴你一路轉職，會幫你盯進度，雖然我屬於那種丟了履歷莫名找到工作的，但還是謝謝Luka前期的密集盯哨與陪伴！ Q：有沒有你很想學，但是沒有學到的東西？A：目前還好 Q：有沒有什麼話想對我說？A：謝謝Luka,覺得這樣的計劃非常有意義，也因為這個計畫認識了其他轉職夥伴，可以互相交流","link":"/2023/01/28/mc2-06-Shawn/"},{"title":"饅頭計畫 #2 學員心得 (7) Lily","text":"Q：名字A：Lily Q：你在參加饅頭計畫前是否已經是工程師？A：是，我是工程師 Q：在饅頭計畫後你是否變成了一位工程師？A：是，我成為了一個人人稱羨的工程師 Q：你目前的職業是？A：前端 Q：你覺得饅頭計畫對你有幫助嘛？(單選)A：非常有幫助，讚！ Q：如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A：感謝 Luka 的耐心協助，指點該如何準備面試，撰寫履歷（很多時候真的不理解到底該怎麼執行，Luka 可以在下班後那麼多事情的情況下願意幫忙，真的很感動），後來也順利拿到薪水更高的 offer。 Q：你覺得 Luka 教學的過程最好的地方是什麼？A：很有耐心、會指點方向讓學員主動學習，而不是直接提供答案 Q：你覺得 Luka 教學的過程最好的地方是什麼？A：pipeline 運作吧 Q：有沒有什麼話想對我說？A：Hi 教練，新年快樂啊～","link":"/2023/01/27/mc2-07-lily/"},{"title":"饅頭計畫 #1 學員心得 (9) Phoenix","text":"Q: 怎麼稱呼？A: Phoenix Q: 你在參加饅頭計畫前是否已經是工程師？A: 不，我不是工程師 Q: 在饅頭計畫後你是否變成了一位工程師？A: 是，我成為了一個混水摸魚的工程師 Q: 你目前的職業是？A: 後端，前端碰的較少 Q: 你覺得饅頭計畫對你有幫助嘛？A: 非常有幫助，讚！ Q: 如果有幫助的話，請說說饅頭計畫帶給你的改變，如果對你的改變很大，請盡可能詳述，反之，填無即可A: 我找到工作了 雖然我是離開工程師一年後再踏上工程師的路，當時的確忘了很多基本觀念，加上前一份工程師的工作使用較舊的技術，經過這次饅頭計畫，創照這樣的環境，跟著大家一起努力，一起成長。 過程中除了技術的成長外，也會在過程中給予我們工程師該有的知識與養成的一些習慣 Q: 你覺得 Luka 教學的過程最好的地方是什麼？A: 耐心教學，很願意教我們這點已經夠讓人敬佩了 Q: 有沒有你很想學，但是沒有學到的東西？A: 其實前後端知識都蠻有興趣的，想要一條往 senior 路上必備的知識想把前端弄好一個框架，react 或 vue 都好後端太博大精深了，有點不知道從何學起，或只能遇到問題在去學習了 Q: 你願意寫篇文章記錄饅頭計畫的過程嘛？A: 我願意！但我需要一點時間 Q: 有沒有什麼話想對 Luka 說？A: 很謝謝你在我當時迷茫低潮害怕的時候給予勇氣，勇敢踏出那一步不知道之後會不會有前進senior之路的教學 Q: 如果有饅頭計畫第二彈，你願意擔任助教嘛？A: 有興趣","link":"/2020/09/06/mc1-09-phoenix/"},{"title":"【 Python 資料科學 】書籍推薦","text":"Data Science from Scratch 中文版（第二版）：用 Python 學資料科學 這本裡面有大量的名詞幫，適合當工具書來查詢，硬啃的話有點累。名詞如下： 資料視覺化, 線性代數, 統計學, 機率, 假設與推論, 梯度遞減, 取得資料, 處理資料, 機器學習, k最近鄰, 單純貝氏, 簡單線性迴歸, 多元迴歸, 邏輯迴歸, 決策樹, 神經網路, 深度學習, 集群, 自然語言處理, 網路分析, 推薦系統, 資料庫與SQL, MapReduce Python資料分析 第二版 這本是 pandas 的作者寫的書，本書重點在於使用 pandas 與 NumPy 進行資料載入、資料前處理、資料處理、資料視覺化 … 等等的步驟。如果想要學習完整的流程挺推薦。 Python資料科學學習手冊 本書分為五個章節，從資料科學開始介紹，接著介紹常用的 IPython、NumPy、Pandas 資料處理、Matplotlib 資料視覺化、最後介紹 Sckit-Learn 來學習機器學習。非常完整的介紹資料科學的流程。 參考資料[分享] 2020 推薦 Python資料科學的書","link":"/2021/11/25/python/01-data-science-book/"},{"title":"【 Python 教學 】什麼是 PyPI？跟 pip 又有什麼關係呢？","text":"什麼是 PyPI？ PyPI（英語 Package Index，簡稱PyPI），是 的官方的第三方套件儲存庫。 如果用生活的例子來比喻，就像 Android 手機，有 google play 可以安裝軟體。iphone 有 app store 來安裝軟體。在這之中 PyPI 就像是 google play 或是 app store. 在我們使用 pip 安裝套件的時候，下指令 pip install 套件名稱 預設就是從 PyPI 下載套件。 在 PyPI 上搜尋套件官方網站 我們試著搜尋 web 框架 flask 。看到第一個就是搜尋結果，後方的日期是更新的時間。 點擊進去之後，就可以看到 Flask 的介紹，還有貼心的教學， 在指令列輸入 pip install flask 即可安裝。 在 PyPI 上查看簡易介紹下方還有簡單的範例，不過因為這些套件是第三方 (Third-Party) 維護，也就是開發套件的人是自主開發的，因此我們需要到各自的官網看詳細教學。 在 PyPI 找到套件的官方網站，查看詳細文件所以我們點擊 documentation 就可以進入到 Flask 的官方網站，最詳盡的文件可以在這邊找到。 PyPI 跟 pip 有什麼關係呢？最後我們來回答標題上的第二個問題，PyPI 跟 pip 的關係，剛剛在操作過程已經知道了。pip install 某某套件 預設的官方套件商店就是 PyPI。 總結今天介紹的是從 PyPI 官方網站搜尋到需要的套件 (Flask)，然後使用指令安裝需要的套件，最後是如何查詢 Flask 的使用方式。","link":"/2021/11/27/python/02-what-is-pypi/"},{"title":"【 Python 冷知識 】你知道 PyPI 怎麼唸嘛？","text":"撰寫另一篇文章 【 Python 教學 】什麼是 PyPI？跟 pip 又有什麼關係呢？的時候，發現 PyPI 的時候，產生了一個疑問，PyPI該怎麼唸？ 可能的答案有： 拍拍 批歪批唉 批批 拍批埃 究竟是哪一個，你念對了嘛？答案在下方教學影片： How to pronounce PyPI (beginner) Anthony explains #020 - YouTube","link":"/2021/11/29/python/03-how-to-pronounce-pypi/"},{"title":"【 Python 教學 】enumerate 函式介紹","text":"Python 的 enumerate() 函式是一個非常有用的工具，特別是在處理迴圈時。這個函式可以將一個可迭代的對象（如列表、元組或字串）轉換為索引序列，同時列出資料和資料對應的索引值。這使得在迴圈中同時獲得元素和其對應索引變得簡單。 基本用法enumerate() 函式的基本語法是 enumerate(iterable, start=0)。其中，iterable 是一個可迭代物件，如列表、元組、字串等。start 是可選參數，用來指定索引值的起始值，預設為 0。 假設有一個列表：fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]。使用 enumerate() 函式，可以這樣遍歷列表： 12for index, fruit in enumerate(fruits): print(index, fruit) 這將輸出： 1230 apple1 banana2 cherry 如果指定 start 參數，例如 enumerate(fruits, start=1)，則索引將從 1 開始計數。 使用範例列表 (List)假設我們有一個包含數字的列表，我們想要列印出每個數字及其索引： 123numbers = [10, 20, 30, 40, 50]for index, number in enumerate(numbers): print(f&quot;Index: {index}, Number: {number}&quot;) 輸出將是： 12345Index: 0, Number: 10Index: 1, Number: 20Index: 2, Number: 30Index: 3, Number: 40Index: 4, Number: 50 元組 (Tuple)元組也可以使用 enumerate()。例如，我們有一個包含幾個城市名稱的元組： 123cities = (&quot;Taipei&quot;, &quot;Kaohsiung&quot;, &quot;Taichung&quot;)for index, city in enumerate(cities): print(f&quot;Index: {index}, City: {city}&quot;) 輸出將是： 123Index: 0, City: TaipeiIndex: 1, City: KaohsiungIndex: 2, City: Taichung 字串 (String)對於字串，enumerate() 可以幫助我們獲得每個字元及其索引： 123text = &quot;Hello&quot;for index, char in enumerate(text): print(f&quot;Index: {index}, Character: {char}&quot;) 輸出將是： 12345Index: 0, Character: HIndex: 1, Character: eIndex: 2, Character: lIndex: 3, Character: lIndex: 4, Character: o 字典 (Dictionary)雖然字典不是傳統意義上的序列，但我們仍然可以使用 enumerate() 來迭代它的鍵： 123info = {&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;}for index, key in enumerate(info): print(f&quot;Index: {index}, Key: {key}, Value: {info[key]}&quot;) 輸出將是： 123Index: 0, Key: name, Value: JohnIndex: 1, Key: age, Value: 30Index: 2, Key: city, Value: New York 在這些例子中，enumerate() 函式為我們提供了一種簡潔且高效的方式來迭代各種類型的可迭代物件，同時獲取它們的索引和值。 心得Python 的 enumerate() 函式是處理迴圈和可迭代物件時的一個強大工具，它提高了程式碼的可讀性和效率。使用 enumerate() 的主要優點是它提供了一種簡潔的方式來獲取索引，並且比使用 range() 和 len() 組合更為直觀和高效。它使程式碼更加清晰，易於理解和維護。","link":"/2023/12/04/python/enumerate/"},{"title":"【 Flask 教學 】Hello, Flask！五分鐘建立你的第一個 Flask 應用","text":"輕量型 Web 框架 - Flask Flask 是一款 Python 的網頁開發框架。它的特色就是輕巧。Flask 的官方網站用 Micro 這個字來說明 Flask 的設計哲學。 Micro 意味著，一開始什麼都沒有，沒有資料庫，沒有好用的表單工具，Flask 就提供給你一個非常非常精簡的 Web 框架。 如果你需要資料庫功能，那麼你需要找尋套件，例如：你想要連接 MySQL 的話，需要安裝 Flask-SQLAlchemy 套件，來擴展你的 Flask 應用程式。 這跟 Python 中另一個主流框架，Django 大相逕庭。然而 Flask 與 Django 的市占率大概 50% vs 50%，非常有趣，意味著各有各的擁護者。 瞭解了 Flask 的設計哲學後，接下來我們實作的 Hello World 應用程式，便是只有提供網頁功能，並且只有「一個檔案」的迷你專案。 Hello Flask！初學程式的時候發現一個奇特的現象，為什麼第一個程式要輸出 Hello World 呢？因為我們第一件事情就是要確保環境能夠正確執行。 安裝 Flask使用 pip 安裝 Flask 1pip install flask 組織專案結構安裝完成之後，我們先建立一個乾淨的資料夾命名為 hello_flask。接著在裡面建立一個新檔案命名為 hello.py所以現在我們的專案結構是 hello_flask 資料夾底下，有一個 hello.py 的檔案 12hello_flask└── hello.py 接著我們編輯 hello.py 的內容，將以下內容撰寫上檔案 1234567891011from flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def hello_world(): return &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;if __name__ == '__main__': app.run(port=5000) 在本地端運行接著下列指令， 12export FLASK_APP=helloflask run 就會發現終端機的畫面，Flask Server (伺服器)已經開始在你的本地開發環境，也就是你的電腦上面運轉囉！ 此時我們複製終端機上的顯示的網址 http://127.0.0.1:5000/ 到瀏覽器上，打開便會看到 Hello World！。 先讓程式跑起來，接下來我們才可以嘗試各式各樣的開發。 參考資料 Flask 官方網站 實作一個簡單的 Flask 入門 | Max行銷誌","link":"/2021/11/29/python-flask/01-hello-flask/"},{"title":"【 Flask 教學 】五分鐘學會 Flask 中的 GET, POST, PUT, PATCH, DELETE","text":"本文詳細講解如何在 Flask 中使用 HTTP 請求方法，包括 GET、POST、PUT、PATCH 和 DELETE。文章介紹每種請求方法的用途和使用方法，並提供了相應的程式碼範例，使讀者能夠更好地理解如何在 Flask 中使用這些請求方法。本文適合初學者閱讀，可快速了解 Flask 中 HTTP 請求方法的基本使用方法。 GET 請求GET 請求用於從伺服器獲取資料。在 Flask 中，使用 GET 請求非常簡單。以下是一個簡單的範例，使用 GET 請求從伺服器獲取資料： 12345678from flask import Flask, jsonifyapp = Flask(__name__)@app.route('/data', methods=['GET'])def get_data(): data = {'name': 'Alice', 'age': 25} return jsonify(data) 在這個範例中，我們使用 Flask 的 @app.route 裝飾器來指定路由，其中 methods=['GET'] 指定了使用 GET 請求。我們定義了一個 get_data 函數，返回一個包含 name 和 age 屬性的 JSON Response。 POST 請求POST 請求用於向伺服器提交資料。在 Flask 中，使用 POST 請求同樣非常簡單。以下是一個範例，使用 POST 請求提交表單資料： 12345678910from flask import Flask, request, jsonifyapp = Flask(__name__)@app.route('/data', methods=['POST'])def post_data(): name = request.form['name'] age = request.form['age'] data = {'name': name, 'age': age} return jsonify(data) 在這個範例中，我們同樣使用 @app.route 裝飾器指定路由和請求方法。我們定義了一個 post_data 函數，使用 request.form 獲取提交的表單資料，然後將資料封裝成 JSON Response返回。 PUT 請求PUT 請求用於更新伺服器上的資料。在 Flask 中，使用 PUT 請求也很簡單。以下是一個範例，使用 PUT 請求更新一條記錄： 1234567891011from flask import Flask, request, jsonifyapp = Flask(__name__)data = {'name': 'Alice', 'age': 25}@app.route('/data/&lt;name&gt;', methods=['PUT'])def put_data(name): age = request.form['age'] data[name] = age return jsonify(data) 在這個範例中，我們使用了 URL 參數 &lt;name&gt; 來指定要更新的記錄。我們定義了一個 put_data 函數，使用 request.form 獲取新的年齡資料，並將資料更新到 data 字典中。 PATCH 請求PATCH 請求用於部分更新伺服器上的資料。在 Flask 中，使用 PATCH 請求同樣很簡單。以下是一個範例，使用 PATCH 請求部分更新一條記錄： 1234567891011from flask import Flask, request, jsonifyapp = Flask(__name__)data = {'name': 'Alice', 'age': 25}@app.route('/data/&lt;name&gt;', methods=['PATCH'])def patch_data(name): age = request.form['age'] data[name]['age'] = age return jsonify(data) 在這個範例中，我們同樣使用 URL 參數 &lt;name&gt; 來指定要更新的記錄。我們定義了一個 patch_data 函數，使用 request.form 獲取新的年齡資料，並將資料部分更新到 data 字典中。 DELETE 請求DELETE 請求用於刪除伺服器上的資料。在 Flask 中，使用 DELETE 請求同樣非常簡單。以下是一個範例，使用 DELETE 請求刪除一條記錄： 12345678910from flask import Flask, jsonifyapp = Flask(__name__)data = {'name': 'Alice', 'age': 25}@app.route('/data/&lt;name&gt;', methods=['DELETE'])def delete_data(name): del data[name] return jsonify(data) 在這個範例中，我們同樣使用 URL 參數 &lt;name&gt; 來指定要刪除的記錄。我們定義了一個 delete_data 函數，使用 Python 的 del 語句從 data 字典中刪除指定的記錄，並將更新後的資料封裝成 JSON Response返回。","link":"/2023/02/11/python-flask/02-routes/"},{"title":"【 Flask 教學 】Flask SQLAlchemy | Python 與資料庫的橋樑","text":"在本篇文章，我們將介紹 Flask-SQLAlchemy，讓我們能夠在 Python Flask 應用程式中使用 SQLAlchemy 的 ORM 和 Flask-SQLAlchemy 進行資料庫溝通。 Flask 是一個輕量級的 Python Web 框架，用於建立 Web 應用程式，而 SQLAlchemy 則是一個 Python 庫，提供對關係資料庫的高效和高效能的訪問。 Flask-SQLAlchemy 是一個用於 Flask 應用程式的擴展程式，簡化了使用 SQLAlchemy 的複雜性，並提供了常見的對象和模式，例如與每個 Web 請求相關聯的會話、模型和引擎，同時不會更改 SQLAlchemy 的工作方式。 下面我們來看看如何在 Python Flask 應用程式中使用 Flask-SQLAlchemy。 安裝 Flask-SQLAlchemy要使用 Flask-SQLAlchemy，首先需要在計算機上安裝它。可以使用以下命令在終端中安裝 Flask-SQLAlchemy： 1pip install Flask-SQLAlchemy 建立 Flask 應用程式 在使用 Flask-SQLAlchemy 之前，需要建立一個 Flask 應用程式。可以使用以下程式碼建立一個簡單的 Flask 應用程式： 12from flask import Flaskapp = Flask(__name__) 設定資料庫 在 Flask-SQLAlchemy 中，可以使用 PostgreSQL、MySQL、SQLite 或 Oracle 等多種資料庫。在本節中，我們將使用 SQLite3 作為資料庫。可以使用以下程式碼設定資料庫： 123from flask_sqlalchemy import SQLAlchemyapp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///example.db'db = SQLAlchemy(app) 上述程式碼將建立一個名為 example.db 的 SQLite3 資料庫。 建立資料庫模型在 Flask-SQLAlchemy 中，資料庫模型由 Python Class定義。以下是一個簡單的範例： 1234567class User(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(80), nullable=False) email = db.Column(db.String(120), unique=True, nullable=False) def __repr__(self): return '&lt;User %r&gt;' % self.username 上述程式碼定義了一個名為 User 的模型，包含三個屬性：id、name 和 email。 建立資料庫表在Flask-SQLAlchemy 中，可以使用以下程式碼建立資料庫表： 1db.create_all() 上述程式碼將根據模型定義建立資料庫表。 添加資料到資料庫在 Flask-SQLAlchemy 中，可以使用以下程式碼向資料庫添加資料： 123user = User(name='John Doe', email='johndoe@example.com')db.session.add(user)db.session.commit() 上述程式碼將建立一個新的 User 對象，將其添加到資料庫中，並提交更改。 從資料庫檢索資料在 Flask-SQLAlchemy 中，可以使用以下程式碼從資料庫檢索資料： 1users = User.query.all() 上述程式碼將檢索資料庫中的所有 User 對象，並將它們作為列表返回。 更新資料庫中的資料在 Flask-SQLAlchemy 中，可以使用以下程式碼更新資料庫中的資料： 123user = User.query.filter_by(email='johndoe@example.com').first()user.name = 'John'db.session.commit() 上述程式碼將從資料庫中檢索具有指定電子郵件地址的 User 對象，將其名稱更改為 John，然後提交更改。 刪除資料庫中的資料在 Flask-SQLAlchemy 中，可以使用以下程式碼從資料庫中刪除資料： 123user = User.query.filter_by(email='johndoe@example.com').first()db.session.delete(user)db.session.commit() 上述程式碼將從資料庫中刪除具有指定電子郵件地址的 User 對象，然後提交更改。 小節綜上所述，本篇教學文章介紹了 Flask-SQLAlchemy 的基本用法，包括建立 Flask 應用程式、設定資料庫、建立資料庫模型、建立資料庫表、添加資料到資料庫、從資料庫檢索資料、更新資料庫中的資料和刪除資料庫中的資料。這些步驟提供了初學者所需的基礎知識，可以用來構建簡單的 Python Flask 應用程式，以及進一步擴展以實現更複雜的資料庫操作。需要注意的是，Flask-SQLAlchemy 需要一定的學習曲線，但一旦掌握了基本概念，就可以輕鬆地使用它來管理資料庫。 希望本篇教學文章能夠為初學者提供一個良好的起點，幫助他們進入 Flask-SQLAlchemy 的世界，並開始在 Python Flask 應用程式中進行資料庫溝通。 延伸閱讀以下是本次回答所使用的參考資料的標題和連結： Flask-SQLAlchemy 快速入門 和 Flask-SQLAlchemy 快速入門：兩篇 Flask-SQLAlchemy 的快速入門指南，介紹了 Flask-SQLAlchemy 的基本用法，是初學者快速入門 Flask-SQLAlchemy 的好資源。 如何在 Flask 應用程式中使用 SQLAlchemy 進行資料庫 ：這篇教學透過一個小型的學生管理系統展示了如何使用 Flask-SQLAlchemy 擴展來完成基本的資料庫溝通，如連接到資料庫伺服器、建立資料庫表、添加資料、檢索資料、更新資料和刪除資料等操作。 如何使用 Flask Blueprints 和 Flask-SQLAlchemy 構建大型 Flask 應用程式的結構：這篇教學詳細介紹了如何使用 Flask 藍圖和 Flask-SQLAlchemy 構建大型 Flask 應用程式的架構。本文提供了範例程式碼和詳細的解釋，是進階學習 Flask-SQLAlchemy 的好資源。 Flask-SQLAlchemy 文件：Flask-SQLAlchemy 的官方文件，提供了完整的 API 參考、常見問題解答和高級主題等內容。無論你是初學者還是經驗豐富的 Python 開發者，都可以在這裡找到所需的資訊。 Flask SQLAlchemy (with Examples)：這是一篇包含範例的教學，介紹了如何使用 Flask-SQLAlchemy 建立和操作資料庫表。本文包含了範例程式碼和詳細的解釋，是初學者快速掌握 Flask-SQLAlchemy 的好資源。 使用 Flask 和 SQLAlchemy 建立一個基本的 CRUD 應用程式：這篇","link":"/2023/02/13/python-flask/03-relational-database/"},{"title":"【 Flask 教學 】Flask Factory 介紹","text":"Flask 是一個輕量的 Python 網頁應用框架，因為它簡單易用而廣受歡迎。其中，Flask Factory 是一個新的概念，可以更加靈活地建立 Flask 應用程式。本文將介紹 Flask Factory 的概念以及如何在 Flask 應用程式中使用它。 Flask Factory 是什麼？在傳統的 Flask 應用程式中，我們會在一個檔案中建立 Flask 應用程式物件，然後將它與路由和視圖函式一起定義在同一個檔案中。然而，這種方式的維護和擴展性很差。Flask Factory 的概念就是將 Flask 應用程式物件的建立和設定分離出來，以便更靈活地管理 Flask 應用程式。 Flask Factory 通常會分為三個部分： 工廠函式：這是建立 Flask 應用程式物件的函式，通常是一個叫做 create_app 的函式。這個函式會負責建立 Flask 應用程式物件、設定 Flask 應用程式以及註冊路由和視圖函式。 設定：這是 Flask 應用程式的設定，可以使用 Python Class 或字典來定義。 視圖函式：這些是處理路由的函式，通常是一個或多個藍圖。 如何在 Flask 中使用工廠？以下是一個簡單的 create_app 工廠函式範例： 1234567891011from flask import Flaskdef create_app(): app = Flask(__name__) app.config['DEBUG'] = True @app.route('/') def hello_world(): return 'Hello, World!' return app 在上面的範例中，create_app 函式建立了一個 Flask 應用程式物件，並定義了一個路由和一個視圖函式。此外，它還設定了 DEBUG 設定選項，以便在偵錯模式下執行應用程式。 這個工廠函式可以在另一個檔案中被呼叫，並使用以下程式碼啟動應用程式： 1234from myapp import create_appapp = create_app()app.run() 在上面的範例中，create_app 函式在另一個名為 myapp 的模組中定義，然後被呼叫以建立 Flask 應用程式物件。然後，run 方法啟動了應用程式。 除了上面的範例，我們還可以使用工廠函式來建立複雜的 Flask 應用程式。例如，我們可以使用藍圖來組織視圖函式，使用 Flask 插件來擴展應用程式功能，等等。 以下是一個更複雜的工廠函式範例： 123456789101112131415from flask import Flaskfrom myapp.views import main_bp, admin_bpfrom myapp.extensions import db, login_managerdef create_app(config_object): app = Flask(__name__) app.config.from_object(config_object) db.init_app(app) login_manager.init_app(app) app.register_blueprint(main_bp) app.register_blueprint(admin_bp, url_prefix='/admin') return app 在上面的範例中，create_app 函式建立了一個 Flask 應用程式物件，並使用 config_object 設定來設定應用程式。它還初始化了一些 Flask 插件，如 db 和 login_manager，並將它們與應用程式關聯起來。最後，它註冊了兩個藍圖 main_bp 和 admin_bp，這些藍圖包含不同的視圖函式。 這個工廠函式可以在另一個檔案中被呼叫，並使用以下程式碼啟動應用程式： 12345from myapp import create_appfrom myapp.config import ProductionConfigapp = create_app(ProductionConfig)app.run() 在上面的範例中，create_app 函式在 myapp 模組中定義，然後使用 ProductionConfig 設定物件建立 Flask 應用程式物件。然後，run 方法啟動了應用程式。 總結一下，Flask Factory 是一個有用的概念，可以使我們更加靈活地建立和管理 Flask 應用程式。通過將建立 Flask 應用程式物件的過程分離出來，我們可以更輕鬆地進行擴展和維護。如果你還沒有嘗試過 Flask Factory，我們建議你嘗試一下，體驗一下其帶來的好處。","link":"/2023/02/15/python-flask/04-flask-factory/"},{"title":"【 Flask 教學 】用 Flask Blueprint 組織程式碼","text":"Flask Blueprint 組織程式碼的幾種方式Blueprint 是一個用於標示架構和組織軟體專案的概念。在這裡，我們將探討三種不同的專案組織方式：單一應用程式、模組化應用程式，以及使用 Flask Blueprint 的應用程式。以下是這三種組織方式的程式範例： 按功能劃分藍圖在這種組織方式中，我們根據應用程式的功能劃分藍圖。這個範例包含了一個簡單的 Flask 應用程式，使用了按功能劃分的 Blueprint 組織方式。應用程式有兩個功能模塊：身份驗證（auth）和文章（posts）。每個模塊都有自己的視圖和模板。在 app.py 中，我們註冊了兩個藍圖：auth_blueprint 和 posts_blueprint。 目錄結構： 12345678910111213myproject/ ├── auth/ │ ├── __init__.py │ ├── views.py ├── posts/ │ ├── __init__.py │ ├── views.py ├── templates/ │ ├── auth/ │ │ ├── login.html │ ├── posts/ │ │ ├── list.html └── app.py app.py： 12345678910from flask import Flaskfrom auth.views import auth_blueprintfrom posts.views import posts_blueprintapp = Flask(__name__)app.register_blueprint(auth_blueprint)app.register_blueprint(posts_blueprint)if __name__ == '__main__': app.run() auth/init.py： 1# 空文件 auth/views.py： 1234567from flask import Blueprint, render_templateauth_blueprint = Blueprint('auth', __name__, template_folder='templates/auth')@auth_blueprint.route('/login')def login(): return render_template('auth/login.html') templates/auth/login.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Login Page&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; posts/init.py： 1# 空文件 posts/views.py： 1234567from flask import Blueprint, render_templateposts_blueprint = Blueprint('posts', __name__, template_folder='templates/posts')@posts_blueprint.route('/posts')def list_posts(): return render_template('posts/list.html') templates/posts/list.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Posts&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Posts List&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 按角色劃分藍圖在這種組織方式中，我們根據不同的使用者角色（如管理員、使用者…等）劃分藍圖。這樣可以讓應用程式的不同角色有各自的功能界面和邏輯。以下是按角色劃分 Blueprint 的簡單範例： 目錄結構： 12345678910111213myproject/ ├── admin/ │ ├── __init__.py │ ├── views.py ├── user/ │ ├── __init__.py │ ├── views.py ├── templates/ │ ├── admin/ │ │ ├── dashboard.html │ ├── user/ │ │ ├── profile.html └── app.py app.py： 12345678910from flask import Flaskfrom admin.views import admin_blueprintfrom user.views import user_blueprintapp = Flask(__name__)app.register_blueprint(admin_blueprint, url_prefix='/admin')app.register_blueprint(user_blueprint, url_prefix='/user')if __name__ == '__main__': app.run() admin/init.py： 1# 空文件 admin/views.py： 1234567from flask import Blueprint, render_templateadmin_blueprint = Blueprint('admin', __name__, template_folder='templates/admin')@admin_blueprint.route('/dashboard')def dashboard(): return render_template('admin/dashboard.html') templates/admin/dashboard.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Admin Dashboard&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Admin Dashboard&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; user/init.py： 1# 空文件 user/views.py： 1234567from flask import Blueprint, render_templateuser_blueprint = Blueprint('user', __name__, template_folder='templates/user')@user_blueprint.route('/profile')def profile(): return render_template('user/profile.html') templates/user/profile.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;User Profile&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;User Profile&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 第一個範例按照角色劃分，有 admin 和 user 兩個角色，每個角色有對應的視圖和模板。這些範例分別展示了按角色劃分和按資源劃分的兩種 Flask Blueprint 組織方式。 按資源類型劃分藍圖：在這種組織方式中，我們根據應用程式中的資源類型（如文章、評論等）劃分藍圖。這樣可以讓程式碼更具模組化，便於維護和擴展。在 app.py 中，我們註冊了相應的藍圖。 目錄結構： 12345678910111213myproject/ ├── posts/ │ ├── __init__.py │ ├── views.py ├── comments/ │ ├── __init__.py │ ├── views.py ├── templates/ │ ├── posts/ │ │ ├── list.html │ ├── comments/ │ │ ├── list.html └── app.py app.py： 12345678910from flask import Flaskfrom posts.views import posts_blueprintfrom comments.views import comments_blueprintapp = Flask(__name__)app.register_blueprint(posts_blueprint, url_prefix='/posts')app.register_blueprint(comments_blueprint, url_prefix='/comments')if __name__ == '__main__': app.run() posts/init.py： 1# 空文件 posts/views.py： 1234567from flask import Blueprint, render_templateposts_blueprint = Blueprint('posts', __name__, template_folder='templates/posts')@posts_blueprint.route('/')def list_posts(): return render_template('posts/list.html') templates/posts/list.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Posts&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Posts List&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; comments/init.py： 1# 空文件 comments/views.py： 1234567from flask import Blueprint, render_templatecomments_blueprint = Blueprint('comments', __name__, template_folder='templates/comments')@comments_blueprint.route('/')def list_comments(): return render_template('comments/list.html') templates/comments/list.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Comments&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Comments List&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 比較三種方案下表對比了使用 Flask Blueprint 組織程式碼的三種方式的優缺點： 方式 優點 缺點 按功能劃分藍圖 功能模塊清晰 功能模塊過多時結構可能變得複雜 有利於專案的擴展性和可維護性 按角色劃分藍圖 便於實現角色之間的隔離和權限控制 角色之間存在相似功能時可能導致程式碼重複 有利於專案的擴展性和可維護性 按資源類型劃分藍圖 程式碼具有高度模組化 資源之間有相互依賴時可能需要更多的協調和溝通 便於維護和擴展 在選擇組織方式時，應該根據專案的需求和規模來決定。有時候，可以將這些組織方式結合使用，以便更好地滿足專案需求。 混合使用綜合以上三種使用 Flask Blueprint 的程式碼組織方式，開發者可以根據專案需求靈活選擇或混合應用。在實際應用中，專案可能需要更細緻的組織結構，此時可以將多種組織方式結合起來，以便更好地滿足需求。 例如，我們可以根據應用程式的功能和資源類型同時劃分藍圖： 1234567891011121314151617181920212223242526272829303132333435myproject/ ├── auth/ │ ├── __init__.py │ ├── views.py ├── admin/ │ ├── posts/ │ │ ├── __init__.py │ │ ├── views.py │ ├── images/ │ │ ├── __init__.py │ │ ├── views.py ├── user/ │ ├── posts/ │ │ ├── __init__.py │ │ ├── views.py │ ├── comments/ │ │ ├── __init__.py │ │ ├── views.py ├── templates/ │ ├── auth/ │ │ ├── login.html │ │ ├── register.html │ ├── admin/ │ │ ├── posts/ │ │ │ ├── manage_posts.html │ │ ├── images/ │ │ │ ├── manage_images.html │ ├── user/ │ │ ├── posts/ │ │ │ ├── list.html │ │ │ ├── detail.html │ │ ├── comments/ │ │ │ ├── list.html │ │ │ ├── new_comment.html └── app.py 在這個範例中，我們同時根據功能（身份驗證、管理員、使用者）和資源類型（文章、圖片、評論）劃分藍圖。這樣可以使程式碼更具模組化，便於維護和擴展。同時，不同角色的功能和權限也得到了清晰的區分。","link":"/2023/02/16/python-flask/05-flask-blueprint/"},{"title":"【 Flask 教學 】如何在 Flask 設置和操作 Cookie","text":"在 Python Flask 中，cookie 是一種儲存在使用者瀏覽器中的小型資料塊。通常情況下，我們使用 cookie 來記錄使用者的首選設定、登錄資料以及其他與使用者相關的資訊。在 Flask 應用程式中，使用 cookie 的過程非常簡單。 設置 cookie要在 Flask 中設置 cookie，我們需要使用 response 物件的 set_cookie() 方法。這個方法接受以下參數： key：cookie 的名稱，必須是一個字符串 value：cookie 的值，必須是一個字符串，默認為空字符串 max_age：cookie 的存活時間，以秒為單位，默認為 None 以下是一個簡單的 Flask 應用程式，演示如何設置 cookie： 123456789from flask import Flask, make_responseapp = Flask(__name__)@app.route('/')def index(): resp = make_response('Setting a cookie!') resp.set_cookie('my_cookie', 'my_value') return resp 在上面的程式碼中，我們建立了一個名為 my_cookie 的 cookie，其值為 my_value。當使用者訪問該頁面時，他們的瀏覽器將接收到這個 cookie。 讀取 cookie要讀取 cookie，我們可以使用 request 物件的 cookies 屬性。這個屬性是一個字典，其中包含了所有使用者瀏覽器中的 cookie。以下是一個簡單的 Flask 應用程式，演示如何讀取 cookie： 12345678from flask import Flask, requestapp = Flask(__name__)@app.route('/')def index(): my_cookie = request.cookies.get('my_cookie') return f'The value of my_cookie is {my_cookie}' 在上面的程式碼中，我們使用 request.cookies.get() 方法讀取名為 my_cookie 的 cookie。如果該 cookie 存在，它的值將被存儲在 my_cookie 變數中。否則，my_cookie 將為 None。 刪除 cookie要刪除 cookie，我們只需要設置 cookie 的 max_age 參數為 0。以下是一個簡單的 Flask 應用程式，演示如何刪除 cookie： 123456789from flask import Flask, make_responseapp = Flask(__name__)@app.route('/')def index(): resp = make_response('Deleting a cookie!') resp.set_cookie('my_cookie', '', max_age=0) return resp 在上面的程式碼中，我們建立了一個名為 my_cookie 的 cookie，並將其 max_age 設置為 0。這意味著該 cookie 的存活時間為 0 秒，瀏覽器將立即刪除它。 使用 session雖然 cookie 是一種非常方便的儲存使用者設置和資料的方式，但是在一些情況下，它們可能不夠安全。為了增強安全性，Flask 提供了一種名為 session 的機制，它會在伺服器端儲存使用者資料，並使用一個加密的 cookie 將使用者資料傳遞給使用者瀏覽器。以下是一個簡單的 Flask 應用程式，演示如何使用 session： 1234567891011121314from flask import Flask, sessionapp = Flask(__name__)app.secret_key = 'my_secret_key'@app.route('/')def index(): session['my_session'] = 'my_value' return 'Setting a session!'@app.route('/get_session')def get_session(): my_session = session.get('my_session') return f'The value of my_session is {my_session}' 在上面的程式碼中，我們使用 session 物件儲存使用者資料。在設置 session 時，我們可以像設置字典一樣設置 session 的鍵和值。在讀取 session 時，我們使用 session.get() 方法。需要注意的是，使用 session 時需要設置 app.secret_key 屬性，該屬性是用於加密 session 的關鍵。 使用情境以下是使用 Python Flask 框架來實現一些使用 Cookie 的範例： 使用者身份驗證1234567891011121314151617from flask import Flask, request, make_responseapp = Flask(__name__)@app.route('/')def index(): resp = make_response('Welcome!') resp.set_cookie('user_id', '123') return resp@app.route('/dashboard')def dashboard(): user_id = request.cookies.get('user_id') if user_id == '123': return 'Dashboard' else: return 'Unauthorized' 在上面的程式碼中，當使用者訪問首頁時，我們設置了一個名為 user_id 的 cookie，其值為 123。當使用者訪問儀表板頁面時，我們讀取了 user_id cookie 的值，並檢查其是否等於 123。如果相等，則返回儀表板頁面，否則返回未經授權的錯誤。 記住使用者首選設置12345678910111213141516from flask import Flask, request, make_responseapp = Flask(__name__)@app.route('/')def index(): lang = request.cookies.get('lang', 'en') resp = make_response(f'Language: {lang}') resp.set_cookie('lang', lang) return resp@app.route('/set_lang/&lt;lang&gt;')def set_lang(lang): resp = make_response('Language set!') resp.set_cookie('lang', lang) return resp 在上面的程式碼中，我們讀取了名為 lang 的 cookie 的值，並將其用作網站的語言。如果 cookie 不存在，我們默認使用英語。當使用者訪問網站時，我們將 lang cookie 的值設置為當前語言。如果使用者訪問 /set_lang/&lt;lang&gt; 頁面，我們將 lang cookie 的值設置為使用者指定的語言。 記住使用者在線狀態123456789101112131415from flask import Flask, request, make_responseapp = Flask(__name__)@app.route('/')def index(): resp = make_response('Welcome!') resp.set_cookie('online', 'true') return resp@app.route('/logout')def logout(): resp = make_response('Logged out!') resp.set_cookie('online', 'false') return resp 在上面的程式碼中，當使用者訪問首頁時，我們設置了一個名為 online 的 cookie，其值為 true，表示使用者在線。當使用者訪問登出頁面時，我們將 online cookie 的值設置為 false，表示使用者離線。 記住使用者的購物車1234567891011121314151617181920212223242526272829from flask import Flask, request, make_responseapp = Flask(__name__)@app.route('/')def index(): resp = make_response('Welcome to our store!') resp.set_cookie('cart', '') return resp@app.route('/add_to_cart/&lt;item&gt;')def add_to_cart(item): cart = request.cookies.get('cart') if cart: cart += f',{item}' else: cart = item resp = make_response(f'{item} added to cart!') resp.set_cookie('cart', cart) return resp@app.route('/view_cart')def view_cart(): cart = request.cookies.get('cart') if cart: items = cart.split(',') return f'Items in your cart: {&quot;, &quot;.join(items)}' else: return 'Your cart is empty' 在上面的程式碼中，當使用者訪問首頁時，我們設置了一個名為 cart 的 cookie，其值為空，表示使用者的購物車是空的。當使用者訪問添加到購物車頁面時，我們讀取 cart cookie 的值，將新的項目添加到購物車中，然後更新 cart cookie 的值。當使用者訪問查看購物車頁面時，我們讀取 cart cookie 的值，並顯示購物車中的所有項目。 記住使用者的瀏覽歷史12345678910111213141516171819202122232425262728from flask import Flask, request, make_responseapp = Flask(__name__)@app.route('/')def index(): resp = make_response('Welcome to our store!') resp.set_cookie('history', '') return resp@app.route('/view_product/&lt;product&gt;')def view_product(product): history = request.cookies.get('history') if history: products = history.split(',') if product not in products: history += f',{product}' else: history = product resp = make_response(f'Viewing product: {product}') resp.set_cookie('history', history) return resp@app.route('/view_history')def view_history(): history = request.cookies.get('history') if history: products = history.split 總結在 Flask 中，使用 cookie 是一種非常簡單和方便的方式，可以儲存使用者設置和資料。在上面的教學中，我們學習了如何設置、讀取和刪除 cookie，以及如何使用 session 增強安全性。通過這些方法，我們可以更加靈活地設計 Flask 應用程式，以滿足不同的需求。 參考資料 OverIQ：簡單介紹 Flask 中如何使用 set_cookie() 方法設置 cookie。 GeeksforGeeks：提供 Flask cookie 的概述，並介紹如何設置和讀取 cookie。 Flask documentation：官方 Flask 文件，提供全面的關於 cookie 的指南，包括如何設置、讀取、刪除 cookie，以及使用 session。 Python Basics：簡單介紹在 Flask 中如何使用 make_response() 函數和 set_cookie() 方法來設置 cookie。 Stack Overflow：Stack Overflow 討論串，討論了在 Flask 中設置 cookie 會面臨的問題以及如何解決。 Protutorialplus：提供了如何在 Python Flask 中設置和讀取 cookie 的簡單教學。","link":"/2023/02/16/python-flask/06-flask-cookie/"},{"title":"【 Flask 教學 】 透過 URL 傳遞參數與透過表單傳遞","text":"通過 URL 傳遞參數嗨，動態路由你好！Flask 是一個輕量級的 Web 框架，提供了簡單易用的路由定義和視圖函數。其中一個優勢是通過 URL 傳遞參數的能力，也就是動態路由。在這個路由方式下，URL 中的一部分可以作為參數傳遞到視圖函數中，從而實現不同的動態內容呈現。 123@app.route('/greet/&lt;name&gt;')def greet(name): return f'Hello, {name}!' 此路由接受 URL 中的 name 參數，我們可以通過 name 參數在函數中訪問它。例如，如果我們輸入網址 http://localhost:5000/greet/Bob，我們將在頁面上看到 “Hello, Bob!”。 在 Flask 中，使用動態路由需要在路由定義中使用 &lt;parameter_name&gt; 語法，指定要傳遞的參數名稱。這個參數可以是任何類型的資料，包括整數、字符串、浮點數等等。在視圖函數中，我們可以使用這個參數來生成不同的內容。 根據網址的文章 id 導向該篇文章下面我們來看一個具體的例子，假設我們有一個博客網站，每一篇文章都有一個獨特的 ID，我們希望通過 URL 顯示不同的文章內容。那麼，我們可以使用以下的路由定義： 1234@app.route('/article/&lt;int:article_id&gt;')def show_article(article_id): # 在這裡使用 article_id 來顯示文章內容 return '這是文章 %d 的內容' % article_id 在上述程式碼中，&lt;int:article_id&gt; 指定了我們要傳遞一個整數類型的參數 article_id。在視圖函數 show_article 中，我們使用了這個參數來顯示文章內容。這個函數只是一個簡單的範例，實際情況中，我們可以從資料庫中獲取文章內容，然後將其呈現在網頁上。 當使用者訪問 /article/123 時，Flask 會自動提取 URL 中的 123，並將其傳遞到 show_article 視圖函數中。因為我們使用了 &lt;int:article_id&gt;，Flask 會自動確認 123 是一個整數類型的資料，並將其轉換成 article_id 參數的值。然後，視圖函數會使用 article_id 來顯示文章內容。 顯示名稱為 username 的使用者資料在 Flask 中，我們可以使用多個動態路由參數，例如： 1234@app.route('/@app.route('/user/&lt;username&gt;/int:user_id')')def show_user(username, user_id): # 在這裡使用 username 和 user_id 來顯示使用者資料 return '使用者名是 %s，ID 是 %d' % (username, user_id) 在這個路由定義中，我們使用了兩個動態路由參數，&lt;username&gt; 和 &lt;int:user_id&gt;。在視圖函數 show_user 中，我們使用了這兩個參數來顯示使用者資料。 動態路由注意事項使用動態路由時需要注意以下幾點： 參數的類型必須指定。在上面的例子中，我們使用 &lt;int:article_id&gt; 和 &lt;username&gt; 指定了參數的類型。 參數名稱必須和視圖函數中的參數名稱相同。 參數的類型轉換是自動進行的，如果轉換失敗，Flask 會返回 404 錯誤頁面。 總而言之，動態路由是 Flask 提供的一個強大的功能，可以讓我們通過 URL 傳遞參數，實現不同的動態內容呈現。通過 &lt;parameter_name&gt; 語法指定參數名稱和類型，在視圖函數中使用參數來生成不同的內容。使用時需要注意參數類型和名稱，以及類型轉換可能出現的錯誤。 透過表單傳遞資料範例程式以下是一個簡單的 Flask 程式，可以處理表單資料： 12345678910111213141516from flask import Flask, render_template, requestapp = Flask(__name__)@app.route('/')def index(): return render_template('index.html')@app.route('/submit', methods=['POST'])def submit(): name = request.form.get('name') age = request.form.get('age') return f'Hello {name}, you are {age} years old!'if __name__ == '__main__': app.run(debug=True) 這個程式定義了兩個路由： /：顯示一個網頁，該網頁包含一個表單，該表單要求使用者輸入姓名和年齡。 /submit：處理提交的表單資料，並顯示一條歡迎消息，包含使用者的姓名和年齡。 這個程式需要一個名為 index.html 的模板文件，該文件定義了表單的 HTML 程式碼。以下是 index.html 的範例程式碼： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Flask Form Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Enter your name and age:&lt;/h1&gt; &lt;form method=&quot;POST&quot; action=&quot;/submit&quot;&gt; &lt;label for=&quot;name&quot;&gt;Name:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt; &lt;br&gt; &lt;label for=&quot;age&quot;&gt;Age:&lt;/label&gt; &lt;input type=&quot;number&quot; name=&quot;age&quot; id=&quot;age&quot;&gt; &lt;br&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 這個模板文件顯示一個表單，要求使用者輸入姓名和年齡，然後提交表單。表單使用 POST 方法提交到 /submit 路由。 Flask 中的 request.form回頭看 Python 主程式 12345678910111213141516from flask import Flask, render_template, requestapp = Flask(__name__)@app.route('/')def index(): return render_template('index.html')@app.route('/submit', methods=['POST'])def submit(): name = request.form.get('name') age = request.form.get('age') return f'Hello {name}, you are {age} years old!'if __name__ == '__main__': app.run(debug=True) 在 Flask 中，request.form 是一個特殊的 Python 字典，用於處理 POST 方法所傳送的表單資料。當使用者在表單中輸入資料並提交時，POST 請求將表單資料打包在請求主體 (request body) 中，並將其傳送到伺服器。Flask 中的 request 物件可以獲取這些表單資料，request.form 字典會將表單中所有名為 “name” 的欄位值映射到 request.form['name'] 的字典鍵上。 在這段程式碼中，submit() 函數使用 request.form.get() 方法從提交的表單資料中獲取使用者名字和年齡。request.form.get() 方法的作用是從 request.form 字典中獲取指定名稱的值，如果字典中不存在指定名稱的值，則返回 None。例如，name = request.form.get('name') 將會從 POST 請求中獲取名為 “name” 的欄位值，如果不存在這個欄位則返回 None。同理，age = request.form.get('age') 則會從 POST 請求中獲取名為 “age” 的欄位值。最後，這些表單資料可以用來產生回應內容，如 “Hello {name}, you are {age} years old!”。 當使用者提交表單時，Flask 調用 submit 函數處理表單資料。這個函數從 request 對象中獲取 name 和 age 字段的值，然後使用這些值顯示一條歡迎訊息。 請注意，在實際應用中，你應該對提交的資料進行驗證和清理，以防止不良使用者輸入無效資料或惡意資料。你還應該對資料進行適當的安全處理，以保護你的應用免受攻擊。 總結在這個教學中，我們學習了如何在 Flask 中定義路由以及如何處理 URL 參數和表單資料。Flask 為構建 Web 應用程式提供了一個靈活而強大的框架，了解如何定義路由是構建任何 Flask 應用程式的關鍵部分。","link":"/2023/02/16/python-flask/07-dynanic_route_and_forms/"}],"tags":[],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"基礎教學","slug":"Python/基礎教學","link":"/categories/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/"},{"name":"Flask 教學","slug":"Python/Flask-教學","link":"/categories/Python/Flask-%E6%95%99%E5%AD%B8/"}]}